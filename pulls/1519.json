{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519",
    "id": 1831748262,
    "node_id": "PR_kwDOAP4Jqs5tLkKm",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1519.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1519.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/592f2517c44c25009e3021d06ff4ed9c8eee9069",
    "number": 1519,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add BIP352 `silentpayments` module",
    "user": {
      "login": "josibake",
      "id": 7444140,
      "node_id": "MDQ6VXNlcjc0NDQxNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/josibake",
      "html_url": "https://github.com/josibake",
      "followers_url": "https://api.github.com/users/josibake/followers",
      "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
      "organizations_url": "https://api.github.com/users/josibake/orgs",
      "repos_url": "https://api.github.com/users/josibake/repos",
      "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/josibake/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This PR adds a new Silent Payments ([BIP352](https://github.com/bitcoin/bips/pull/1458)) module to secp256k1. It is a continuation of the work started in https://github.com/bitcoin-core/secp256k1/pull/1471.\r\n\r\nThe module implements the full protocol, except for transaction input filtering and silent payment address encoding / decoding as those will be the responsibility of the wallet software. It is organized with functions for sending (prefixed with `_sender`) and receiving (prefixed by `_recipient`).\r\n\r\n#### For sending\r\n\r\n1. Collect private keys into two lists: `taproot_seckeys` and `plain_seckeys`\r\n    Two lists are used since the `taproot_seckeys` may need negation. `taproot_seckeys` are passed as keypairs to avoid the function needing to compute the public key to determine parity. `plain_seckeys` are passed as just secret keys\r\n2. Create the `_silentpayment_recipient` objects\r\n    These structs hold the scan and spend public key and an index for remembering the original ordering. It is expected that a caller will start with a list of silent payment addresses (with the desired amounts), convert these into an array of `recipients` and then match the generated outputs back to the original silent payment addresses. The index is used to return the generated outputs in the original order\r\n3. Call `silentpayments_sender_create_outputs` to generate the xonly public keys for the recipients\r\n    This function can be called with one or more recipients. The same recipient may be repeated to generate multiple outputs for the same recipient\r\n    \r\n#### For scanning\r\n\r\n1. Collect the public keys into two lists `taproot_pubkeys` and `plain_pubeys`\r\n    This avoids the caller needing to convert taproot public keys into compressed public keys (and vice versa)\r\n2. Compute the input data needed, i.e. sum the public keys and compute the `input_hash`\r\n    This is done as a separate step to allow the caller to reuse this output if scanning for multiple scan keys. It also allows a caller to use this function for aggregating the transaction inputs and storing them in an index to vend to light clients later (or for faster rescans when recovering a wallet)\r\n4. Call `silentpayments_recipient_scan_outputs` to scan the transaction outputs and return the tweak data (and optionally label information) needed for spending later\r\n\r\nIn addition, a few utility functions for labels are provided for the recipient for creating a label tweak and tweaked spend public key for their address. Finally, two functions are exposed in the API for supporting light clients, `_recipient_created_shared_secret` and `_recipient_create_output_pubkey`. These functions enable incremental scanning for scenarios where the caller does not have access to the transaction outputs:\r\n\r\n1. Calculating a shared secret\r\n    This is done as a separate step to allow the caller to reuse the shared secret result when creating outputs and avoid needing to do a costly ECDH every time they need to check for an additional output\r\n3. Generate an output (with `k = 0`)\r\n5. Check if the output exists in the UTXO set (using their preferred light client protocol)\r\n6. If the output exists, proceed by generating a new output from the shared secret with `k++`\r\n\r\nSee `examples/silentpayments.c` for a demonstration of how the API is expected to be used.\r\n\r\n### Note for reviewers\r\n\r\nMy immediate goal is to get feedback on the API so that I can pull this module into https://github.com/bitcoin/bitcoin/pull/28122 (silent payments in the bitcoin core wallet). That unblocks from finishing the bitcoin core PRs while work continues on this module.\r\n\r\n#### Notable differences between this PR and the previous version\r\n\r\nSee https://github.com/bitcoin-core/secp256k1/issues/1427 and https://github.com/bitcoin-core/secp256k1/pull/1471 for discussions on the API design. This iteration of the module attempts to be much more high level and incorporate the feedback from #1471. I also added a `secp256k1_silentpayments_public_data` opaque data type, which contains the summed public key and the input_hash. My motivation here was:\r\n\r\n1. I caught myself mixing up the order of arguments between `A_sum` and `recipient_spend_key`, which was impossible to catch with `ARG_CHECKS` and would result in the scanning process finishing without errors, but not finding any outputs\r\n2. Combining public key and input_hash into the same data type allows for completely hiding `input_hash` from the caller, which makes for an overall simpler API IMO\r\n\r\nI also removed the need for the recipient to generate a shared secret before using the `secp256k1_silentpayments_recipient_scan_outputs` function and instead create the shared secret inside the function.\r\n\r\n### Outstanding work\r\n\r\n- [ ] clean up the testing code\r\n- [ ] improve test coverage (currently only using the BIP352 test vectors)\r\n- [ ] optimize the implementation, where possible",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones/8",
      "html_url": "https://github.com/bitcoin-core/secp256k1/milestone/8",
      "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones/8/labels",
      "id": 11842907,
      "node_id": "MI_kwDOAP4Jqs4AtLVb",
      "number": 8,
      "state": "open",
      "title": "0.7.0",
      "description": "",
      "creator": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "open_issues": 2,
      "closed_issues": 2,
      "created_at": "2024-11-04T16:42:33Z",
      "updated_at": "2025-03-13T07:29:53Z",
      "due_on": "2025-04-20T07:00:00Z"
    },
    "created_at": "2024-04-19T14:21:15Z",
    "updated_at": "2025-03-20T17:36:02Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merged": false,
    "merge_commit_sha": "923b01e4c4b9a00763049f4c6e79ddeeee6386d5",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "josibake:bip352-silentpayments-module",
      "ref": "bip352-silentpayments-module",
      "sha": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 751433786,
        "node_id": "R_kgDOLMn4Og",
        "name": "secp256k1",
        "full_name": "josibake/secp256k1",
        "owner": {
          "login": "josibake",
          "id": 7444140,
          "node_id": "MDQ6VXNlcjc0NDQxNDA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/josibake",
          "html_url": "https://github.com/josibake",
          "followers_url": "https://api.github.com/users/josibake/followers",
          "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
          "organizations_url": "https://api.github.com/users/josibake/orgs",
          "repos_url": "https://api.github.com/users/josibake/repos",
          "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/josibake/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/josibake/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/josibake/secp256k1",
        "archive_url": "https://api.github.com/repos/josibake/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/josibake/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/josibake/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/josibake/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/josibake/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/josibake/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/josibake/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/josibake/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/josibake/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/josibake/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/josibake/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/josibake/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/josibake/secp256k1/events",
        "forks_url": "https://api.github.com/repos/josibake/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/josibake/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/josibake/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/josibake/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/josibake/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/josibake/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/josibake/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/josibake/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/josibake/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/josibake/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/josibake/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/josibake/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/josibake/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/josibake/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/josibake/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/josibake/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:josibake/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/josibake/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/josibake/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/josibake/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/josibake/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/josibake/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/josibake/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/josibake/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/josibake/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/josibake/secp256k1/hooks",
        "svn_url": "https://github.com/josibake/secp256k1",
        "language": "C",
        "forks_count": 1,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 12844,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-03-20T17:04:25Z",
        "created_at": "2024-02-01T15:52:50Z",
        "updated_at": "2025-03-17T10:40:51Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "70f149b9a1bf4ed3266f97774d0ae9577534bf40",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1042,
        "stargazers_count": 2185,
        "watchers_count": 2185,
        "size": 12237,
        "default_branch": "master",
        "open_issues_count": 140,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-03-13T18:40:39Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2025-03-18T05:53:49Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 9903,
    "deletions": 12,
    "changed_files": 24,
    "commits": 10,
    "review_comments": 369,
    "comments": 52
  },
  "events": [
    {
      "event": "labeled",
      "id": 12541859026,
      "node_id": "LE_lADOAP4Jqs6GTERUzwAAAALrjZTS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12541859026",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-19T16:18:02Z",
      "label": {
        "name": "feature",
        "color": "731E95"
      }
    },
    {
      "event": "reviewed",
      "id": 2015096769,
      "node_id": "PRR_kwDOAP4Jqs54G-_B",
      "url": null,
      "actor": null,
      "commit_id": "3d080277895655e8274ee73aacd154c4ead143e3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nLeft some initial feedback, especially around the scanning routine, will do an in-depth review round soon. Didn't look closer at the `public_data` type routines and the examples yet.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2015096769",
      "submitted_at": "2024-04-22T16:26:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12588114369,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAALuT2HB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12588114369",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8b48bf19c3c020e653734f6c9d9364e6a47a30d1",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/8b48bf19c3c020e653734f6c9d9364e6a47a30d1",
      "created_at": "2024-04-24T08:38:21Z"
    },
    {
      "event": "commented",
      "id": 2074419309,
      "node_id": "IC_kwDOAP4Jqs57pSBt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2074419309",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T08:45:36Z",
      "updated_at": "2024-04-24T08:45:36Z",
      "author_association": "MEMBER",
      "body": "Rebased on #1518 (https://github.com/bitcoin-core/secp256k1/commit/3d080277895655e8274ee73aacd154c4ead143e3 -> https://github.com/bitcoin-core/secp256k1/commit/8b48bf19c3c020e653734f6c9d9364e6a47a30d1, [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-01..josibake:secp256k1:bip352-silentpayments-module-rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2074419309",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12588974018,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAALuXH_C",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12588974018",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f5585d4b93606144e76e45ad3d43a797a9afefcf",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/f5585d4b93606144e76e45ad3d43a797a9afefcf",
      "created_at": "2024-04-24T09:38:43Z"
    },
    {
      "event": "commented",
      "id": 2074531708,
      "node_id": "IC_kwDOAP4Jqs57ptd8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2074531708",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T09:39:20Z",
      "updated_at": "2024-04-24T09:39:20Z",
      "author_association": "MEMBER",
      "body": "Updated https://github.com/bitcoin-core/secp256k1/commit/8b48bf19c3c020e653734f6c9d9364e6a47a30d1 -> https://github.com/bitcoin-core/secp256k1/commit/f5585d4b93606144e76e45ad3d43a797a9afefcf ([bip352-silentpayments-module-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-rebase) -> [bip352-silentpayments-module-02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-02), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-rebase..josibake:secp256k1:bip352-silentpayments-module-02)):\r\n\r\n* Fix function documentation for `_recipient_scan_outputs`\r\n* Replace `VERIFY_CHECK` with `return 0;` in `_sender_create_outputs`\r\n* Remove unneeded `declassify` code from `_sender_create_outputs`\r\n* Change `_gej_add_ge` to `_gej_add_var` in `_recipient_public_data_create`\r\n* Fix label scanning in `_recipient_scan_outputs`\r\n* Remove unneeded prints from the tests\r\n\r\nFor the label scanning, I looked for an example of using an invalid public key but didn't see anything except for the `invalid_pubkey_bytes` in the tests. For now, if the output is found without a label, I'm setting `found_with_label = 0` and saving the found output in both the `output` and `label` field. Happy to change this if there is a better suggestion for communicating an invalid public key.\r\n\r\nI also used `secp256k1_pubkey_save` instead of `output = *tx_outputs`, as I think this makes the code more clear.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2074531708",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "reviewed",
      "id": 2026864465,
      "node_id": "PRR_kwDOAP4Jqs54z39R",
      "url": null,
      "actor": null,
      "commit_id": "f5585d4b93606144e76e45ad3d43a797a9afefcf",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Second review round through, looks good so far! Left a bunch of nits, mostly about naming and missing ARG_CHECKS etc.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2026864465",
      "submitted_at": "2024-04-28T01:45:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12693217589,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAL0kyE1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693217589",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9d7519057155616993fcc121eecd6e72e54adfd7",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/9d7519057155616993fcc121eecd6e72e54adfd7",
      "created_at": "2024-05-03T08:03:39Z"
    },
    {
      "event": "mentioned",
      "id": 12693287039,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAL0lDB_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693287039",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:10:24Z"
    },
    {
      "event": "subscribed",
      "id": 12693287051,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAL0lDCL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693287051",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:10:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12693404541,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAL0lft9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693404541",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1a3a00bd0999a89e30d5dc9f927592ead72ab7a3",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/1a3a00bd0999a89e30d5dc9f927592ead72ab7a3",
      "created_at": "2024-05-03T08:21:32Z"
    },
    {
      "event": "commented",
      "id": 2092544520,
      "node_id": "IC_kwDOAP4Jqs58ubII",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2092544520",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:25:39Z",
      "updated_at": "2024-05-03T08:25:39Z",
      "author_association": "MEMBER",
      "body": "Thanks for the thorough review, @theStack ! I've addressed your feedback, along with some other changes.\r\n\r\n---\r\nUpdate https://github.com/bitcoin-core/secp256k1/commit/f5585d4b93606144e76e45ad3d43a797a9afefcf -> https://github.com/bitcoin-core/secp256k1/commit/1a3a00bd0999a89e30d5dc9f927592ead72ab7a3 ([bip352-silentpayments-module-02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-02) -> [bip352-silentpayments-module-03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-03), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-02..josibake:secp256k1:bip352-silentpayments-module-03))\r\n\r\n* Spelling and wording cleanups, notably:\r\n  *  `s/receiver/recipient/`, `s/labeled/labelled/`\r\n  * `s/scan_seckey/scan_key/`\r\n* Reduce duplicate code in `scan_outputs`\r\n* Add `ARG_CHECK`s\r\n* Update tests\r\n* Add benchmark for `scan_outputs`\r\n\r\nThe sending tests now check that the generated outputs match exactly one of the possible expected output sets. Previously, the sending tests were checking that the generated outputs exist in the array of all possible outputs, but this wouldn't catch a bug where `k` is not being set correctly e.g.  *[A<sub>k=0</sub>, B<sub>k=0</sub>]* would (incorrectly) pass *[A<sub>k=0</sub>, B<sub>k=1</sub>, A<sub>k=1</sub>, B<sub>k=0</sub>]* but will now (correctly) fail *[[A<sub>k=0</sub>, B<sub>k=1</sub>], [A<sub>k=1</sub>, B<sub>k=0</sub>]]*",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2092544520",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 12693448859,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAL0lqib",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693448859",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:25:40Z"
    },
    {
      "event": "subscribed",
      "id": 12693448875,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAL0lqir",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693448875",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:25:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12695113793,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAL0sBBB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12695113793",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "92f592023f3f4d6a66724772349fbdc4967ab50f",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/92f592023f3f4d6a66724772349fbdc4967ab50f",
      "created_at": "2024-05-03T11:11:55Z"
    },
    {
      "event": "commented",
      "id": 2092802286,
      "node_id": "IC_kwDOAP4Jqs58vaDu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2092802286",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T11:17:30Z",
      "updated_at": "2024-05-03T11:17:30Z",
      "author_association": "MEMBER",
      "body": "Rebased on #1518 https://github.com/bitcoin-core/secp256k1/commit/1a3a00bd0999a89e30d5dc9f927592ead72ab7a3 -> https://github.com/bitcoin-core/secp256k1/commit/92f592023f3f4d6a66724772349fbdc4967ab50f ([bip352-silentpayments-module-03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-03) -> [bip352-silentpayments-module-03-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-03-rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-03..josibake:secp256k1:bip352-silentpayments-module-03-rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2092802286",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12743423674,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAL3kTa6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12743423674",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "56ed901b6a2239e8b44a1a3f084bd38b9e86d769",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/56ed901b6a2239e8b44a1a3f084bd38b9e86d769",
      "created_at": "2024-05-08T12:48:24Z"
    },
    {
      "event": "commented",
      "id": 2100507478,
      "node_id": "IC_kwDOAP4Jqs59MzNW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2100507478",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-08T12:50:33Z",
      "updated_at": "2024-05-08T12:50:33Z",
      "author_association": "MEMBER",
      "body": "Rebased on master (following #1518 merge) https://github.com/bitcoin-core/secp256k1/commit/92f592023f3f4d6a66724772349fbdc4967ab50f -> https://github.com/bitcoin-core/secp256k1/commit/56ed901b6a2239e8b44a1a3f084bd38b9e86d769 ([bip352-silentpayments-module-03-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-03-rebase) -> [bip352-silentpayments-module-04-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-04-rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-03-rebase..josibake:secp256k1:bip352-silentpayments-module-04-rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2100507478",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "reviewed",
      "id": 2082332210,
      "node_id": "PRR_kwDOAP4Jqs58Hd4y",
      "url": null,
      "actor": null,
      "commit_id": "56ed901b6a2239e8b44a1a3f084bd38b9e86d769",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Went through another round. To the best of my knowledge, this PR matches the BIP352 specification and I'm close to non-cryptographer-light-ACKing it :-)\r\n\r\nFound some nits an one open TODO that should probably be discussed though.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2082332210",
      "submitted_at": "2024-05-28T18:19:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12999995271,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMG3C-H",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12999995271",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bd66eaa22acf434f0134d7f93c4fb694303708c3",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/bd66eaa22acf434f0134d7f93c4fb694303708c3",
      "created_at": "2024-05-31T12:34:48Z"
    },
    {
      "event": "commented",
      "id": 2142009213,
      "node_id": "IC_kwDOAP4Jqs5_rHd9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142009213",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T12:36:59Z",
      "updated_at": "2024-05-31T12:36:59Z",
      "author_association": "MEMBER",
      "body": "Rebased on master to fix merge conflict https://github.com/bitcoin-core/secp256k1/commit/56ed901b6a2239e8b44a1a3f084bd38b9e86d769 ->  https://github.com/bitcoin-core/secp256k1/commit/bd66eaa22acf434f0134d7f93c4fb694303708c3 ([bip352-silentpayments-module-04-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-04-rebase) -> [bip352-silentpayments-module-05-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-05-rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-04-rebase..josibake:secp256k1:bip352-silentpayments-module-05-rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142009213",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2142037343,
      "node_id": "IC_kwDOAP4Jqs5_rOVf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142037343",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T12:45:21Z",
      "updated_at": "2024-05-31T12:45:21Z",
      "author_association": "MEMBER",
      "body": "CI failure seems related to not being able to install valgrind via homebrew and unrelated to my change so ignoring for now (cc @real-or-random for confirmation?). ",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142037343",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13000125756,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMG3i08",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13000125756",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T12:45:22Z"
    },
    {
      "event": "subscribed",
      "id": 13000125772,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMG3i1M",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13000125772",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T12:45:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13000777915,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMG6CC7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13000777915",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2dde8f1fa13687d2bd8328f85ac412a4052b040c",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/2dde8f1fa13687d2bd8328f85ac412a4052b040c",
      "created_at": "2024-05-31T13:37:03Z"
    },
    {
      "event": "commented",
      "id": 2142198112,
      "node_id": "IC_kwDOAP4Jqs5_r1lg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142198112",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T13:45:02Z",
      "updated_at": "2024-05-31T13:45:02Z",
      "author_association": "MEMBER",
      "body": "Thanks for the review @theStack ! Sorry for the slow response, I somehow missed the notification for your review :sweat_smile: \r\n\r\n---\r\n\r\nUpdate https://github.com/bitcoin-core/secp256k1/commit/bd66eaa22acf434f0134d7f93c4fb694303708c3 -> https://github.com/bitcoin-core/secp256k1/commit/2dde8f1fa13687d2bd8328f85ac412a4052b040c ([bip352-silentpayments-module-05-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-05-rebase) -> [bip352-silentpayments-module-06](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-06), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-05-rebase..josibake:secp256k1:bip352-silentpayments-module-06))\r\n\r\n* spelling, grammar, and fixups per @theStack 's review\r\n* Added `ARG_CHECK`s to check for the sum of the private keys / public keys being zero\r\n\r\nPer https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617720108, I agree returning 0 is not the right thing to do, but having multiple error codes also seemed gross. I think an `ARG_CHECK` makes sense here because if the caller passed all valid seckeys / pubkeys and then they sum to zero, in principle its the caller passing incorrect arguments. The only thing the caller can do at this point is try again with different arguments. For the sender, this would mean repeating coin selection to get a different input set, and for the recipient this would mean skipping the transaction and moving on to the next one. Also happy to change if there is a better suggestion!",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142198112",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13000887002,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMG6cra",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13000887002",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T13:45:03Z"
    },
    {
      "event": "subscribed",
      "id": 13000887022,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMG6cru",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13000887022",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T13:45:03Z"
    },
    {
      "event": "commented",
      "id": 2142338498,
      "node_id": "IC_kwDOAP4Jqs5_sX3C",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142338498",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T14:22:24Z",
      "updated_at": "2024-05-31T14:22:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "> CI failure seems related to not being able to install valgrind via homebrew and unrelated to my change so ignoring for now (cc @real-or-random for confirmation?). \r\n\r\nIndeed, see https://github.com/bitcoin-core/secp256k1/issues/1536\r\n\r\n",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142338498",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13001464326,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMG8poG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13001464326",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T14:22:25Z"
    },
    {
      "event": "subscribed",
      "id": 13001464349,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMG8pod",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13001464349",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T14:22:25Z"
    },
    {
      "event": "commented",
      "id": 2142599641,
      "node_id": "IC_kwDOAP4Jqs5_tXnZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142599641",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T16:23:47Z",
      "updated_at": "2024-05-31T16:24:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "\r\n## Some general notes\r\n### On error handling in general\r\nError handling is hard, and the caller usually can't really recover from an error anyway. This is in particular true on malicious inputs:  there's no reason to try to continue dealing with the attacker, and you simply want to abort. That's why, as a general rule, we try to avoid error paths as much as possible. This usually boils down to merging all errors into a single one, i.e., *a)* have just a single error \"code\" for all possible errors, *b)* and in the case of a multi-stage thing involving multiple function calls, have just a single place where errors are returned. \r\n\r\nSignature verification is a good example. A (signature, message, pubkey) triple is either valid or not. The caller *should not* care why exactly a signature fails to verify, so we don't even want to expose this to the caller.\r\n\r\n However, signature verification this is also a nice example of a case in which we stretch the rules a bit. Signature verification is implemented as two-stage process: 1. Parse the public key (which can fail). 2. Check the signature (which can fail). Purely from a \"safe\" API point of view, this is not great because we give the user two functions and two error paths instead of one. Ideally, there could just be one verification function which also takes care of parsing (this is how it's defined BIP340). The primary reason why we want to have a separate parsing function in this case is performance: if you check several signatures under the same key, you don't want to parse, which involves computing the y-coordinate, every time.\r\n\r\n### ARG_CHECK\r\n`ARG_CHECK` will call the \"illegal (argument) callback\", which, by default, crashes. See the docs here: https://github.com/bitcoin-core/secp256k1/blob/1791f6fce4d4856a4ce2b1982768a4ffa23fcc0a/include/secp256k1.h#L324 The callback/crash indicates to the caller that there's a bug in the caller's code.\r\n\r\n## What does this mean for this discussion?\r\n> * Added `ARG_CHECK`s to check for the sum of the private keys / public keys being zero\r\n> \r\n> \r\n> Per [#1519 (comment)](https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617720108), I agree returning 0 is not the right thing to do, but having multiple error codes also seemed gross. I think an `ARG_CHECK` makes sense here because if the caller passed all valid seckeys / pubkeys and then they sum to zero, in principle its the caller passing incorrect arguments. The only thing the caller can do at this point is try again with different arguments. For the sender, this would mean repeating coin selection to get a different input set, and for the recipient this would mean skipping the transaction and moving on to the next one. Also happy to change if there is a better suggestion!\r\n\r\nSo let's take a look at the two sides:\r\n\r\n### On the sender side: The secret keys sum up to zero (`sum_i a_i = 0`)\r\nThis will happen only with negligible probability for honestly generated (=random) secret keys. That is, this will in practice only happen if the caller has a bug, or the caller has been tricked into using these secret keys, e.g., if someone else has crafted malicious secret keys for the caller. Since the latter is not a crazy scenario, we should not use `ARG_CHECK` here. \r\n\r\nWe can just return 0 here to indicate to the caller that we can't continue with these function inputs. And even if there are other error cases, I don't see a reason why the caller code should care much about why the function fails. As long as you call the function with honestly generated inputs, everything will work out. (Devs will be interested in the exact failure case when debugging the caller's code, but I think they can figure out during debugging then. \"Normal\" caller code should get just a single error code.)\r\n\r\n### On the recipient side: The public keys sum up to infinity (`sum_i A_i = 0`) [1]\r\nAgain, this can only happen if the sender is malicious. But since we're not the sender, it's entirely possible that the sender is malicious. And then these inputs are certainly legal, they're just not valid. (In the same sense as it's perfectly legal to use the signature verification algorithm on an invalid signature.) So an `ARG_CHECK` will not be appropriate at all: a malicious sender could trigger it and crash the scanning process. \r\n\r\nWe should also simply return 0 to indicate that this transaction is not well-formed/not eligible for SP. And again, even if there are other error cases, I don't see a reason why the caller should care why this transaction is not eligible.\r\n\r\nAlternatively, we could even return 1, store infinity in the `public_data`, and simply make sure that scanning won't find any payments in that case.  This would avoid the error path for this function entirely. But if the caller then calls `secp256k1_silentpayments_recipient_create_shared_secret`, I think we'd just postpone the error to this function, and for this function, I don't see another way than returning an error. So I'm not convinced that this is better. \r\n\r\n\r\n[1] We should perhaps rename \"infinity\" to \"zero\"... ;)\r\n",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142599641",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2142745728,
      "node_id": "IC_kwDOAP4Jqs5_t7SA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142745728",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T18:06:38Z",
      "updated_at": "2024-06-01T12:08:10Z",
      "author_association": "MEMBER",
      "body": "@real-or-random thanks for the response, this is super helpful.\r\n\r\n> Devs will be interested in the exact failure case when debugging the caller's code, but I think they can figure out during debugging then\r\n\r\nIn hindsight, I think my preference for `ARG_CHECK` was \"better error messages as to what went wrong,\" but I now realize it was because I was thinking as a dev ;). Also an oversight on my part: I didn't realize/forgot that `ARG_CHECK` is actually crashing the program by default. I certainly agree that we don't want this in either failure case.\r\n\r\n> Alternatively, we could even return 1, store infinity in the public_data, and simply make sure that scanning won't find any payments in that case. This would avoid the error path for this function entirely. But if the caller then calls secp256k1_silentpayments_recipient_create_shared_secret, I think we'd just postpone the error to this function, and for this function, I don't see another way than returning an error. So I'm not convinced that this is better.\r\n\r\nIf we imagine an index + light client scenario, the `public_data` would be created by the index and then sent to the light client, where the light client would call `secp256k1_silentpayments_recipient_create_shared_secret` (and then get the error). Given this, I think it would be better to have the error path so that the index ends up not storing any data at all for the malicious crafted transaction, which saves space for the index and bandwidth for the light client.\r\n\r\n---\r\n\r\nThinking about this a bit more:\r\n\r\n> That's why, as a general rule, we try to avoid error paths as much as possible. This usually boils down to merging all errors into a single one, i.e., a) have just a single error \"code\" for all possible errors, b) and in the case of a multi-stage thing involving multiple function calls, have just a single place where errors are returned.\r\n\r\nMost of the high-level functions in our API are calling multiple lower-level functions and so far the approach has been something like:\r\n\r\n```\r\nif (!secp256k1_func_that_returns_0_on_error(args)) {\r\n    return 0;\r\n}\r\n...\r\nif (!secp256k1_another_func_that_returns_0_on_error(args)) {\r\n    return 0;\r\n}\r\n```\r\n\r\n~~Perhaps its worth looking to consolidate and try and only return an error at the end of a multi-stage process? This would mean ignoring the return values for a lot of the lower level function calls, which initially made me feel a bit weird. But in light of your recent comment, feels like this might be the preferred approach?~~\r\n\r\nEDIT: reading your comment again, I realize \"error paths\" is not really talking about branches in the code and more error paths for the user.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142745728",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13004201610,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMHHF6K",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13004201610",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T18:06:39Z"
    },
    {
      "event": "subscribed",
      "id": 13004201641,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMHHF6p",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13004201641",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T18:06:39Z"
    },
    {
      "event": "commented",
      "id": 2143167510,
      "node_id": "IC_kwDOAP4Jqs5_viQW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2143167510",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-01T00:23:18Z",
      "updated_at": "2024-06-01T00:23:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "> We should also simply return 0 to indicate that this transaction is not well-formed/not eligible for SP. And again, even if there are other error cases, I don't see a reason why the caller should care why this transaction is not eligible.\r\n\r\nMakes sense. My worry was that without an explicit error-code for this corner case, some users wouldn't even be aware of an indirect \"not eligible\" case and more likely interpret a return value of 0 as \"only possible if there's a logic error on our side, so let's assert for success\" (given the passed in data is public and already verified for consensus-validity). But in the end that's more a matter of good API documentation I guess.\r\n\r\nAn example for the \"input public keys sum up to point of infinity\" case ($\\sum_i A_i = 0$) is now available on the Signet chain via tx [d73f4a19f3973e90af6df62e735bb7b31f3d5ab8e7e26e7950651b436d093313](https://mempool.space/signet/tx/d73f4a19f3973e90af6df62e735bb7b31f3d5ab8e7e26e7950651b436d093313) [1], mined in block 198023. It consists of two inputs spending P2WPKH prevouts with negated pubkeys $(x,y)$ and $(x,-y)$ (easy to verify by looking at the second item of the witness stack each, where only the first byte for encoding the sign bit differs), and one dummy P2TR output. It hopefully helps SP implementations to identify potential problems with this corner case early. As first example and proof that it triggers the discussed code path, it makes the Silent Payment Index PR [#28241](https://github.com/bitcoin/bitcoin/pull/28241) crash, which asserts on a return value of 1 for `_recipient_public_data_create`.\r\n\r\nI think it would be also a good idea to add this scenario to the BIP352 test vectors, or at least a unit test in this PR?\r\n\r\n[1] created with the following Python script: https://github.com/theStack/bitcoin/blob/202405-contrib-bip352_input_pubkeys_cancelled/contrib/silentpayments/submit_input_pubkeys_infinity_tx.py",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2143167510",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2144837459,
      "node_id": "IC_kwDOAP4Jqs5_159T",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2144837459",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-03T10:24:32Z",
      "updated_at": "2024-06-03T10:24:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "> \r\n> ~Perhaps its worth looking to consolidate and try and only return an error at the end of a multi-stage process? This would mean ignoring the return values for a lot of the lower level function calls, which initially made me feel a bit weird. But in light of your recent comment, feels like this might be the preferred approach?~\r\n> \r\n> EDIT: reading your comment again, I realize \"error paths\" is not really talking about branches in the code and more error paths for the user.\r\n\r\nRight, it's about avoiding errors that the user would need to deal with, e.g., by more branches on the user side. So the idea is that to try to avoid complexity in the user code, perhaps at the cost of adding complexity to our code. But let me also add that this and most all of what I above is more a rule of thumb than a strict policy.\r\n\r\n> > We should also simply return 0 to indicate that this transaction is not well-formed/not eligible for SP. And again, even if there are other error cases, I don't see a reason why the caller should care why this transaction is not eligible.\r\n> \r\n> Makes sense. My worry was that without an explicit error-code for this corner case, some users wouldn't even be aware of an indirect \"not eligible\" case and more likely interpret a return value of 0 as \"only possible if there's a logic error on our side, so let's assert for success\" (given the passed in data is public and already verified for consensus-validity). But in the end that's more a matter of good API documentation I guess.\r\n\r\nOkay, I see the concern. And I agree, this should probably be a matter of documentation. I think, assuming our code is correct, there won't be a reason to return 0 unless there's something wrong with the transaction (invalid public key, keys sum up to 0), and we should just list these reasons in the docs.\r\n\r\n> I think it would be also a good idea to add this scenario to the BIP352 test vectors, or at least a unit test in this PR?\r\n\r\nIndeed, this should be in the BIP, ideally even in the pseudocode. If our code starts to reject \"payments\", then better be authorized by the standard. And I believe it's the right approach: There's no need to add complexity to implementations to deal with these malicious cases.[^1]\r\n\r\n\r\n[^1]: One thing to keep in mind are multi-sender scenarios where blaming the malicious participant could be hard. Say honest A and B have pkA and pkB, and malicious C then claims to have pkC = -(pkA + pkC) s.t. pkA + pkB + pkC = 0. And then A and B can't conclude that C is malicious. We run into such a thing in the MuSig BIP, see the first paragraph of https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki#dealing-with-infinity-in-nonce-aggregation. But IIUC this cannot happen here since C needs to show a signature under pkC.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2144837459",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "subscribed",
      "id": 13034935158,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMI8VN2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13034935158",
      "actor": {
        "login": "sethforprivacy",
        "id": 40500387,
        "node_id": "MDQ6VXNlcjQwNTAwMzg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/40500387?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sethforprivacy",
        "html_url": "https://github.com/sethforprivacy",
        "followers_url": "https://api.github.com/users/sethforprivacy/followers",
        "following_url": "https://api.github.com/users/sethforprivacy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sethforprivacy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sethforprivacy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sethforprivacy/subscriptions",
        "organizations_url": "https://api.github.com/users/sethforprivacy/orgs",
        "repos_url": "https://api.github.com/users/sethforprivacy/repos",
        "events_url": "https://api.github.com/users/sethforprivacy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sethforprivacy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T11:37:20Z"
    },
    {
      "event": "referenced",
      "id": 13207691565,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMTPWEt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13207691565",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1ceb0b6986563854e0ffad280b4362821307ba50",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/1ceb0b6986563854e0ffad280b4362821307ba50",
      "created_at": "2024-06-18T22:47:19Z"
    },
    {
      "event": "referenced",
      "id": 13221274861,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMUDKTt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13221274861",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bbc706cf4f336c74b831966f61fa334d257a5288",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/bbc706cf4f336c74b831966f61fa334d257a5288",
      "created_at": "2024-06-19T22:11:18Z"
    },
    {
      "event": "referenced",
      "id": 13221312587,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMUDThL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13221312587",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a96df5abcbecb669427dd041a6d8c25e106536c2",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/a96df5abcbecb669427dd041a6d8c25e106536c2",
      "created_at": "2024-06-19T22:19:55Z"
    },
    {
      "event": "referenced",
      "id": 13221333509,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMUDYoF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13221333509",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3623b60784398b08abc6f9e74a9f74d51f4f2dea",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/3623b60784398b08abc6f9e74a9f74d51f4f2dea",
      "created_at": "2024-06-19T22:24:38Z"
    },
    {
      "event": "referenced",
      "id": 13221373766,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMUDidG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13221373766",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fe0f83531e35f76d3582813da4cbb518d9bb1d12",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/fe0f83531e35f76d3582813da4cbb518d9bb1d12",
      "created_at": "2024-06-19T22:33:46Z"
    },
    {
      "event": "referenced",
      "id": 13221425667,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMUDvID",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13221425667",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "630466657557b073549f02c130de7bf5799b1cfa",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/630466657557b073549f02c130de7bf5799b1cfa",
      "created_at": "2024-06-19T22:44:51Z"
    },
    {
      "event": "referenced",
      "id": 13247893873,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMVotFx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13247893873",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "59cc43d727000794f18dac0a502cd87c0daec22a",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/59cc43d727000794f18dac0a502cd87c0daec22a",
      "created_at": "2024-06-21T23:58:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13339201347,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMbFA9D",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13339201347",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ac591050262d9d00b629943d598f62b47e1ca7ae",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/ac591050262d9d00b629943d598f62b47e1ca7ae",
      "created_at": "2024-06-29T11:58:30Z"
    },
    {
      "event": "commented",
      "id": 2198126844,
      "node_id": "IC_kwDOAP4Jqs6DBMD8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2198126844",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-29T12:01:18Z",
      "updated_at": "2024-06-29T12:01:18Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/2dde8f1fa13687d2bd8328f85ac412a4052b040c -> https://github.com/bitcoin-core/secp256k1/commit/ac591050262d9d00b629943d598f62b47e1ca7ae ([bip352-silentpayments-module-06](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-06) -> [bip352-silentpayments-module-07](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-07), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-06..josibake:secp256k1:bip352-silentpayments-module-07))\r\n\r\n* Removes `ARG_CHECKS` for the sum to zero / infinity case\r\n* Adds the new test vector for sum to zero / infinity\r\n* Minor fix ups, e.g., `s/receiver/recipient`",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2198126844",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13377472438,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMdXAe2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13377472438",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5dd552ccbb5243047e0ad967561796f15a42bfbb",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/5dd552ccbb5243047e0ad967561796f15a42bfbb",
      "created_at": "2024-07-03T09:22:36Z"
    },
    {
      "event": "commented",
      "id": 2205622493,
      "node_id": "IC_kwDOAP4Jqs6DdyDd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2205622493",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-03T09:57:36Z",
      "updated_at": "2024-07-03T10:04:14Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/ac591050262d9d00b629943d598f62b47e1ca7ae -> https://github.com/bitcoin-core/secp256k1/commit/5dd552ccbb5243047e0ad967561796f15a42bfbb ([bip352-silentpayments-module-07](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-07) -> [bip352-silentpayments-module-08](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-08), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-07..josibake:secp256k1:bip352-silentpayments-module-08))\r\n\r\n(note: I also included a rebase inadvertently, so I rebased the `-07-rebase` branch as well to make comparing the diff easier with this [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-07-rebase..josibake:secp256k1:bip352-silentpayments-module-08) link)\r\n\r\nThe main change in this push is adding full test coverage for the module API. To make this easier, I ended up re-organizing the commits so that everything for sending is one commit, everything for labelled address is one commit, and everything for receiving is one commit. While this does make each commit larger, I think overall this makes things easier to review. I find it especially helpful to have the API tests in the same commit as it makes it easier to reason on how the functions will be used and makes it easy to modify the tests during testing to exercise the API.\r\n\r\nWhile adding the tests, I made the following implementation changes:\r\n\r\n* Only have `ARG_CHECKS` in functions exposed in the API. This meant removing `ARG_CHECKS` from some functions and adding them to others\r\n* Accumulate errors in a return value (i.e., use `ret &= func` instead of `if (!func) { return 0 }`\r\n  * In many cases where we were returning early, I couldn't think of a way to trigger an error in the function since the error would have already been caught with an `ARG_CHECK` or when initializing a struct. In these cases, it seemed better to remove the if branch and instead accumulate the error so that the function will still fail if an error is ever encountered\r\n* Some stylistic changes, e.g., comments and rewriting `ARG_CHECK` parsing for clarity\r\n\r\nRunning `gcov` after these changes shows that the test coverage for the module is ~100% :smile: \r\n![image](https://github.com/bitcoin-core/secp256k1/assets/7444140/fc3d8b26-5110-49ae-97db-447ea439092e)\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2205622493",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2205624871,
      "node_id": "IC_kwDOAP4Jqs6Ddyon",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2205624871",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-03T09:58:21Z",
      "updated_at": "2024-07-03T09:58:21Z",
      "author_association": "MEMBER",
      "body": "Not quite sure what is happening with the CI failures, since it looks like the all of the tests and examples are passing. Will investigate more and push a fix.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2205624871",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13380049035,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMdg1iL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13380049035",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1136e0c6aa6884d67d984d62f480986b9824db99",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/1136e0c6aa6884d67d984d62f480986b9824db99",
      "created_at": "2024-07-03T12:40:51Z"
    },
    {
      "event": "commented",
      "id": 2205997958,
      "node_id": "IC_kwDOAP4Jqs6DfNuG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2205997958",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-03T12:47:27Z",
      "updated_at": "2024-07-03T12:47:27Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/5dd552ccbb5243047e0ad967561796f15a42bfbb -> https://github.com/bitcoin-core/secp256k1/commit/1136e0c6aa6884d67d984d62f480986b9824db99\r\n\r\nCI was failing due to the benchmark executable. In the previous push, I added an `ARG_CHECK` that if a `label_lookup` callback is passed, `label_cache` cannot be NULL. However, I didn't run the benchmarks locally and missed that the benchmark was calling `_scan_outputs` with a label lookup callback but NULL labels cache. Fixed by passing a noop labels cache pointer. This is fine since the purpose of using the `label_lookup` in the benchmark isn't to actually scan for labels but to make sure that the label lookup branch of the code gets triggered during the benchmark.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2205997958",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "reviewed",
      "id": 2161055368,
      "node_id": "PRR_kwDOAP4Jqs6AzxaI",
      "url": null,
      "actor": null,
      "commit_id": "1136e0c6aa6884d67d984d62f480986b9824db99",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Looks generally good to me, I think the new structuring of the commits makes sense and reviewing is easier. One thing that should be taken care of (which I also only became fully aware of recently while reviewing the MuSig2 PR) is cleaning out secrets, as stated in CONTRIBUTING.md:\r\n\r\nhttps://github.com/bitcoin-core/secp256k1/blob/ca06e58b2ce18d170546ad13429fb9319451f48a/CONTRIBUTING.md?plain=1#L50\r\n\r\nI believe this should be applied at least to the following local variables (probably also to the shared secret ones):\r\n\r\n- `tweaked_secret_component` in `_create_shared_secret`\r\n- `a_sum_scalar`, `addend`, `a_sum` in `_sender_create_outputs`",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2161055368",
      "submitted_at": "2024-07-05T17:19:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2211644697,
      "node_id": "IC_kwDOAP4Jqs6D0wUZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2211644697",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-06T05:07:25Z",
      "updated_at": "2024-07-06T05:07:25Z",
      "author_association": "NONE",
      "body": "Looks good to me overall.\r\n\r\nWhy does `secp256k1_silentpayments_sender_create_outputs` have `const secp256k1_silentpayments_recipient **recipients` as parameter instead of `const secp256k1_silentpayments_recipient *recipients` ?\r\nIs there a specific reason for this ?\r\n `const secp256k1_silentpayments_recipient **recipients` can be somewhat confusing. Why not have a pointer to the first element of an array of `secp256k1_silentpayments_recipient` structures ?",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2211644697",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13436446210,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMg3-YC",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13436446210",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8ce68efb9511124877d50e40bcea1563e1384ef8",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/8ce68efb9511124877d50e40bcea1563e1384ef8",
      "created_at": "2024-07-09T09:06:52Z"
    },
    {
      "event": "commented",
      "id": 2217167478,
      "node_id": "IC_kwDOAP4Jqs6EJ0p2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2217167478",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:36:58Z",
      "updated_at": "2024-07-09T09:36:58Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/1136e0c6aa6884d67d984d62f480986b9824db99 -> https://github.com/bitcoin-core/secp256k1/commit/8ce68efb9511124877d50e40bcea1563e1384ef8 ([bip352-silentpayments-module-08](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-08) -> [bip352-silentpayments-module-09](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-09), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-08..josibake:secp256k1:bip352-silentpayments-module-09))\r\n\r\nPrimarily:\r\n\r\n* Replace `secp256k1_ecdh` with `ecmult_const`\r\n* Refactor `create_shared_secret`\r\n* Clear secrets at each stage\r\n\r\nI noticed while clearing the secrets that we were creating the shared secrets in a really inefficient way:\r\n\r\n* deserialize `unsigned char` seckeys into `secp256k1_scalars` and add them\r\n* serialize the summed scalar back to unsigned char so it can be passed to `secp256k1_ecdh`\r\n* deserialize inside `secp256k1_ecdh` back to a scalar :man_facepalming:, call `ecmult_const`\r\n* serialize the resulting point coordinates to unsigned char and pass them to the noop hash function\r\n* deserialize the unsigned char x,y pair back into a point :man_facepalming:\r\n* serialize the point into a compressed public key\r\n\r\nInstead, I opted to remove `secp256k1_ecdh` and just calculate the the shared secret directly with `ecmult_const`. This avoids a lot of back and forth with serializing and deserializing and allowed me to remove the rather complicated noop hash function. Since `secp256k1_ecdh` is calling `ecmult_const` under the hood, this should be the same. However, I did notice that `_cmov` is being called inside `secp256k1_ecdh`, which led me down a bit of a rabbit hole. I left some `TODO` comments in places where we deserialize the secret keys into scalars for future reviewers, because I'm not quite sure what the right approach here is (cc the friendly neighborhood cryptographers @real-or-random , @jonasnick ).\r\n\r\nI also refactored the `create_shared_secret` function to avoid needing to create an intermediate tweaked scalar, which also improves the readability of the code imo.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2217167478",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13436902021,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMg5tqF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13436902021",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:36:59Z"
    },
    {
      "event": "subscribed",
      "id": 13436902042,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMg5tqa",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13436902042",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:36:59Z"
    },
    {
      "event": "mentioned",
      "id": 13436902067,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMg5tqz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13436902067",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:37:00Z"
    },
    {
      "event": "subscribed",
      "id": 13436902089,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMg5trJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13436902089",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:37:00Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13437109160,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMg6gOo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13437109160",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a31a105e6dd9446be7694226fac0e8e7bfafe300",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/a31a105e6dd9446be7694226fac0e8e7bfafe300",
      "created_at": "2024-07-09T09:50:53Z"
    },
    {
      "event": "commented",
      "id": 2217198944,
      "node_id": "IC_kwDOAP4Jqs6EJ8Vg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2217198944",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:52:42Z",
      "updated_at": "2024-07-09T09:52:42Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/8ce68efb9511124877d50e40bcea1563e1384ef8 -> https://github.com/bitcoin-core/secp256k1/commit/a31a105e6dd9446be7694226fac0e8e7bfafe300 ([bip352-silentpayments-module-09](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-09) -> [bip352-silentpayments-module-10](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-10), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-09..josibake:secp256k1:bip352-silentpayments-module-10))\r\n\r\n* Also clear `recipient_scan_key` whenever it is loaded as a scalar (missed in the last push)",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2217198944",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2217225367,
      "node_id": "IC_kwDOAP4Jqs6EKCyX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2217225367",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T10:04:58Z",
      "updated_at": "2024-07-09T10:04:58Z",
      "author_association": "MEMBER",
      "body": "> Why does `secp256k1_silentpayments_sender_create_outputs` have `const secp256k1_silentpayments_recipient **recipients` as parameter instead of `const secp256k1_silentpayments_recipient *recipients` ?\r\n> Is there a specific reason for this ?\r\n\r\nThanks for the review, @jlest01 ! For the `_recipient` structs specifically, a pointer to an array of pointers is preferable for sorting the recipients in place. With an array of pointers each entry is 8 bytes vs with recipient structs each entry is ~136 bytes, making it more efficient to move the pointers around.\r\n\r\nIn general, pointers to an array of pointers is preferred as it provides more flexibility for the caller. For example, if the caller is using `n` inputs that all have the same public key, they can initialize the `secp256k1_pubkey` object once and then create a pointer to it `n` times. This is more efficient than requiring them to initialize `n` structs for the same public key.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2217225367",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13437325206,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMg7U-W",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13437325206",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T10:04:59Z"
    },
    {
      "event": "subscribed",
      "id": 13437325233,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMg7U-x",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13437325233",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T10:04:59Z"
    },
    {
      "event": "commented",
      "id": 2217447402,
      "node_id": "IC_kwDOAP4Jqs6EK4_q",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2217447402",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T11:54:35Z",
      "updated_at": "2024-07-09T11:54:35Z",
      "author_association": "NONE",
      "body": "Thanks for the clarification @josibake . Just out of curiosity. Is there a PR in bitcoin core that uses the interface being implemented here ?\r\nI would like to better understand how this interface is intended to interact with Bitcoin Core classes.",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2217447402",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13438810706,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMhA_pS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13438810706",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T11:54:37Z"
    },
    {
      "event": "subscribed",
      "id": 13438810721,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMhA_ph",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13438810721",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T11:54:37Z"
    },
    {
      "event": "reviewed",
      "id": 2166196376,
      "node_id": "PRR_kwDOAP4Jqs6BHYiY",
      "url": null,
      "actor": null,
      "commit_id": "a31a105e6dd9446be7694226fac0e8e7bfafe300",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Tested that `tests_silentpayments_generate.py` indeed produces `silentpayments/vectors.h` with the latest vectors. \r\n\r\n```\r\n6618bd9d3361f68ed0cdc139ec7c66365d81b6ce87c2119905225fab8ab833c9  send_and_receive_test_vectors.json\r\n```\r\n\r\nMaybe move the changes in `src/modules/silentpayments/tests_impl.h` to their own commit? It would make it slightly easier to review changes (before merge) in the test vectors vs. changes to their usage.\r\n\r\nI'm having a hard time modifying any of the test vectors in a way that makes the test fail. See one suggestion inline for a sanity check you could add. See also #1568.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2166196376",
      "submitted_at": "2024-07-09T12:38:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2166304629,
      "node_id": "PRR_kwDOAP4Jqs6BHy91",
      "url": null,
      "actor": null,
      "commit_id": "a31a105e6dd9446be7694226fac0e8e7bfafe300",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I find the send and receive example easy to follow (despite some feedback - and minus the label stuff), which suggests that this is a good interface.\r\n",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2166304629",
      "submitted_at": "2024-07-09T14:30:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2218081934,
      "node_id": "IC_kwDOAP4Jqs6ENT6O",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2218081934",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T15:58:23Z",
      "updated_at": "2024-07-09T15:58:23Z",
      "author_association": "MEMBER",
      "body": "Thanks for the review, @Sjors !\r\n\r\n> Maybe move the changes in `src/modules/silentpayments/tests_impl.h` to their own commit?\r\n\r\nThis is how it was structured before, but I found it much easier to work with having the tests in the same commit where functions are added to the API. This allows you to easily make changes to the API and the relevant tests in the same commit and also lets reviews step through each commit and verify that the commit compiles and passes the tests.\r\n\r\nWill digest your feedback on the `examples/silentpayments.c` and update!\r\n\r\n---\r\n\r\n> Just out of curiosity. Is there a PR in bitcoin core that uses the interface being implemented here ?\r\n\r\n@jlest01 all of the Bitcoin Core PRs can be found here: https://github.com/bitcoin/bitcoin/issues/28536\r\n\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2218081934",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13442724276,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMhP7G0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13442724276",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T15:58:25Z"
    },
    {
      "event": "subscribed",
      "id": 13442724295,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMhP7HH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13442724295",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T15:58:25Z"
    },
    {
      "event": "mentioned",
      "id": 13442724307,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMhP7HT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13442724307",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T15:58:25Z"
    },
    {
      "event": "subscribed",
      "id": 13442724315,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMhP7Hb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13442724315",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T15:58:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13472398761,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMjBH2p",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472398761",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4a8b707fa84819dda7a663a92c0e32f519f9bacf",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/4a8b707fa84819dda7a663a92c0e32f519f9bacf",
      "created_at": "2024-07-11T14:03:37Z"
    },
    {
      "event": "commented",
      "id": 2223031089,
      "node_id": "IC_kwDOAP4Jqs6EgMMx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2223031089",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:05:29Z",
      "updated_at": "2024-07-11T14:05:29Z",
      "author_association": "MEMBER",
      "body": "Rebased to fix merge conflict",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2223031089",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13472559797,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMjBvK1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472559797",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/0c63b8b1911ef1183f411a5e232165b543c668ea",
      "created_at": "2024-07-11T14:14:50Z"
    },
    {
      "event": "commented",
      "id": 2223072145,
      "node_id": "IC_kwDOAP4Jqs6EgWOR",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2223072145",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:21:54Z",
      "updated_at": "2024-07-11T14:21:54Z",
      "author_association": "MEMBER",
      "body": "Updated https://github.com/bitcoin-core/secp256k1/commit/4a8b707fa84819dda7a663a92c0e32f519f9bacf -> https://github.com/bitcoin-core/secp256k1/commit/0c63b8b1911ef1183f411a5e232165b543c668ea ([bip352-silentpayments-module-10-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-10-rebase) -> [bip352-silentpayments-module-11](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-11), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-10-rebase..josibake:secp256k1:bip352-silentpayments-module-11))\r\n\r\n* Add the json test vectors from the BIP and ensure the Makefile is aware of changes to the test vectors\r\n* Update the example based on feedback from @Sjors \r\n* Update the API documentation\r\n* No API/implementation changes\r\n\r\nPer @real-or-random 's comment https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673641829, I removed details about the protocol internals from a few spots in the API documentation. The caller already needs to be familiar with BIP352 before using this library considering this library does not do things like get the smallest outpoint, filter the transaction inputs, or extract the public keys from the inputs. Given that, I agree its better to keep the documentation here focused on API usage and not on explaining how BIP352 works under the hood.\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2223072145",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13472662045,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMjCIId",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472662045",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:21:56Z"
    },
    {
      "event": "subscribed",
      "id": 13472662072,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMjCII4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472662072",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:21:56Z"
    },
    {
      "event": "mentioned",
      "id": 13472662102,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMjCIJW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472662102",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:21:56Z"
    },
    {
      "event": "subscribed",
      "id": 13472662125,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMjCIJt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472662125",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:21:56Z"
    },
    {
      "event": "reviewed",
      "id": 2173313611,
      "node_id": "PRR_kwDOAP4Jqs6BiiJL",
      "url": null,
      "actor": null,
      "commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2173313611",
      "submitted_at": "2024-07-12T00:24:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2174199522,
      "node_id": "PRR_kwDOAP4Jqs6Bl6bi",
      "url": null,
      "actor": null,
      "commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I think the example is really helpful, and I don't really have ideas to improve conceptually. (That's why I have mostly just nits.)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2174199522",
      "submitted_at": "2024-07-12T09:25:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2174287912,
      "node_id": "PRR_kwDOAP4Jqs6BmQAo",
      "url": null,
      "actor": null,
      "commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "The module should also be mentioned in the README",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2174287912",
      "submitted_at": "2024-07-12T09:26:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13487799340,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMj73ws",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487799340",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "602e11d910083582b139f2c45045c27e26805b92",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/602e11d910083582b139f2c45045c27e26805b92",
      "created_at": "2024-07-12T13:58:55Z"
    },
    {
      "event": "commented",
      "id": 2225664151,
      "node_id": "IC_kwDOAP4Jqs6EqPCX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2225664151",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:20Z",
      "updated_at": "2024-07-12T14:07:20Z",
      "author_association": "MEMBER",
      "body": "Updated https://github.com/bitcoin-core/secp256k1/commit/0c63b8b1911ef1183f411a5e232165b543c668ea -> https://github.com/bitcoin-core/secp256k1/commit/602e11d910083582b139f2c45045c27e26805b92 ([bip352-silentpayments-module-11](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-11) -> [bip352-silentpayments-module-12](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-12), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-11..josibake:secp256k1:bip352-silentpayments-module-12))\r\n\r\n* Updated the `label_lookup` function to take a 33-byte pubkey serialization (as opposed to a `secp256k1_pubkey`) (h/t @real-or-random)\r\n* Made `_sort` and `_create_shared_secret` void functions and added a few tests to verify all cases are covered (h/t @theStack)\r\n* Updated comments in the example to make it more clear that labels is an optional feature (h/t @Sjors)\r\n* General spelling and formatting fix ups\r\n* Added a commit for the `README`\r\n\r\nThe diff looks rather large, but its mostly formatting and spelling fixes. Thanks @Sjors , @real-or-random , @theStack for the thorough review!\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2225664151",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13487919691,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMj8VJL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919691",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "subscribed",
      "id": 13487919713,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMj8VJh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919713",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "mentioned",
      "id": 13487919732,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMj8VJ0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919732",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "subscribed",
      "id": 13487919742,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMj8VJ-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919742",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "mentioned",
      "id": 13487919759,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMj8VKP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919759",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "subscribed",
      "id": 13487919769,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMj8VKZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919769",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "reviewed",
      "id": 2175311571,
      "node_id": "PRR_kwDOAP4Jqs6BqJ7T",
      "url": null,
      "actor": null,
      "commit_id": "602e11d910083582b139f2c45045c27e26805b92",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2175311571",
      "submitted_at": "2024-07-12T17:14:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13497713166,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMkhsIO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13497713166",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "created_at": "2024-07-14T11:24:03Z"
    },
    {
      "event": "commented",
      "id": 2227312600,
      "node_id": "IC_kwDOAP4Jqs6EwhfY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2227312600",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:33:29Z",
      "updated_at": "2024-07-14T11:33:29Z",
      "author_association": "MEMBER",
      "body": "Updated https://github.com/bitcoin-core/secp256k1/commit/602e11d910083582b139f2c45045c27e26805b92 -> https://github.com/bitcoin-core/secp256k1/commit/00b0cb19a97718dfaab70aa7505ff157f22a31bd ([bip352-silentpayments-module-12](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-12) -> [bip352-silentpayments-module-13](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-13), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-12..josibake:secp256k1:bip352-silentpayments-module-13))\r\n\r\n* Formatting fix ups for `examples/silentpayments.c` (introduced in the previous commit :doh:)\r\n* Use `eckey_pubkey_serialize` (h/t @theStack)\r\n* Spelling fixups in `include/secp256k1_silentpayments.h` (h/t @theStack)\r\n* Allow trailing comma in test vectors (h/t @real-or-random)\r\n* Fix up `memset` when clear unsigned char arrays\r\n* Fix CI by replacing `memcmp` with `secp256k1_memcmp_var`\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2227312600",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13497730767,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMkhwbP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13497730767",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:33:30Z"
    },
    {
      "event": "subscribed",
      "id": 13497730770,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMkhwbS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13497730770",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:33:30Z"
    },
    {
      "event": "mentioned",
      "id": 13497730773,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMkhwbV",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13497730773",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:33:30Z"
    },
    {
      "event": "subscribed",
      "id": 13497730774,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMkhwbW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13497730774",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:33:30Z"
    },
    {
      "event": "reviewed",
      "id": 2179013693,
      "node_id": "PRR_kwDOAP4Jqs6B4Rw9",
      "url": null,
      "actor": null,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "nit: a suggestion to make the example file cover all functions.",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2179013693",
      "submitted_at": "2024-07-16T01:26:02Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "referenced",
      "id": 13606918389,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMrCRj1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13606918389",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1d49769ad4c2a7f52294f84b40524361314f8425",
      "commit_url": "https://api.github.com/repos/BitBoxSwiss/secp256k1-zkp/commits/1d49769ad4c2a7f52294f84b40524361314f8425",
      "created_at": "2024-07-22T21:12:01Z"
    },
    {
      "event": "referenced",
      "id": 13607207369,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMrDYHJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13607207369",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ad4bd73d4f404b68ce15f308d3935cfe3d440143",
      "commit_url": "https://api.github.com/repos/BitBoxSwiss/secp256k1-zkp/commits/ad4bd73d4f404b68ce15f308d3935cfe3d440143",
      "created_at": "2024-07-22T21:48:33Z"
    },
    {
      "event": "referenced",
      "id": 13613805074,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMrci4S",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13613805074",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e8810288935ac12cc2ce7858f058258fe48520c4",
      "commit_url": "https://api.github.com/repos/BitBoxSwiss/secp256k1-zkp/commits/e8810288935ac12cc2ce7858f058258fe48520c4",
      "created_at": "2024-07-23T10:45:25Z"
    },
    {
      "event": "referenced",
      "id": 13613853868,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMrcuys",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13613853868",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a361bdc22dec88840375039cdad35bc21395f5cd",
      "commit_url": "https://api.github.com/repos/BitBoxSwiss/secp256k1-zkp/commits/a361bdc22dec88840375039cdad35bc21395f5cd",
      "created_at": "2024-07-23T10:49:17Z"
    },
    {
      "event": "reviewed",
      "id": 2210420185,
      "node_id": "PRR_kwDOAP4Jqs6DwFXZ",
      "url": null,
      "actor": null,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2210420185",
      "submitted_at": "2024-07-31T15:28:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2216342387,
      "node_id": "PRR_kwDOAP4Jqs6EGrNz",
      "url": null,
      "actor": null,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2216342387",
      "submitted_at": "2024-08-02T20:16:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2217828154,
      "node_id": "PRR_kwDOAP4Jqs6EMV86",
      "url": null,
      "actor": null,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2217828154",
      "submitted_at": "2024-08-04T22:49:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13777629641,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAM1NfHJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13777629641",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a804ae7439f0c88d12dfbeb2e2706ea8d4ca52b7",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/a804ae7439f0c88d12dfbeb2e2706ea8d4ca52b7",
      "created_at": "2024-08-06T12:05:52Z"
    },
    {
      "event": "commented",
      "id": 2271134596,
      "node_id": "IC_kwDOAP4Jqs6HXsOE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2271134596",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T12:08:11Z",
      "updated_at": "2024-08-06T12:08:11Z",
      "author_association": "MEMBER",
      "body": "Rebased https://github.com/bitcoin-core/secp256k1/commit/00b0cb19a97718dfaab70aa7505ff157f22a31bd -> https://github.com/bitcoin-core/secp256k1/commit/a804ae7439f0c88d12dfbeb2e2706ea8d4ca52b7 ([bip352-silentpayments-module-13](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-13) -> [bip352-silentpayments-module-13-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-13-rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-13..josibake:secp256k1:bip352-silentpayments-module-13-rebase))\r\n\r\n* Fix merge conflict\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2271134596",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13778277271,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAM1P9OX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13778277271",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b2b904b30a62cd5f90432b659b7b955243bcb5df",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/b2b904b30a62cd5f90432b659b7b955243bcb5df",
      "created_at": "2024-08-06T12:54:55Z"
    },
    {
      "event": "commented",
      "id": 2271234228,
      "node_id": "IC_kwDOAP4Jqs6HYEi0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2271234228",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T12:59:34Z",
      "updated_at": "2024-08-06T12:59:34Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/a804ae7439f0c88d12dfbeb2e2706ea8d4ca52b7) -> https://github.com/bitcoin-core/secp256k1/commit/b2b904b30a62cd5f90432b659b7b955243bcb5df ([bip352-silentpayments-module-13-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-13-rebase) -> [bip352-silentpayments-module-14](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-14), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-13-rebase..josibake:secp256k1:bip352-silentpayments-module-14))\r\n\r\n* Update the example variable names to avoid confusing with general transaction input and outputs\r\n* Add benchmark for scanning a single output (light client scanning)\r\n* Typo fixes (h/t @theStack)\r\n* Handle `secp256k1_pubkey_load` errors",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2271234228",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13778348515,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAM1QOnj",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13778348515",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T12:59:36Z"
    },
    {
      "event": "subscribed",
      "id": 13778348530,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAM1QOny",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13778348530",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T12:59:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13780491273,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAM1YZwJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13780491273",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3165b6b091a30a4ace948d67d55142c61a12929d",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/3165b6b091a30a4ace948d67d55142c61a12929d",
      "created_at": "2024-08-06T15:24:02Z"
    },
    {
      "event": "commented",
      "id": 2271579484,
      "node_id": "IC_kwDOAP4Jqs6HZY1c",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2271579484",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T15:32:20Z",
      "updated_at": "2024-08-06T15:32:20Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/b2b904b30a62cd5f90432b659b7b955243bcb5df -> https://github.com/bitcoin-core/secp256k1/commit/3165b6b091a30a4ace948d67d55142c61a12929d ([bip352-silentpayments-module-14](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-14) -> [bip352-silentpayments-module-15](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-15), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-14..josibake:secp256k1:bip352-silentpayments-module-15))\r\n\r\n* Add test for malformed secp256k1_pubkey_load\r\n* Handle _pubkey_load error missed in the last push\r\n\r\n@theStack I spent some time trying to create a test where we create a secp256k1_pubkey object that is in an invalid state, but it doesn't seem possible, since errors are caught when calling _ec_pubkey_parse. This is why I decided not to make the internal create_shared_secret function handle an error when loading a public key because by that point the public key object has either been a) created by us, or b) validated by us.\r\n\r\nIn all other cases, I think it makes sense to check the error because the pubkey object would have been created by the caller and we have no way of knowing whether or not they created it correctly (e.g., using the ec_pubkey_parse function).\r\n\r\n\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2271579484",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13780602453,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAM1Y05V",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13780602453",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T15:32:21Z"
    },
    {
      "event": "subscribed",
      "id": 13780602473,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAM1Y05p",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13780602473",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T15:32:21Z"
    },
    {
      "event": "commented",
      "id": 2272427097,
      "node_id": "IC_kwDOAP4Jqs6HcnxZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2272427097",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-07T01:03:53Z",
      "updated_at": "2024-08-07T01:03:53Z",
      "author_association": "NONE",
      "body": "Given the following `secp256k1_silentpayments_public_data` :\r\n\r\n`0x00043e715c3499e40448bf23b53113f7218c5b9805b454a1003eb1009339a48ef69385272624f954ce1e87000eb8dc162e7952ede7d0d0d1d0e38dd7f0588101fe9506a48141afe37530269d77c297681e7efe6cb1d516f7ed50634570d3e0e0c54f`\r\n\r\nIf serialized using `secp256k1_silentpayments_recipient_public_data_serialize`, the result will be: \r\n\r\n`0x039fefa1c745f46da57dc11376e80eb6c11cdd0e28733c50eae777cf5c4b0f95d7`.\r\n\r\nSo, if this same `light_client_data33` is parsed back to `secp256k1_silentpayments_public_data` using `secp256k1_silentpayments_recipient_public_data_parse`, the result will be:\r\n\r\n`0x01049fefa1c745f46da57dc11376e80eb6c11cdd0e28733c50eae777cf5c4b0f95d76df2de74016f234aef7957b66fa7a5eb8be025ded9122e32c50556f088efbbff0000000000000000000000000000000000000000000000000000000000000000`\r\n\r\nThis is not clear to me. Shouldn't parsing the serialized data result in the same `secp256k1_silentpayments_public_data`?",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2272427097",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2272848359,
      "node_id": "IC_kwDOAP4Jqs6HeOnn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2272848359",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-07T07:53:49Z",
      "updated_at": "2024-08-07T07:53:49Z",
      "author_association": "MEMBER",
      "body": "Thanks for testing @jlest01 . The public data object contains a public key and 32 byte `input_hash`. This can be used directly in `_scan_outputs` or it can be serialised for later use (in an index or for sending to light clients). When the data is serialised , the public key is tweaked with the input_hash scalar, i.e., $A_{tweaked} = inputhash \\cdot A_{sum}$. \r\n\r\n$A_{tweaked}$ is what gets serialised, so when $A_{tweaked}$ is deserialised the public data object now only contains a public key. In your example, you can see that the compressed serialisation of the first public data object has the x coordinate `9fefa1c745f46da57dc11376e80eb6c11cdd0e28733c50eae777cf5c4b0f95d7`, which is the same x-coordinate in the de-serialised public data at the end. This isn't really explained in the API docs, by design, since this is supposed to be an opaque data type and these details aren't really relevant for the caller.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2272848359",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13788285892,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAM12IvE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13788285892",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-07T07:53:50Z"
    },
    {
      "event": "subscribed",
      "id": 13788285906,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAM12IvS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13788285906",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-07T07:53:50Z"
    },
    {
      "event": "commented",
      "id": 2276084972,
      "node_id": "IC_kwDOAP4Jqs6Hqkzs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2276084972",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-08T15:17:41Z",
      "updated_at": "2024-08-08T15:17:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "> @theStack I spent some time trying to create a test where we create a secp256k1_pubkey object that is in an invalid state, but it doesn't seem possible, since errors are caught when calling _ec_pubkey_parse. This is why I decided not to make the internal create_shared_secret function handle an error when loading a public key because by that point the public key object has either been a) created by us, or b) validated by us.\r\n\r\nThanks for following up! It seems that for the sender API function, the public component (i.e. a recipient's scan public key) is never validated though? With the following change in the send API test:\r\n```diff\r\ndiff --git a/src/modules/silentpayments/tests_impl.h b/src/modules/silentpayments/tests_impl.h\r\nindex fdca422..bb4e4b9 100644\r\n--- a/src/modules/silentpayments/tests_impl.h\r\n+++ b/src/modules/silentpayments/tests_impl.h\r\n@@ -254,7 +254,7 @@ static void test_send_api(void) {\r\n      * trying to parse the public key with _ec_pubkey_parse\r\n      */\r\n     p[0] = ALICE_SECKEY;\r\n-    memset(&r[0].spend_pubkey.data, 0, sizeof(secp256k1_pubkey));\r\n+    memset(&r[0].scan_pubkey.data, 0, sizeof(secp256k1_pubkey));\r\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\r\n }\r\n```\r\nthe test fails on that pubkey's serialization in the shared secret creation helper:\r\n```\r\n$ ./tests\r\ntest count = 64\r\nrandom seed = de0af255fa70eafa2f1bb5b09fdfd112\r\nsrc/modules/silentpayments/main_impl.h:86: test condition failed: ret && len == 33\r\nAborted (core dumped)\r\n```",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2276084972",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13808663336,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAM3D3so",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13808663336",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-08T15:17:43Z"
    },
    {
      "event": "subscribed",
      "id": 13808663371,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAM3D3tL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13808663371",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-08T15:17:43Z"
    },
    {
      "event": "reviewed",
      "id": 2227982140,
      "node_id": "PRR_kwDOAP4Jqs6EzE88",
      "url": null,
      "actor": null,
      "commit_id": "3165b6b091a30a4ace948d67d55142c61a12929d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Did another review round, left a few nitty-nits below. Overall I think the module is in a pretty good state. Would be nice if the \"friendly neighborhood cryptographers\" could give an opinion on the remaining few TODOs regarding _cmov calls following _set_b32-seckey :-)  I _think_ the answer to most of them is just \"no\":\r\n\r\nhttps://github.com/josibake/secp256k1/blob/3165b6b091a30a4ace948d67d55142c61a12929d/src/modules/silentpayments/main_impl.h#L193\r\nhttps://github.com/josibake/secp256k1/blob/3165b6b091a30a4ace948d67d55142c61a12929d/src/modules/silentpayments/main_impl.h#L202\r\nhttps://github.com/josibake/secp256k1/blob/3165b6b091a30a4ace948d67d55142c61a12929d/src/modules/silentpayments/main_impl.h#L455\r\nhttps://github.com/josibake/secp256k1/blob/3165b6b091a30a4ace948d67d55142c61a12929d/src/modules/silentpayments/main_impl.h#L585",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2227982140",
      "submitted_at": "2024-08-08T17:23:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13894479304,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAM8LO3I",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13894479304",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "created_at": "2024-08-15T10:52:59Z"
    },
    {
      "event": "commented",
      "id": 2291071666,
      "node_id": "IC_kwDOAP4Jqs6Ijvqy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2291071666",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-15T10:57:22Z",
      "updated_at": "2024-08-15T10:57:22Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/3165b6b091a30a4ace948d67d55142c61a12929d -> https://github.com/bitcoin-core/secp256k1/commit/f42e0dde59943ad0c9247c61f7af521b70838e8f ([bip352-silentpayments-module-15](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-15) -> [bip352-silentpayments-module-16](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-16), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-15..josibake:secp256k1:bip352-silentpayments-module-16))\r\n\r\n* Added test for malformed scan_pubkey and moved `_pubkey_load` out of `_create_shared_secret`. Overall, I think this makes the error handling more clear to validate the public keys _before_ calling create_shared_secret\r\n* Added VERIFY and infinity checks (h/t @theStack)\r\n* Spelling and formatting fix-ups (h/t @theStack)\r\n\r\nThanks again for the thorough review, @theStack !",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2291071666",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13894512597,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAM8LW_V",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13894512597",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-15T10:57:23Z"
    },
    {
      "event": "subscribed",
      "id": 13894512604,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAM8LW_c",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13894512604",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-15T10:57:23Z"
    },
    {
      "event": "reviewed",
      "id": 2246526213,
      "node_id": "PRR_kwDOAP4Jqs6F50UF",
      "url": null,
      "actor": null,
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Light ACK modulo some more smaller doc and test nits I found\r\n\r\nAs an additional testing idea, could add some checks that the initialized \"BIP0352/...\" tagged hashes have the expected state (inspired by the MuSig2 PR), but that seems fine to also do in a follow-up.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2246526213",
      "submitted_at": "2024-08-20T16:35:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2308424139,
      "node_id": "IC_kwDOAP4Jqs6Jl8HL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2308424139",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-24T15:04:37Z",
      "updated_at": "2024-08-24T15:16:45Z",
      "author_association": "NONE",
      "body": "The function `secp256k1_silentpayments_recipient_public_data_create` fails for the public keys:\r\n\r\n. `02aba9d21ae5bb3832e845eeca8c0b58e07b27b501debc759cdccb9d86beef3d48`\r\n. `03aba9d21ae5bb3832e845eeca8c0b58e07b27b501debc759cdccb9d86beef3d48`\r\n\r\nAnd the smallest outpoint:\r\n\r\n. `66bd2917be75420a789924737f3e47500bf134cea57a10ce67bf33d8a256e7b000000000`\r\n\r\nThese values represent this signet P2TR transaction:\r\nhttps://mempool.space/signet/tx/d73f4a19f3973e90af6df62e735bb7b31f3d5ab8e7e26e7950651b436d093313\r\n\r\nCode below for reproduction:\r\n```c\r\nstatic unsigned char smallest_outpoint[36] = {\r\n    0x66, 0xbd, 0x29, 0x17, 0xbe, 0x75, 0x42, 0x0a, 0x78, \r\n    0x99, 0x24, 0x73, 0x7f, 0x3e, 0x47, 0x50, 0x0b, 0xf1, \r\n    0x34, 0xce, 0xa5, 0x7a, 0x10, 0xce, 0x67, 0xbf, 0x33, \r\n    0xd8, 0xa2, 0x56, 0xe7, 0xb0, 0x00, 0x00, 0x00, 0x00\r\n};\r\n\r\nstatic unsigned char first_pubkey_bytes[33] = {\r\n    0x02, 0xab, 0xa9, 0xd2, 0x1a, 0xe5, 0xbb, 0x38, \r\n    0x32, 0xe8, 0x45, 0xee, 0xca, 0x8c, 0x0b, 0x58,\r\n    0xe0, 0x7b, 0x27, 0xb5, 0x01, 0xde, 0xbc, 0x75, \r\n    0x9c, 0xdc, 0xcb, 0x9d, 0x86, 0xbe, 0xef, 0x3d, 0x48\r\n};\r\n\r\nstatic unsigned char second_pubkey_bytes[33] = {\r\n    0x03, 0xab, 0xa9, 0xd2, 0x1a, 0xe5, 0xbb, 0x38, \r\n    0x32, 0xe8, 0x45, 0xee, 0xca, 0x8c, 0x0b, 0x58,\r\n    0xe0, 0x7b, 0x27, 0xb5, 0x01, 0xde, 0xbc, 0x75, \r\n    0x9c, 0xdc, 0xcb, 0x9d, 0x86, 0xbe, 0xef, 0x3d, 0x48\r\n};\r\n\r\nint main(void) {\r\n\r\n    enum { N_INPUTS = 2 };\r\n\r\n    unsigned char randomize[32];\r\n\r\n    secp256k1_pubkey first_pubkey;\r\n    secp256k1_pubkey second_pubkey;\r\n    const secp256k1_pubkey *tx_input_ptrs[N_INPUTS];\r\n    secp256k1_silentpayments_public_data public_data;\r\n\r\n    int ret;\r\n\r\n    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\r\n    if (!fill_random(randomize, sizeof(randomize))) {\r\n        printf(\"Failed to generate randomness\\n\");\r\n        return 1;\r\n    }\r\n\r\n    ret = secp256k1_context_randomize(ctx, randomize);\r\n    assert(ret);\r\n\r\n    ret = secp256k1_ec_pubkey_parse(ctx, &first_pubkey, first_pubkey_bytes, 33);\r\n    ret = secp256k1_ec_pubkey_parse(ctx, &second_pubkey, second_pubkey_bytes, 33);\r\n\r\n    tx_input_ptrs[0] = &first_pubkey;\r\n    tx_input_ptrs[1] = &second_pubkey;\r\n\r\n    ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\r\n                &public_data,\r\n                smallest_outpoint,\r\n                NULL, 0, \r\n                tx_input_ptrs, N_INPUTS\r\n            );\r\n\r\n    assert(ret); // main: Assertion `ret' failed.\r\n\r\n    return 0;\r\n\r\n}\r\n```",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2308424139",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2308436382,
      "node_id": "IC_kwDOAP4Jqs6Jl_Ge",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2308436382",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-24T15:48:51Z",
      "updated_at": "2024-08-24T15:48:51Z",
      "author_association": "NONE",
      "body": "Testing the same values ​​using rust silentpayments crate, you get an error description: `Secp256k1Error(InvalidPublicKeySum)` (code below).\r\n\r\nI assume the problem is that adding these two public keys results in a point at infinity (since they have opposite parity).\r\n\r\nWould it be the caller's responsibility to do this check before calling `secp256k1_silentpayments_recipient_public_data_create` ?\r\n\r\n```rust\r\nuse silentpayments::{secp256k1::PublicKey, utils::receiving::calculate_tweak_data};\r\n\r\nfn main() {\r\n\r\n    let mut pubkeys: Vec<PublicKey> = Vec::with_capacity(2);\r\n\r\n    let first_pubkey_bytes = hex::decode(\"02aba9d21ae5bb3832e845eeca8c0b58e07b27b501debc759cdccb9d86beef3d48\").unwrap();\r\n    let first_pubkey = PublicKey::from_slice(first_pubkey_bytes.as_slice()).unwrap();\r\n    pubkeys.push(first_pubkey);\r\n\r\n    let second_pubkey_bytes = hex::decode(\"03aba9d21ae5bb3832e845eeca8c0b58e07b27b501debc759cdccb9d86beef3d48\").unwrap();\r\n    let second_pubkey = PublicKey::from_slice(second_pubkey_bytes.as_slice()).unwrap();\r\n    pubkeys.push(second_pubkey);\r\n\r\n    let input_pub_keys: Vec<&PublicKey> = pubkeys.iter().collect();\r\n    \r\n    let mut outpoints_data: Vec<(String, u32)> = Vec::with_capacity(2);\r\n\r\n    outpoints_data.push((\"b0e756a2d833bf67ce107aa5ce34f10b50473e7f732499780a4275be1729bd66\".to_string(), 0));\r\n    outpoints_data.push((\"b0e756a2d833bf67ce107aa5ce34f10b50473e7f732499780a4275be1729bd66\".to_string(), 1));\r\n\r\n    let tweak_data = calculate_tweak_data(&input_pub_keys, &outpoints_data).unwrap();\r\n    // panicked! called `Result::unwrap()` on an `Err` value: Secp256k1Error(InvalidPublicKeySum)\r\n}\r\n\r\n```",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2308436382",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2310157802,
      "node_id": "IC_kwDOAP4Jqs6JsjXq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2310157802",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-26T13:00:31Z",
      "updated_at": "2024-08-26T13:00:31Z",
      "author_association": "MEMBER",
      "body": "Hey @jlest01 , thanks for the thorough testing! The error you're encountering is from here:\r\n\r\nhttps://github.com/bitcoin-core/secp256k1/blob/f42e0dde59943ad0c9247c61f7af521b70838e8f/src/modules/silentpayments/main_impl.h#L369-L374\r\n\r\nAs you mention, this is because the public keys sum to the point at infinity, i.e., the second pubkey is a negation of the first one. It is expected that callers should check the return value from `_public_data_create` and proceed to the next transaction if they get an error. Earlier in this PR we did discuss having more specific error codes but ultimately decided it's best to try and make it such that if a user encounters an error, there's likely nothing they can do but skip the transaction. From a user's perspective, if they can't do anything to fix the error, they don't really gain anything by knowing *why* it failed.\r\n\r\nI _think_ we have a case for this in the test vectors, but if not I'll definitely add this to the BIP test vectors since scanning implementations should be checking for this.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2310157802",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 14013194939,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAANDQGK7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14013194939",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-26T13:00:33Z"
    },
    {
      "event": "subscribed",
      "id": 14013194966,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAANDQGLW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14013194966",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-26T13:00:34Z"
    },
    {
      "event": "reviewed",
      "id": 2287502358,
      "node_id": "PRR_kwDOAP4Jqs6IWIQW",
      "url": null,
      "actor": null,
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2287502358",
      "submitted_at": "2024-09-07T14:04:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2287996221,
      "node_id": "PRR_kwDOAP4Jqs6IYA09",
      "url": null,
      "actor": null,
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2287996221",
      "submitted_at": "2024-09-07T16:23:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2289169904,
      "node_id": "PRR_kwDOAP4Jqs6IcfXw",
      "url": null,
      "actor": null,
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Reviewed the scaffold, send, labels and part of the receive commit (94c6e1f54299dfc83aa34bc92f9f861808449a23). Did not study the tests.\r\n\r\nYou could split the light client / indexer functions out of the receive commit 94c6e1f54299dfc83aa34bc92f9f861808449a23.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2289169904",
      "submitted_at": "2024-09-09T14:30:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2291984643,
      "node_id": "PRR_kwDOAP4Jqs6InOkD",
      "url": null,
      "actor": null,
      "commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2291984643",
      "submitted_at": "2024-09-10T10:05:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2292150689,
      "node_id": "PRR_kwDOAP4Jqs6In3Gh",
      "url": null,
      "actor": null,
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Reviewed the rest. This PR @ f42e0dde59943ad0c9247c61f7af521b70838e8f seems to be in pretty good shape, but I'm not a low level C guru.\r\n\r\nI didn't check the changes since my last review of the example, but its usage of labels is now clear to me.\r\n\r\nI didn't review the tests and benchmarks.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2292150689",
      "submitted_at": "2024-09-10T14:37:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2362819079,
      "node_id": "PRR_kwDOAP4Jqs6M1cIH",
      "url": null,
      "actor": null,
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2362819079",
      "submitted_at": "2024-10-11T14:58:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2364836373,
      "node_id": "PRR_kwDOAP4Jqs6M9IoV",
      "url": null,
      "actor": null,
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2364836373",
      "submitted_at": "2024-10-13T07:04:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "unsubscribed",
      "id": 14619660439,
      "node_id": "UE_lADOAP4Jqs6GTERUzwAAAANnZlCX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/14619660439",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-13T13:29:14Z"
    },
    {
      "event": "reviewed",
      "id": 2396442471,
      "node_id": "PRR_kwDOAP4Jqs6O1s9n",
      "url": null,
      "actor": null,
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2396442471",
      "submitted_at": "2024-10-25T20:58:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2397094351,
      "node_id": "PRR_kwDOAP4Jqs6O4MHP",
      "url": null,
      "actor": null,
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2397094351",
      "submitted_at": "2024-10-26T09:52:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2462239636,
      "node_id": "IC_kwDOAP4Jqs6SwsuU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2462239636",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-07T13:27:00Z",
      "updated_at": "2024-11-07T13:27:00Z",
      "author_association": "MEMBER",
      "body": "Big thanks to all the review over the last few months and apologies for my slow response. I'm in the process of rebasing and incorporating review feedback, should have the PR updated shortly.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2462239636",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "reviewed",
      "id": 2430408482,
      "node_id": "PRR_kwDOAP4Jqs6Q3Rci",
      "url": null,
      "actor": null,
      "commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2430408482",
      "submitted_at": "2024-11-12T18:36:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2409505924,
      "node_id": "PRR_kwDOAP4Jqs6PniSE",
      "url": null,
      "actor": null,
      "commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2409505924",
      "submitted_at": "2024-12-12T07:21:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2505693682,
      "node_id": "PRR_kwDOAP4Jqs6VWdny",
      "url": null,
      "actor": null,
      "commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2505693682",
      "submitted_at": "2024-12-16T09:56:06Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2518573756,
      "node_id": "PRR_kwDOAP4Jqs6WHmK8",
      "url": null,
      "actor": null,
      "commit_id": "7229d49d1bfa2367cee54b106fead4575edc5118",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2518573756",
      "submitted_at": "2024-12-21T04:31:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2518936514,
      "node_id": "PRR_kwDOAP4Jqs6WI-vC",
      "url": null,
      "actor": null,
      "commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2518936514",
      "submitted_at": "2024-12-21T19:43:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2524471499,
      "node_id": "PRR_kwDOAP4Jqs6WeGDL",
      "url": null,
      "actor": null,
      "commit_id": "5c546e2874012dccc40a3e91ed2502c538a00356",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2524471499",
      "submitted_at": "2024-12-28T03:52:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2587413399,
      "node_id": "IC_kwDOAP4Jqs6aOMuX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2587413399",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-13T15:22:30Z",
      "updated_at": "2025-01-13T15:22:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "We discussed this in the meeting today.\r\n\r\n@josibake Can you summarize what the status of the PR is? We're considering doing a sprint week around mid-March if that fits your (and other contributors') schedules and the status of the PR. \r\n",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2587413399",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 15907163497,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAO0JA1p",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/15907163497",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-13T15:22:32Z"
    },
    {
      "event": "subscribed",
      "id": 15907163521,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAO0JA2B",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/15907163521",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-13T15:22:32Z"
    },
    {
      "event": "commented",
      "id": 2595534905,
      "node_id": "IC_kwDOAP4Jqs6atLg5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2595534905",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-16T12:49:29Z",
      "updated_at": "2025-01-16T12:49:29Z",
      "author_association": "MEMBER",
      "body": "Hey @real-or-random, current status when I left off in early December was finishing a rebase and responding to outstanding feedback. I'll be picking up that work next week with a goal of having this ready for review and all outstanding feedback addressed by beginning of February. I think a sprint in mid March works perfectly for me! I'll be babysitting this PR through February so its ready for March and will also have time in March to respond to reviewer feedback.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2595534905",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 15958805468,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAO3OAvc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/15958805468",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-16T12:49:30Z"
    },
    {
      "event": "subscribed",
      "id": 15958805530,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAO3OAwa",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/15958805530",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-16T12:49:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16283402185,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAPKkP_J",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16283402185",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "created_at": "2025-02-12T15:59:41Z"
    },
    {
      "event": "commented",
      "id": 2654194445,
      "node_id": "IC_kwDOAP4Jqs6eM8sN",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2654194445",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T16:12:44Z",
      "updated_at": "2025-02-12T16:12:44Z",
      "author_association": "MEMBER",
      "body": "A big thanks to all the reviewers and there patience waiting on me to respond and rebase 😅 \r\n\r\nI've added a commit for constant time tests (h/t to @jonasnick and @theStack!) and addressed a majority of the review comments. As some changes were necessary in order to pass the constant time tests, there are also some TODO comments which I will be addressing, along with the remaining PR feedback (pls don't take it personally if I miss a review comment; I am finding Github's UI exceedingly difficult to work with 😠 ).\r\n\r\n@real-or-random , @jonasnick I left a TODO comment in the tests where I have two test cases for ensuring the `_create_outputs` function can handle malformed public keys passed in via the `recipients` arguments. Since this argument is provided by the user, I think it's reasonable to test for invalid public keys but I couldn't figure out how to do this with the way the `CHECK_ILLEGAL` macro works. I left a more detailed explanation in the TODO comment, would appreciate suggestions here!",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2654194445",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 16283624722,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPKlGUS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16283624722",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T16:12:46Z"
    },
    {
      "event": "subscribed",
      "id": 16283624749,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPKlGUt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16283624749",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T16:12:46Z"
    },
    {
      "event": "mentioned",
      "id": 16283624767,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPKlGU_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16283624767",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T16:12:46Z"
    },
    {
      "event": "subscribed",
      "id": 16283624793,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPKlGVZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16283624793",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T16:12:46Z"
    },
    {
      "event": "mentioned",
      "id": 16283624814,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPKlGVu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16283624814",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T16:12:46Z"
    },
    {
      "event": "subscribed",
      "id": 16283624833,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPKlGWB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16283624833",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T16:12:46Z"
    },
    {
      "event": "reviewed",
      "id": 2616184657,
      "node_id": "PRR_kwDOAP4Jqs6b789R",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2616184657",
      "submitted_at": "2025-02-13T20:47:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2616186013,
      "node_id": "PRR_kwDOAP4Jqs6b79Sd",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2616186013",
      "submitted_at": "2025-02-13T20:48:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2616306873,
      "node_id": "PRR_kwDOAP4Jqs6b8ay5",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2616306873",
      "submitted_at": "2025-02-13T23:20:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2709963952,
      "node_id": "IC_kwDOAP4Jqs6hhsSw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2709963952",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-10T09:38:31Z",
      "updated_at": "2025-03-13T15:13:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've restarted the macOS jobs which fail in `silentpayments_example` but that didn't seem to help. Unfortunately, we don't print the test logs of the examples. ~@josibake Can you cherry-pick #1655, or better, rebase on it?~\r\n\r\nedit: Let me first finish #1655, I got sidetracked by refactoring some stuff in CI...",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2709963952",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 16651260332,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPgfhGs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16651260332",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-10T09:38:32Z"
    },
    {
      "event": "subscribed",
      "id": 16651260364,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPgfhHM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16651260364",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-10T09:38:32Z"
    },
    {
      "event": "milestoned",
      "id": 16656925456,
      "node_id": "MIE_lADOAP4Jqs6GTERUzwAAAAPg1IMQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16656925456",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-10T15:20:57Z",
      "milestone": {
        "title": "0.7.0"
      }
    },
    {
      "event": "commented",
      "id": 2713090371,
      "node_id": "IC_kwDOAP4Jqs6htnlD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2713090371",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-11T08:11:46Z",
      "updated_at": "2025-03-13T15:13:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "Okay, I might make further tweaks to https://github.com/bitcoin-core/secp256k1/pull/1655, but it's in a working state already now, so you could use it to get the test output on macOS CI.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2713090371",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2715551069,
      "node_id": "IC_kwDOAP4Jqs6h3AVd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2715551069",
      "actor": {
        "login": "davidgumberg",
        "id": 2257631,
        "node_id": "MDQ6VXNlcjIyNTc2MzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/davidgumberg",
        "html_url": "https://github.com/davidgumberg",
        "followers_url": "https://api.github.com/users/davidgumberg/followers",
        "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
        "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
        "repos_url": "https://api.github.com/users/davidgumberg/repos",
        "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-11T19:56:14Z",
      "updated_at": "2025-03-13T15:13:28Z",
      "author_association": "NONE",
      "body": "May be helpful: I created a branch that prints `test-suite.log` and ran this branch on top of it: https://github.com/davidgumberg/secp256k1/actions/runs/13617860956/job/38063259253#step:7:1 , also notable is how long the failed jobs take to execute.\r\n\r\nThe following was the valgrind error output:\r\n\r\n<details>\r\n\r\n<summary>\r\n\r\n`test-suite.log`\r\n\r\n</summary>\r\n\r\n```\r\n=============================================\r\n   libsecp256k1 0.6.1-dev: ./test-suite.log\r\n==============================================\r\n\r\n# TOTAL: 9\r\n# PASS:  8\r\n# SKIP:  0\r\n# XFAIL: 0\r\n# FAIL:  1\r\n# XPASS: 0\r\n# ERROR: 0\r\n\r\nSystem information (uname -a): Darwin 22.6.0 Darwin Kernel Version 22.6.0: Thu Dec 5 23:45:11 PST 2024; root:xnu-8796.141.3.709.7~4/RELEASE_X86_64\r\n\r\n.. contents:: :depth: 2\r\n\r\nFAIL: silentpayments_example\r\n============================\r\n\r\n==16219== Memcheck, a memory error detector\r\n==16219== Copyright (C) 2002-2024, and GNU GPL'd, by Julian Seward et al.\r\n==16219== Using Valgrind-3.24.0.GIT-lbmacos and LibVEX; rerun with -h for copyright info\r\n==16219== Command: ./silentpayments_example\r\n==16219== \r\n==16219== Conditional jump or move depends on uninitialised value(s)\r\n==16219==    at 0x7FF80F62E587: ???\r\n==16219==    by 0x1000020CA: ??? (in ./silentpayments_example)\r\n==16219==    by 0x240D40DE7CA8B606: ???\r\n==16219==    by 0xE26A7B019416DCB: ???\r\n==16219==    by 0x7EE3E32000E54B98: ???\r\n==16219==    by 0xAC: ???\r\n==16219== \r\n==16219== Use of uninitialised value of size 8\r\n==16219==    at 0x7FF80F62E5A3: ???\r\n==16219==    by 0x1000020CA: ??? (in ./silentpayments_example)\r\n==16219==    by 0x240D40DE7CA8B606: ???\r\n==16219==    by 0xE26A7B019416DCB: ???\r\n==16219==    by 0x7EE3E32000E54B98: ???\r\n==16219==    by 0xAC: ???\r\n==16219== \r\n==16219== Use of uninitialised value of size 8\r\n==16219==    at 0x7FF80F62E5A8: ???\r\n==16219==    by 0x1000020CA: ??? (in ./silentpayments_example)\r\n==16219==    by 0x240D40DE7CA8B606: ???\r\n==16219==    by 0xE26A7B019416DCB: ???\r\n==16219==    by 0x7EE3E32000E54B98: ???\r\n==16219==    by 0xAC: ???\r\n==16219== \r\n==16219== Conditional jump or move depends on uninitialised value(s)\r\n==16219==    at 0x1000020CD: ??? (in ./silentpayments_example)\r\n==16219==    by 0x240D40DE7CA8B606: ???\r\n==16219==    by 0xE26A7B019416DCB: ???\r\n==16219==    by 0x7EE3E32000E54B98: ???\r\n==16219==    by 0xAC: ???\r\n==16219== \r\nAlice created the following outputs for Bob and Carol: \r\n    1.0 BTC : 0x1dbe60f5af81d3fa78987fc761fa04fd35e8b9a58690bd3bccf138bd67730227\r\n    2.0 BTC : 0xf00234d09f868000854826491df0df26eb4564e69bac181747f169c4d26e5d0f\r\n    3.0 BTC : 0x53c13d48b92a84bc9dd8ae431f708a3c5e126273712d9ab803973160248145ae\r\n\r\nBob found the following outputs: \r\n    0xf00234d09f868000854826491df0df26eb4564e69bac181747f169c4d26e5d0f\r\n\r\nCarol found the following outputs: \r\n    0x53c13d48b92a84bc9dd8ae431f708a3c5e126273712d9ab803973160248145ae\r\n    0x1dbe60f5af81d3fa78987fc761fa04fd35e8b9a58690bd3bccf138bd67730227\r\n==16219== \r\n==16219== HEAP SUMMARY:\r\n==16219==     in use at exit: 12,945 bytes in 177 blocks\r\n==16219==   total heap usage: 188 allocs, 11 frees, 14,088 bytes allocated\r\n==16219== \r\n==16219== LEAK SUMMARY:\r\n==16219==    definitely lost: 4,288 bytes in 134 blocks\r\n==16219==    indirectly lost: 0 bytes in 0 blocks\r\n==16219==      possibly lost: 576 bytes in 2 blocks\r\n==16219==    still reachable: 8,081 bytes in 41 blocks\r\n==16219==         suppressed: 0 bytes in 0 blocks\r\n==16219== Rerun with --leak-check=full to see details of leaked memory\r\n==16219== \r\n==16219== Use --track-origins=yes to see where uninitialised values come from\r\n==16219== For lists of detected and suppressed errors, rerun with: -s\r\n==16219== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 142 from 41)\r\nFAIL silentpayments_example (exit status: 42)\r\n```\r\n\r\n</details>",
      "user": {
        "login": "davidgumberg",
        "id": 2257631,
        "node_id": "MDQ6VXNlcjIyNTc2MzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/davidgumberg",
        "html_url": "https://github.com/davidgumberg",
        "followers_url": "https://api.github.com/users/davidgumberg/followers",
        "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
        "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
        "repos_url": "https://api.github.com/users/davidgumberg/repos",
        "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2715551069",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2715886527,
      "node_id": "IC_kwDOAP4Jqs6h4SO_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2715886527",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-11T22:58:58Z",
      "updated_at": "2025-03-13T15:13:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks! I was about to do something like this.\r\n\r\nApple clang job: https://github.com/davidgumberg/secp256k1/actions/runs/13617860956/job/38063259253#step:7:1\r\ngcc job: https://github.com/davidgumberg/secp256k1/actions/runs/13617860956/job/38063259361\r\n\r\nThe problem is that the stack traces output by Valgrind don't contain symbols. I suspect this is due to https://github.com/LouisBrunner/valgrind-macos/issues/108, ~for which there is reasonable hope that it is fixed on master of LouisBrunner/valgrind-macos/. But for some reason, our CI script does not build the current valgrind-macos master. It checks out an outdated revision from git (this seems to be a bug) and then (correctly) concludes that it has a build of that revision in the cache... cc @hebasto~\r\nedit: see next comment\r\n\r\nAt this point, it will make sense that someone with a real mac and valgrind-macos installed takes a look at the failure. It's not unlikely that this is just a false positive. \r\n\r\n\r\n> also notable is how long the failed jobs take to execute.\r\n\r\nThat's expected, Valgrind is slow.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2715886527",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 16699207990,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPjWbE2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16699207990",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-11T22:58:59Z"
    },
    {
      "event": "subscribed",
      "id": 16699207999,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPjWbE_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16699207999",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-11T22:58:59Z"
    },
    {
      "event": "commented",
      "id": 2717105528,
      "node_id": "IC_kwDOAP4Jqs6h8714",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2717105528",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-12T08:52:19Z",
      "updated_at": "2025-03-13T15:13:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "> The problem is that the stack traces output by Valgrind don't contain symbols. I suspect this is due to [LouisBrunner/valgrind-macos#108](https://github.com/LouisBrunner/valgrind-macos/issues/108), for which there is reasonable hope that it is fixed on master of LouisBrunner/valgrind-macos/. But for some reason, our CI script does not build the current valgrind-macos master. It checks out an outdated revision from git (this seems to be a bug) and then (correctly) concludes that it has a build of that revision in the cache... cc @hebasto\r\n\r\nScratch that. This is just because the CI run was already a week old. @davidgumberg I just saw your new run at https://github.com/davidgumberg/secp256k1/actions/runs/13797060468/job/38591133675 and this fails on the most recent Valgrind (so installing Valgrind works), but still without symbols. Here's the output for the Apple clang build:\r\n\r\n```\r\nsilentpayments_example.log\r\n  ==11001== Memcheck, a memory error detector\r\n  ==11001== Copyright (C) 2002-2024, and GNU GPL'd, by Julian Seward et al.\r\n  ==11001== Using Valgrind-3.25.0.GIT-lbmacos and LibVEX; rerun with -h for copyright info\r\n  ==11001== Command: ./silentpayments_example\r\n  ==11001== \r\n  ==11001== Conditional jump or move depends on uninitialised value(s)\r\n  ==11001==    at 0x7FF802CAE587: ???\r\n  ==11001==    by 0x100004180: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x100035598: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x10000473D: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x100176417: (below main) (in /usr/lib/dyld)\r\n  ==11001== \r\n  ==11001== Use of uninitialised value of size 8\r\n  ==11001==    at 0x7FF802CAE5A3: ???\r\n  ==11001==    by 0x100004180: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x100035598: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x10000473D: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x100176417: (below main) (in /usr/lib/dyld)\r\n  ==11001== \r\n  ==11001== Use of uninitialised value of size 8\r\n  ==11001==    at 0x7FF802CAE5A8: ???\r\n  ==11001==    by 0x100004180: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x100035598: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x10000473D: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x100176417: (below main) (in /usr/lib/dyld)\r\n  ==11001== \r\n  ==11001== Conditional jump or move depends on uninitialised value(s)\r\n  ==11001==    at 0x100004183: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x100035598: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x10000473D: ??? (in ./silentpayments_example)\r\n  ==11001==    by 0x100176417: (below main) (in /usr/lib/dyld)\r\n  ==11001== \r\n  Alice created the following outputs for Bob and Carol: \r\n      1.0 BTC : 0x54bd4de574365e6ac3b45a8beebf37c27511d8ccdb0332ed2311ee40b2d39e5a\r\n      2.0 BTC : 0xa9f3b61fcf83b005e112fbacc870e7d67f6f4eecb4a29e92db70565e2622906d\r\n      3.0 BTC : 0x656a3a7c24337a82571c47e6fd1c5f52743e2dece9c9e0db5807ad4b16408df9\r\n  \r\n  Bob found the following outputs: \r\n      0xa9f3b61fcf83b005e112fbacc870e7d67f6f4eecb4a29e92db70565e2622906d\r\n  \r\n  Carol found the following outputs: \r\n      0x656a3a7c24337a82571c47e6fd1c5f52743e2dece9c9e0db5807ad4b16408df9\r\n      0x54bd4de574365e6ac3b45a8beebf37c27511d8ccdb0332ed2311ee40b2d39e5a\r\n  ==11001== \r\n  ==11001== HEAP SUMMARY:\r\n  ==11001==     in use at exit: 12,969 bytes in 178 blocks\r\n  ==11001==   total heap usage: 189 allocs, 11 frees, 14,112 bytes allocated\r\n  ==11001== \r\n  ==11001== LEAK SUMMARY:\r\n  ==11001==    definitely lost: 4,288 bytes in 134 blocks\r\n  ==11001==    indirectly lost: 0 bytes in 0 blocks\r\n  ==11001==      possibly lost: 600 bytes in 3 blocks\r\n  ==11001==    still reachable: 8,081 bytes in 41 blocks\r\n  ==11001==         suppressed: 0 bytes in 0 blocks\r\n  ==11001== Rerun with --leak-check=full to see details of leaked memory\r\n  ==11001== \r\n  ==11001== Use --track-origins=yes to see where uninitialised values come from\r\n  ==11001== For lists of detected and suppressed errors, rerun with: -s\r\n  ==11001== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 143 from 41)\r\n```",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2717105528",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 16708321340,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPj5MA8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16708321340",
      "actor": {
        "login": "davidgumberg",
        "id": 2257631,
        "node_id": "MDQ6VXNlcjIyNTc2MzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/davidgumberg",
        "html_url": "https://github.com/davidgumberg",
        "followers_url": "https://api.github.com/users/davidgumberg/followers",
        "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
        "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
        "repos_url": "https://api.github.com/users/davidgumberg/repos",
        "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-12T08:52:21Z"
    },
    {
      "event": "subscribed",
      "id": 16708321362,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPj5MBS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16708321362",
      "actor": {
        "login": "davidgumberg",
        "id": 2257631,
        "node_id": "MDQ6VXNlcjIyNTc2MzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/davidgumberg",
        "html_url": "https://github.com/davidgumberg",
        "followers_url": "https://api.github.com/users/davidgumberg/followers",
        "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
        "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
        "repos_url": "https://api.github.com/users/davidgumberg/repos",
        "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-12T08:52:21Z"
    },
    {
      "event": "mentioned",
      "id": 16708321376,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPj5MBg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16708321376",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-12T08:52:21Z"
    },
    {
      "event": "subscribed",
      "id": 16708321388,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPj5MBs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16708321388",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-12T08:52:21Z"
    },
    {
      "event": "reviewed",
      "id": 2679751532,
      "node_id": "PRR_kwDOAP4Jqs6fucNs",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2679751532",
      "submitted_at": "2025-03-12T21:47:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2680053411,
      "node_id": "PRR_kwDOAP4Jqs6fvl6j",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "LLFourn",
        "id": 3734083,
        "node_id": "MDQ6VXNlcjM3MzQwODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3734083?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LLFourn",
        "html_url": "https://github.com/LLFourn",
        "followers_url": "https://api.github.com/users/LLFourn/followers",
        "following_url": "https://api.github.com/users/LLFourn/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LLFourn/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LLFourn/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LLFourn/subscriptions",
        "organizations_url": "https://api.github.com/users/LLFourn/orgs",
        "repos_url": "https://api.github.com/users/LLFourn/repos",
        "events_url": "https://api.github.com/users/LLFourn/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LLFourn/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2680053411",
      "submitted_at": "2025-03-12T23:03:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2720290306,
      "node_id": "IC_kwDOAP4Jqs6iJFYC",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2720290306",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T07:58:33Z",
      "updated_at": "2025-03-13T07:58:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "@josibake \r\n\r\n> @real-or-random , @jonasnick I left a TODO comment in the tests where I have two test cases for ensuring the `_create_outputs` function can handle malformed public keys passed in via the `recipients` arguments. Since this argument is provided by the user, I think it's reasonable to test for invalid public keys but I couldn't figure out how to do this with the way the `CHECK_ILLEGAL` macro works. I left a more detailed explanation in the TODO comment, would appreciate suggestions here!\r\n\r\nHow about this: https://github.com/jonasnick/secp256k1/commit/7c4ecb82066d7c7e69ecb4c0fc1f10c540e4eb72. It matches how we test multiple illegal callbacks in `test_sort_api(void)`.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2720290306",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 16727905641,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPlD5Vp",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16727905641",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T07:58:36Z"
    },
    {
      "event": "subscribed",
      "id": 16727905660,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPlD5V8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16727905660",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T07:58:36Z"
    },
    {
      "event": "mentioned",
      "id": 16727905672,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPlD5WI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16727905672",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T07:58:36Z"
    },
    {
      "event": "subscribed",
      "id": 16727905704,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPlD5Wo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16727905704",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T07:58:36Z"
    },
    {
      "event": "mentioned",
      "id": 16727905725,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPlD5W9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16727905725",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T07:58:36Z"
    },
    {
      "event": "subscribed",
      "id": 16727905740,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPlD5XM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16727905740",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T07:58:36Z"
    },
    {
      "event": "reviewed",
      "id": 2681171430,
      "node_id": "PRR_kwDOAP4Jqs6fz23m",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2681171430",
      "submitted_at": "2025-03-13T09:38:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2720732664,
      "node_id": "IC_kwDOAP4Jqs6iKxX4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2720732664",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T10:22:56Z",
      "updated_at": "2025-03-13T15:12:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "Regarding the Valgrind issue, I hacked together a CI run together on my repo that has debug symbols in the stack trace. ([It uses an old revision of macos-valgrind.](https://github.com/LouisBrunner/valgrind-macos/issues/108#issuecomment-2720726118))\r\n\r\n<details>\r\n<summary>GCC (https://github.com/real-or-random/secp256k1/actions/runs/13831759976/job/38697947710#step:5:409): </summary>\r\n\r\n```\r\n==22290== Conditional jump or move depends on uninitialised value(s)\r\n==22290==    at 0x7FF804093587: ???\r\n==22290==    by 0x10000318A: label_lookup (silentpayments.c:104)\r\n==22290==    by 0x10001CBD6: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:575)\r\n==22290==    by 0x10001DF11: main (in ./silentpayments_example)\r\n==22290== \r\n==22290== Use of uninitialised value of size 8\r\n==22290==    at 0x7FF8040935A3: ???\r\n==22290==    by 0x10000318A: label_lookup (silentpayments.c:104)\r\n==22290==    by 0x10001CBD6: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:575)\r\n==22290==    by 0x10001DF11: main (in ./silentpayments_example)\r\n==22290== \r\n==22290== Use of uninitialised value of size 8\r\n==22290==    at 0x7FF8040935A8: ???\r\n==22290==    by 0x10000318A: label_lookup (silentpayments.c:104)\r\n==22290==    by 0x10001CBD6: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:575)\r\n==22290==    by 0x10001DF11: main (in ./silentpayments_example)\r\n==22290== \r\n==22290== Conditional jump or move depends on uninitialised value(s)\r\n==22290==    at 0x10000318D: label_lookup (silentpayments.c:104)\r\n==22290==    by 0x10001CBD6: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:575)\r\n==22290==    by 0x10001DF11: main (in ./silentpayments_example)\r\n```\r\n</details>\r\n<details>\r\n<summary>Apple clang (https://github.com/real-or-random/secp256k1/actions/runs/13831759976/job/38697947703#step:5:403)</summary>\r\n\r\n```\r\n==21757== Conditional jump or move depends on uninitialised value(s)\r\n==21757==    at 0x7FF813DF8587: ???\r\n==21757==    by 0x100000690: label_lookup (silentpayments.c:104)\r\n==21757==    by 0x1000217D8: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:575)\r\n==21757==    by 0x100000C4D: main (silentpayments.c:386)\r\n==21757== \r\n==21757== Use of uninitialised value of size 8\r\n==21757==    at 0x7FF813DF85A3: ???\r\n==21757==    by 0x100000690: label_lookup (silentpayments.c:104)\r\n==21757==    by 0x1000217D8: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:575)\r\n==21757==    by 0x100000C4D: main (silentpayments.c:386)\r\n==21757== \r\n==21757== Use of uninitialised value of size 8\r\n==21757==    at 0x7FF813DF85A8: ???\r\n==21757==    by 0x100000690: label_lookup (silentpayments.c:104)\r\n==21757==    by 0x1000217D8: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:575)\r\n==21757==    by 0x100000C4D: main (silentpayments.c:386)\r\n==21757== \r\n==21757== Conditional jump or move depends on uninitialised value(s)\r\n==21757==    at 0x100000693: label_lookup (silentpayments.c:104)\r\n==21757==    by 0x1000217D8: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:575)\r\n==21757==    by 0x100000C4D: main (silentpayments.c:386)\r\n```\r\n</details>\r\n\r\n\r\n",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2720732664",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "reviewed",
      "id": 2681509205,
      "node_id": "PRR_kwDOAP4Jqs6f1JVV",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2681509205",
      "submitted_at": "2025-03-13T11:21:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2721001075,
      "node_id": "IC_kwDOAP4Jqs6iLy5z",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2721001075",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T11:54:09Z",
      "updated_at": "2025-03-13T15:16:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "@josibake As soon as you rebase on #1655, you should get the Valgrind error output, with a full human-readable stack trace.\r\n\r\nBut I hacked together a CI jobs to see it already now:\r\n - https://github.com/real-or-random/secp256k1/actions/runs/13836954165/job/38714314881#step:5:398\r\n\r\nHere's a snippet:\r\n```\r\n==22464==    by 0x100000690: label_lookup (silentpayments.c:104)\r\n==22464==    by 0x1000217D8: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:575)\r\n==22464==    by 0x100000C4D: main (silentpayments.c:386)\r\n==22464==  Uninitialised value was created by a stack allocation\r\n==22464==    at 0x100020ACD: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:477)\r\n```\r\n\r\nMy conclusion is that this is a false positive, caused by the use of `memcmp` in the example code.\r\n\r\n[The errors are gone](https://github.com/real-or-random/secp256k1/actions/runs/13836935297/job/38714251450) when I [replace `memcmp` by `secp256k1_memcmp_var`](https://github.com/real-or-random/secp256k1/commit/82de1c833ac7c661bf8833e82285f510ce69d1c1). \r\n\r\nSo this is harmless. But I'm not entirely sure yet what we should do about this. In general, it's desirable that Valgrind passes cleanly on the examples. But Valgrind on macOS is a somewhat special thing because you'll need the macos-valgrind fork anyway, which does the job, but is maintained by a single person on a best-effort basis and needs to be installed via special brew commands etc.  So it would be okay to write our own Valgrind error suppression file for these memcmp errors, enable it in our CI  and be happy. Anyone who runs Valgrind without the suppression file will still see the errors, but due to the special setup that is required, it's unlikely that many users will run into this, and if so, they probably won't panic but instead be prepared for any false positives. \r\n\r\nAlternatively, we could really switch to `secp256k1_memcmp_var` in the example, preferably renamed and with a brief comment that explains that we use this only due to a bug in Valgrind, and there's no (other) reason not to use the real `memcmp`.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2721001075",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 16734871430,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPled-G",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16734871430",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T11:54:15Z"
    },
    {
      "event": "subscribed",
      "id": 16734871588,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPleeAk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16734871588",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T11:54:15Z"
    },
    {
      "event": "reviewed",
      "id": 2682040199,
      "node_id": "PRR_kwDOAP4Jqs6f3K-H",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2682040199",
      "submitted_at": "2025-03-13T13:59:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "mentioned",
      "id": 16741919427,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPl5WrD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16741919427",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T15:13:03Z"
    },
    {
      "event": "subscribed",
      "id": 16741919462,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPl5Wrm",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16741919462",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T15:13:03Z"
    },
    {
      "event": "reviewed",
      "id": 2682370373,
      "node_id": "PRR_kwDOAP4Jqs6f4blF",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2682370373",
      "submitted_at": "2025-03-13T15:15:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2721751050,
      "node_id": "IC_kwDOAP4Jqs6iOqAK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2721751050",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T15:53:31Z",
      "updated_at": "2025-03-14T09:07:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "@LLFourn I've included the possibility of x-only ECDH (and x-only B_scan) in my review document of the BIP: https://gist.github.com/sipa/c9299811fb1f56abdcd2451a8a078d20",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2721751050",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 16743071923,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPl9wCz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16743071923",
      "actor": {
        "login": "LLFourn",
        "id": 3734083,
        "node_id": "MDQ6VXNlcjM3MzQwODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3734083?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LLFourn",
        "html_url": "https://github.com/LLFourn",
        "followers_url": "https://api.github.com/users/LLFourn/followers",
        "following_url": "https://api.github.com/users/LLFourn/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LLFourn/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LLFourn/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LLFourn/subscriptions",
        "organizations_url": "https://api.github.com/users/LLFourn/orgs",
        "repos_url": "https://api.github.com/users/LLFourn/repos",
        "events_url": "https://api.github.com/users/LLFourn/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LLFourn/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T15:53:33Z"
    },
    {
      "event": "subscribed",
      "id": 16743071948,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPl9wDM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16743071948",
      "actor": {
        "login": "LLFourn",
        "id": 3734083,
        "node_id": "MDQ6VXNlcjM3MzQwODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3734083?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LLFourn",
        "html_url": "https://github.com/LLFourn",
        "followers_url": "https://api.github.com/users/LLFourn/followers",
        "following_url": "https://api.github.com/users/LLFourn/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LLFourn/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LLFourn/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LLFourn/subscriptions",
        "organizations_url": "https://api.github.com/users/LLFourn/orgs",
        "repos_url": "https://api.github.com/users/LLFourn/repos",
        "events_url": "https://api.github.com/users/LLFourn/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LLFourn/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T15:53:33Z"
    },
    {
      "event": "reviewed",
      "id": 2682270704,
      "node_id": "PRR_kwDOAP4Jqs6f4DPw",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2682270704",
      "submitted_at": "2025-03-14T17:17:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2687486162,
      "node_id": "PRR_kwDOAP4Jqs6gL8jS",
      "url": null,
      "actor": null,
      "commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2687486162",
      "submitted_at": "2025-03-17T10:57:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDhmNjkyOTcyMTUzYjE0YzMxMzhlM2M5NWFjNzc2OTYyZWQwYThmZWE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8f692972153b14c3138e3c95ac776962ed0a8fea",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8f692972153b14c3138e3c95ac776962ed0a8fea",
      "tree": {
        "sha": "44cef0e5ba1cc2180a8930b2b6ecbe9ab59630d5",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/44cef0e5ba1cc2180a8930b2b6ecbe9ab59630d5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 44cef0e5ba1cc2180a8930b2b6ecbe9ab59630d5\nparent 70f149b9a1bf4ed3266f97774d0ae9577534bf40\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1695828134 +0200\ncommitter josibake <josibake@protonmail.com> 1742233319 +0100\n\nbuild: add skeleton for new silentpayments (BIP352) module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmfYXu4ACgkQity1WMTz\nPWVtwg/+Pyr/rXggWw7vP0iGWIsztlthuBmsEZ7xcBwSI+9RiRFUhvzuWd5KNqd6\naN1vleX9JIekiEDTvES/0VIrRMrjBkxeoeawB4BzIMFmDXqwy1b1LNzSRo78IN+x\n7cEBJ+1ZEFPOLbGcMNHQAdRk3LJ/FgmBnxXs4dODb23j3LxDUfCe8Ctz13TI3Miw\nFCISzjNxwNLjULiRD8fEgjyerNC+iYZ21g8r06MrrZFgR4MF4u5P1vLBHrmiXeNi\nySFEFZQicFMvB+7Af6/grCay9fC0zBRkEse11prLGZl1Ppsg43t9BrKZ3YJ8NZ9e\ndIPw8IAHj4I+LvNcdoeEIKn3/NTys27+MC6VbVA+0HNrCUkM+AXoTKTGlCGSIVMB\ntBI2DLxTs5x84Ays77dlVXlPxkV6W1PoUrZh1u9ff5TQEu3Rltt5byvzBMQXjOR3\n2Pj8GkMcO/2YdaX4yUyAG7i69XKCA3gD67IwvZW5B40gycScC0B1uuB3dChdW6SJ\nUDIAnV0xXX5pZkNgKS+yPN4cx08qQxUyAsJ/xrTj0aD6LXtPjLKe0f5rnptA5fMO\nzZ0chlETRm5XBKpiLDVnctE051kQdnd9+1lWj7H00Crysy9rCluu7dzWpiQSY0r2\nPk2d3DB6QxsyA0FZwSr70g4KqyHczqcXdafJcEePvM9SCiLMXys=\n=AEVW\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/70f149b9a1bf4ed3266f97774d0ae9577534bf40",
          "sha": "70f149b9a1bf4ed3266f97774d0ae9577534bf40",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/70f149b9a1bf4ed3266f97774d0ae9577534bf40"
        }
      ],
      "message": "build: add skeleton for new silentpayments (BIP352) module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-03-17T17:41:59Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2023-09-27T15:22:14Z"
      },
      "sha": "8f692972153b14c3138e3c95ac776962ed0a8fea"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDU0MmFlZjJlYjU5NGY3YWU5NTA2MzRkYjFjMDU5Y2Y4YWQ0MDczMjQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/542aef2eb594f7ae950634db1c059cf8ad407324",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/542aef2eb594f7ae950634db1c059cf8ad407324",
      "tree": {
        "sha": "f20762b54f710c03967c1d6c3a350cb2d8f410f5",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/f20762b54f710c03967c1d6c3a350cb2d8f410f5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree f20762b54f710c03967c1d6c3a350cb2d8f410f5\nparent 8f692972153b14c3138e3c95ac776962ed0a8fea\nauthor josibake <josibake@protonmail.com> 1711383817 +0100\ncommitter josibake <josibake@protonmail.com> 1742307934 +0100\n\nsilentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmfZgmUACgkQity1WMTz\nPWXolRAApEQdilUGmQtBWPSwhFokOjvQJMbzPY4hjD/mcOCr7gh3eIBAvuxQ+w7g\nKX/LQLMBA65puHFlOXjGzotTJ9KxhoqlqvZUmz6J1vY+v1kEVmhEc7At6uhJtF2q\nMRtZr6e7Q3qy2KXg5z7h04QDjE0rDKaEHCWzkhoe2JOUHojZfEf4wMxiips41elk\niqimbaM4oyC1ZN54UKOibq23bGtXmWEB07JQem7/VOLJyQ+bFmbOnARSmQFAS5ZP\n2OCV70iZVqRZCSgccpXD7+vStmoGzrcNkEgkY2Hy/V0oSWH31sldQ+WaJk/3avHR\nDMJDLOY4B4TxvCp4XSBNNPL1+UIfFEMcfXamRrnHOodfgk0CIc0jDSVTFt7TP2z9\nMrN260Hy5mf+HKNQnAWe9ZfSt21xiDyNYuDQOaWDT/i7/JTRDC69UgeEboPIjHh3\nHl91LQCF0hbt3rC+A0g8KcSNjVm9Oqu2+WNssbncGoMtOVlkWoMmOTgy/jCE09tu\nc/Eplr7jrnDCq1s39AdXKC1d9Zucd/LIGcawjSVXv9wC26avJEHqVzVV6g95ZuYb\niAXeqiSypIlHjZcwQJFTNgbWapM7fyhBQUE1HsU5iIW03aA0yJNH52gBrH5qHlrt\nh1xPCUKETBqXpinEVj7gGwOLqW+a5OjWZzmbQ0DjX51BAa+811Y=\n=K+Qc\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8f692972153b14c3138e3c95ac776962ed0a8fea",
          "sha": "8f692972153b14c3138e3c95ac776962ed0a8fea",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8f692972153b14c3138e3c95ac776962ed0a8fea"
        }
      ],
      "message": "silentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-03-18T14:25:34Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-03-25T16:23:37Z"
      },
      "sha": "542aef2eb594f7ae950634db1c059cf8ad407324"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDRiM2YyNGNlMzllNDc0YWM1ZmIyZjk3OTkzNzc5ODhlOTI3ZmVkMzg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4b3f24ce39e474ac5fb2f9799377988e927fed38",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4b3f24ce39e474ac5fb2f9799377988e927fed38",
      "tree": {
        "sha": "53bbff9fd4ca67a1bc3f6f89155f536e23ee1130",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/53bbff9fd4ca67a1bc3f6f89155f536e23ee1130"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 53bbff9fd4ca67a1bc3f6f89155f536e23ee1130\nparent 542aef2eb594f7ae950634db1c059cf8ad407324\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1705946165 +0100\ncommitter josibake <josibake@protonmail.com> 1742307941 +0100\n\nsilentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labelled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labelled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labelled\nsilent payment address.\n\nAdd tests for the label API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIyBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmfZgmsACgkQity1WMTz\nPWUO6g/4wgaW+koNXB6N+bpPLVftlXisFrYfaKhqmQMI361WjRvHgctF+yQoitRH\nY05gk7NL7IGUf43toxTlej2rASP+KZUI3d+gT4uk1OJyXnOWoeO1MVU+Y32z3NUQ\nC2vAkh8jWEoe7O8Mn9nwuhWs+97KBYhsmZCDRFXOKUJq3kSRzaYKs+oYmwJt03PA\nOLIh5GxiYIvdUnbzrO5tb0pp13XxEYC/FthEt5hjJQauDOOaZPfUJoMBa+xihgiH\nqpV6a5e6QYJOaLdP4YXZLao7thmEx3Y3NzxlrUZ+OFX/voXDBUMLOa81vpUvMkGc\nQukbKOzToX9IkicIRkgOwOkMu3Bw5hTvtdBlUHlMMXuj1t1zCrXxVGHAEKiKYmbo\nrNJWnWUthB66wl3sngmYiCHfEAdjAHMu+GhwPvhxkCu4jDK/kIYRNqNVLBAhwBJq\nL+6vIGTY0w7TwhafGhtveSQbrngjBXO35OuAOly8Y8gtn+71uUSTYSpVg1/eYzwH\nc8rs6DtAhF0hD2jpG8S+UTfYQRdiaRAx0MrvBgsgZDbXbJK5v3LdLN+72Q2XNX7y\nuZkWm2J8Rouxj7ASgIB/HV0X8B4Nk8LWqC/+RGY8jCszehfBGlnQCA+pKkZZLSOJ\nyCkLerjSLNwCHS7QmqBYx4ljeu5LVU2PIzM4b4MPaJEoMc1dAg==\n=y2H5\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/542aef2eb594f7ae950634db1c059cf8ad407324",
          "sha": "542aef2eb594f7ae950634db1c059cf8ad407324",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/542aef2eb594f7ae950634db1c059cf8ad407324"
        }
      ],
      "message": "silentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labelled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labelled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labelled\nsilent payment address.\n\nAdd tests for the label API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-03-18T14:25:41Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-01-22T17:56:05Z"
      },
      "sha": "4b3f24ce39e474ac5fb2f9799377988e927fed38"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16838183784,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAProkto",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16838183784",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f5740a4c4bea5cc1e47fd0b95eba809a594f8eef",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/f5740a4c4bea5cc1e47fd0b95eba809a594f8eef",
      "created_at": "2025-03-18T15:59:14Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16838283996,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAPro9Lc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16838283996",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c31114a206bd498186eba7547f982aedc54eea27",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/c31114a206bd498186eba7547f982aedc54eea27",
      "created_at": "2025-03-18T16:03:12Z"
    },
    {
      "event": "commented",
      "id": 2733839704,
      "node_id": "IC_kwDOAP4Jqs6i8xVY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2733839704",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T16:08:57Z",
      "updated_at": "2025-03-18T16:08:57Z",
      "author_association": "MEMBER",
      "body": "Rebased https://github.com/bitcoin-core/secp256k1/commit/71df073ade5bf54d593ce95a2fdaefe3552318d0 -> https://github.com/bitcoin-core/secp256k1/commit/c31114a206bd498186eba7547f982aedc54eea27 ([bip352-silentpayments-module-18](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-18) -> [bip352-silentpayments-module-rebased](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-rebased), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-18..josibake:secp256k1:bip352-silentpayments-module-rebased))\r\n\r\n* Rebased on master\r\n* Also included a fix for the Valgrind false positive in the example (h/t @real-or-random for helping me troubleshoot this!)\r\n\r\nSeparating the rebase from addressing feedback for my own sanity and to help make sure I haven't missed any feedback.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2733839704",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 16838433306,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPrphoa",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16838433306",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T16:08:59Z"
    },
    {
      "event": "subscribed",
      "id": 16838433335,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPrpho3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16838433335",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T16:08:59Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDhhNzkzMjBkNjUwYmM3ZmNkZTIwODQxYjY5ZjNhNDA3OWQyZDM1NzM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8a79320d650bc7fcde20841b69f3a4079d2d3573",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8a79320d650bc7fcde20841b69f3a4079d2d3573",
      "tree": {
        "sha": "5f4e58a53ddf00e5642c560b905b6a01d64ac949",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/5f4e58a53ddf00e5642c560b905b6a01d64ac949"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 5f4e58a53ddf00e5642c560b905b6a01d64ac949\nparent 4b3f24ce39e474ac5fb2f9799377988e927fed38\nauthor josibake <josibake@protonmail.com> 1719660810 +0200\ncommitter josibake <josibake@protonmail.com> 1742315601 +0100\n\nsilentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the summed input public key (A_sum)\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply b_scan * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a public_data object to\nand from a public key. When serializing a public_data object, the\ninput_hash is multplied into A_sum. This is so the object can be stored\nas public key for wallet rescanning later, or to vend to light clients.\nFor the light client, a `_parse` function is added which parses the\ncompressed public key serialization into a `public_data` object.\n\nFinally, add test coverage for the recieiving API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmfZoFgACgkQity1WMTz\nPWXY2xAAz6ZL7piOgEi6nAAjE9MJ5BFq7rEGP26QXpMN7XhcDTxLZLpcyC8ki6MU\nYeuyMuJMZjK5RW6hdLyWAvs33qqTdDIO0/w9YztaFenLz2RZ2zMLRGn+ZDqsz9HU\nYC72lYaCAmS98xpYSsAlg+UPapa2FI1isXZWwiOTGiK031/N8+d8rGiJY/Mt6Rn2\nNoYgP6v5in2po0Nn/hs03wrF3kko6VOT7vf/Pnq9lHVTfuAeFzcxTumbOwjDE/LF\nuRHLDUL1XY+1BifHuS4f7Ta3nNSrXO862ny/MJS8Siof2SN7knyGnS1Ur3HJHnEb\n/A0HNO5OQ+4M854pELwRADH5r3Hr+WUldByueP5uP3bN65gshz0hCxsQ4Wu09kVf\nqhQLlyK0cNKXIDPyO4dJAUyLGBjzyeBcJpZMmUGX+ymquTeoJ/3UsRgxitD6WZUp\n8vdWzezruksMuLXve2bJgMhUW1zb4GtbAZctlsLqODjBA3tiDHxbUfTGZzw5hcBa\nBH3YvuvC3hPL5dhW3WzXt50+TdmdY5xOQNGQJ7lLJjcZ+TdziY8+ClM4sZxHil8R\nf+8vJJtAaqHIvXhrz4ZYC9tIbOHmk/GfZ7RZYABhyNtMjxyDnu+peOpwXlDQ1klo\nxvo0GCK4jzh8ndzTePYXkzjCHdFWoosKFYMSDsMUb144lA4/qlk=\n=eMmB\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4b3f24ce39e474ac5fb2f9799377988e927fed38",
          "sha": "4b3f24ce39e474ac5fb2f9799377988e927fed38",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4b3f24ce39e474ac5fb2f9799377988e927fed38"
        }
      ],
      "message": "silentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the summed input public key (A_sum)\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply b_scan * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a public_data object to\nand from a public key. When serializing a public_data object, the\ninput_hash is multplied into A_sum. This is so the object can be stored\nas public key for wallet rescanning later, or to vend to light clients.\nFor the light client, a `_parse` function is added which parses the\ncompressed public key serialization into a `public_data` object.\n\nFinally, add test coverage for the recieiving API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-03-18T16:33:21Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-06-29T11:33:30Z"
      },
      "sha": "8a79320d650bc7fcde20841b69f3a4079d2d3573"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDQ2ZWZlM2ZlZjUyM2ZkYjQzNTc0N2EwNWJhNDA1NjJjNmYxMmY5NzI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/46efe3fef523fdb435747a05ba40562c6f12f972",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/46efe3fef523fdb435747a05ba40562c6f12f972",
      "tree": {
        "sha": "ab3bfab3acd02f01578417b4e2ffbbdf96c55baa",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ab3bfab3acd02f01578417b4e2ffbbdf96c55baa"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ab3bfab3acd02f01578417b4e2ffbbdf96c55baa\nparent 8a79320d650bc7fcde20841b69f3a4079d2d3573\nauthor josibake <josibake@protonmail.com> 1713202589 +0200\ncommitter josibake <josibake@protonmail.com> 1742315608 +0100\n\nsilentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmfZoFgACgkQity1WMTz\nPWVUVQ//WUL3BES5qgvbrXccYKaCfCKVFV+uqCjo0nVERGbRPILZXxuQQ+hp6rjc\npf2OLUHi4iswpLO0x/v7WEiE/32n2aqAOx2pV9FB6hjsW0mV5wvjAFqS9Q3GRh2r\ngwFKVRa4cZzGU18uLmx1Y/buupcQgzYDEPfwV9FeLPQplqxBCRsK4qoS6epwzfDy\n1HvrM30ByUUatrFAheZWu+hxwdR4Ujxqt6nUwBLT0OCsI1EmlMppKsOyUtyDZ9Ow\nT8Ty0YyoTs8s+S8BNZT8W7g/j4YYLqG996N/qGPe9CaqgPp77KY3CFdzpWS5UGhT\nQglQHxjIuLbWd1hkNfKzv4Ul+7pOFvYJXXun/lvKsR+/UbxcBRo/ZKGqZpYHhsFb\nMB0Y3G9G+C8IPx5tTrMQSEk37Rjx1p5TGqR8JG0B5An3zIIxHNGc8zwVgtn3xnxs\nbF3BRErcCI4b2ld5XsrnCnPFoP2Hh7i/lLrDV+Avk7nTrg7MXCMWwwRnRPiegFwR\nW6OSjdcTCglEm0cC6sztvl/M8jAtmvKGYNuQ9VPvyQ9P8NujmZy1e00lZYilTl0n\nQKFXnqTZ1F+A6xmiC2YEwVn7jOaFSOqItqZWi/UkKc+YwiVoGxW1yAStEXLrUGKb\nqjZEOd69aC/cWKnfIXsRhLqgE4lSz/q3h+S/sdq50/sZxirRT80=\n=rv68\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8a79320d650bc7fcde20841b69f3a4079d2d3573",
          "sha": "8a79320d650bc7fcde20841b69f3a4079d2d3573",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8a79320d650bc7fcde20841b69f3a4079d2d3573"
        }
      ],
      "message": "silentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-03-18T16:33:28Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-15T17:36:29Z"
      },
      "sha": "46efe3fef523fdb435747a05ba40562c6f12f972"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDVkNTU0NzNjZTEwZmIwY2RiMjIwYjFmNDUwOWVkOTc5OWMyMGJkM2M",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/5d55473ce10fb0cdb220b1f4509ed9799c20bd3c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/5d55473ce10fb0cdb220b1f4509ed9799c20bd3c",
      "tree": {
        "sha": "e9ce32e62553ce21aca5f50c6adcaa19ba87c4f1",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e9ce32e62553ce21aca5f50c6adcaa19ba87c4f1"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e9ce32e62553ce21aca5f50c6adcaa19ba87c4f1\nparent 46efe3fef523fdb435747a05ba40562c6f12f972\nauthor josibake <josibake@protonmail.com> 1714066415 +0200\ncommitter josibake <josibake@protonmail.com> 1742315608 +0100\n\nsilentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan and for scanning a single\noutput. Only benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmfZoFgACgkQity1WMTz\nPWWsWxAArMypFWjg/sWGEmbCw9bSeK7fiuuv0kjUwDfe05EbQ4hJ1qFwOJjZfddk\nHWKaRaryobY9yGwCnLpryrfZ6NCAber80sxn5X1L5zy2mtjIGLl8kAXjV1/6CtTn\nw3snua/CiMToOAcZ8OoboQe2+3THOauDYk0LzLBn3/HiEt7nZ5UQ+9SIQhFNrvbq\nv6QBVPnZWONOX9tGPtkHCbVa8VAJRvJ1Zzr2SPpAhkDlbDDa86hUqaceioi0u7pG\nSGJGdD8ktNA0qG7of0FOnyIDojecMkXxfgwbiwxRnyZIBiOt6iNnrHZCMqmlLbvZ\nUsjuhwbHDkBMnkn3Beco6jXIxq5TpgR5KnTRETOFTmCT1QEBfBCM4T+twFoMkbLi\nc2CWEPH5HPeEsJej9EmV3MGM779voBkKZX+48tDhTFVOd7fFA2FY8f73g+YcxQkN\nhdDKZoUpKf4wrm3guSx50xrpaU7XU+B7dLMR8NFhb+38Qqh5HJUeGPWAOGbMGLRQ\nFNAdyraKsxJOwK1g/8TPhXzWg0B5nS2ZGrRm9WDwp4y+KnJ/KLL+TlNLcASai4jl\nEIPhSmGrOWp+nAZ9yG7HOOKzvq6QrhSDbfw1a6h6gX76AGB4CZ1Xd7Yql7Bt+nQi\nauBH1WLNwB+GW635aFaVgiEOY+iq+zbCJ03gp30dxddzkXvRywU=\n=7mk6\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/46efe3fef523fdb435747a05ba40562c6f12f972",
          "sha": "46efe3fef523fdb435747a05ba40562c6f12f972",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/46efe3fef523fdb435747a05ba40562c6f12f972"
        }
      ],
      "message": "silentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan and for scanning a single\noutput. Only benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-03-18T16:33:28Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-25T17:33:35Z"
      },
      "sha": "5d55473ce10fb0cdb220b1f4509ed9799c20bd3c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGEzZTA0ZmZlMjE4ZGFmMTUyYmQyOGJmNTM2OWM2NmQ4NWQ5MmI5MTI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a3e04ffe218daf152bd28bf5369c66d85d92b912",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a3e04ffe218daf152bd28bf5369c66d85d92b912",
      "tree": {
        "sha": "a5188a4b02969b42ad923926306fde037223ba50",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/a5188a4b02969b42ad923926306fde037223ba50"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree a5188a4b02969b42ad923926306fde037223ba50\nparent 5d55473ce10fb0cdb220b1f4509ed9799c20bd3c\nauthor josibake <josibake@protonmail.com> 1719942343 +0200\ncommitter josibake <josibake@protonmail.com> 1742315608 +0100\n\ntests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmfZoFgACgkQity1WMTz\nPWXFdw/+LUO+TKcBbH4MRyCWW7Icuf9wS7VCXA4EBCipxhzaztulysrwcr4LgVI6\nlupEsw4zlOYtHWnKl5bge/kScbk4GSta/iLHiIbvWfnmDioulSyU1xQa8u2+PNbL\nt4Rf9LTyXVzJeyBdes2tualfP+9t+qMdxrTkvV9gMZN+GldNjj47XPKOoUOdn3U6\n4ak8b+HZ02RPc+qS8qEEWsOvN3LL3GHYcBR0STCPUaluS13SQwr1SuocJ/XetbdC\nns2PO6NLCxABtC1xkjaB56tTPRKOmvoIQC7HJdm8fpIzTAjYYcBvzTrXUR+nEbqp\n0GqsgBmswxv05U4aDWJPQenhfcH2o5UiB6+ZtxwuXUEcU6Ke+Bu6wSAgD8B8FKdv\nSF5Ir3teLjZwGtBnTSOKZULuWW1asdg2Yxh/Is26HnDs7aQOFRxJFqJGGL/FvVxa\nUFZn7yzQ+xqbhYnZwQGyxywyzjUbbJbuQfmcjTvMtl5rvzBOc0RvIeAV/yKAZglu\nD/Y3atOgMtgVHuG8FwuIYtqvdKaon4oHxxTjJKc5p9xzr2a01hO0MywbjdS6+MJt\nqu+tUdc4Q57llPHspZDgEzJ2grCleSgfz6zysEA6ukD39ntd4l+1rrLX9ursOSrq\nm55PIcqWxPHcK0yjpUpv8k5uoiOjOS4FVIlr4ltgpC8qkb/dKM0=\n=Bk3k\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/5d55473ce10fb0cdb220b1f4509ed9799c20bd3c",
          "sha": "5d55473ce10fb0cdb220b1f4509ed9799c20bd3c",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/5d55473ce10fb0cdb220b1f4509ed9799c20bd3c"
        }
      ],
      "message": "tests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-03-18T16:33:28Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-02T17:45:43Z"
      },
      "sha": "a3e04ffe218daf152bd28bf5369c66d85d92b912"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDY4ODQ2ZTg5MTMxYmQ5NTA5N2Y2ODQ1MmYyYjdmZDRlY2JhMjU1ZTA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/68846e89131bd95097f68452f2b7fd4ecba255e0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/68846e89131bd95097f68452f2b7fd4ecba255e0",
      "tree": {
        "sha": "ce946d95fc5e0e47dc7a5a16a4a98c9633ec1846",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ce946d95fc5e0e47dc7a5a16a4a98c9633ec1846"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ce946d95fc5e0e47dc7a5a16a4a98c9633ec1846\nparent a3e04ffe218daf152bd28bf5369c66d85d92b912\nauthor josibake <josibake@protonmail.com> 1730981939 +0100\ncommitter josibake <josibake@protonmail.com> 1742315609 +0100\n\ntests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmfZoFkACgkQity1WMTz\nPWXD0A//Sryhsov+UPfaB5YdmUQVLmJWdf3yMgb4qu5gkdlb0t+S2SjI5P29Y4uS\nfQO4Hmr3OLwLDUETYfweSlyJlwyV5hEVh6lE1K547ARRX3loTRpU59xGZ9aFu/Pc\n18ritZdHrtSXll+1svxRZqIybFfO5n0oC4dtMzKju7i8KSPek+D1hZZ/6/SHwFcc\nulD8oTuFfPw0Bl9mBj0uB2pQojPIoun9PvWhxouyAfq3mVtXALZc1YmanRuXX1Nz\nFiU4Nt0N7rnVsxdKqHDvaMiTa3ha0fhyLcqpDv76xe6wgEtwpQHOtsHvyaWpVP4g\ngYs+ub8p/XQXVDLQkRsWv0jWfblI43pEzb0kdwwTGEavo8YKNPVsia2mWAyFyuz2\nzg03dGtnazLHBgsQ/vm3ErQD6LJ6bz42Rkh61xdSAba0PpbyZV0mZFUoU7uGexAj\n5K70JlY58jf77rU1/ZLDBg8NaSWVXc0iWvUH2iSPqzZ8XEBhWMpzN4LAj3GjLht9\nBe1kvoUcZ2xpzfx9BxbJ8nAjjYIR0E/8hoxZVMvhxWr9rDaqBjFDYSELM2pZ3vax\nnVqzrIymMwrgAu6hqjHS2mun5Ga3KZZBR4KItLtL2FO0KrRYQBykIwMgprvSkwV3\nOu9p2rpm5BdHee+ZOIl1jlx1Qf9YT/MHFHrkeOnKpmKULDDX1ik=\n=bcMH\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a3e04ffe218daf152bd28bf5369c66d85d92b912",
          "sha": "a3e04ffe218daf152bd28bf5369c66d85d92b912",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a3e04ffe218daf152bd28bf5369c66d85d92b912"
        }
      ],
      "message": "tests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-03-18T16:33:29Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-11-07T12:18:59Z"
      },
      "sha": "68846e89131bd95097f68452f2b7fd4ecba255e0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDAwYWMzMWMxMWYzZGM5ODE1ZmM4MzAyZDM4ZmNhYjRiMzAxZWM2OTc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/00ac31c11f3dc9815fc8302d38fcab4b301ec697",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/00ac31c11f3dc9815fc8302d38fcab4b301ec697",
      "tree": {
        "sha": "dcf6e970eecaba864a9f3a12b242f7647ba7488d",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/dcf6e970eecaba864a9f3a12b242f7647ba7488d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree dcf6e970eecaba864a9f3a12b242f7647ba7488d\nparent 68846e89131bd95097f68452f2b7fd4ecba255e0\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1708644341 +0100\ncommitter josibake <josibake@protonmail.com> 1742315609 +0100\n\nci: enable silentpayments module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmfZoFkACgkQity1WMTz\nPWVqDxAArBNC7qLMyd+8i22zerxcJIrq2k2rQ1V+yy4itTF913DrHDDaC5Idsfti\ntLfjAna/GfGyAf6KfqGYj9X3IH2ngEaw+rfmUjw3J7CIVxu6qfzqYhlGZx8QFDm5\nb7N84Sn/A7GdXCqrfKJdXkR5EK2Gv0rFbRdC5GcyhP+61vtKF7p1r5L3FM8xEagd\nLGKrWo35PixEnhF/H1M8BKKVENEBol8SsaAxpISbf9bcWcxd2MjrG9mvk/v0tjYJ\nYPSTsXt5TDRV30TohoAkLnAXK1Ka3VqWKMNWCyFHDbGNT15VVllyYFASthqipkY9\nEq9cUIdggDcwthx9urubicUHmwjvlNW7QqRBwF9Y3n2u8gILbg9W5y/3VBLlG1P7\nYxNe4sFd0m5qXpNmTL3Sb5mf8U/SaaM4uvMqPzZWKqr0vDyS7Llfj2jK9MPdBjDN\njg3P6411eRsJ5miOWxOc7yvp4trFk4qvq4z2FEFeYrJL6ao/vtJJHidz1OowhhYO\ndJRUqzaUN0JdZ/DNOzP/pq3XJnlVfN/PFmwrKGow4kUALFGXFkSIWSSr2rM700+k\ntaHDyEMWDGXvm+EpGZFmz7//94oTHBSx9RJACkgbT13XTlEmQ1KsZVRsQCO5ldwG\n9dZ1njxfoP+bk2dApwdAWGRBCnmRORUfV8bsBos0XIC80jkM8rQ=\n=1CaK\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/68846e89131bd95097f68452f2b7fd4ecba255e0",
          "sha": "68846e89131bd95097f68452f2b7fd4ecba255e0",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/68846e89131bd95097f68452f2b7fd4ecba255e0"
        }
      ],
      "message": "ci: enable silentpayments module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-03-18T16:33:29Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-02-22T23:25:41Z"
      },
      "sha": "00ac31c11f3dc9815fc8302d38fcab4b301ec697"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDU5MmYyNTE3YzQ0YzI1MDA5ZTMwMjFkMDZmZjRlZDljOGVlZTkwNjk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "tree": {
        "sha": "d38ca8d0ca0144125aeb3cde61e63ac9209137df",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/d38ca8d0ca0144125aeb3cde61e63ac9209137df"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree d38ca8d0ca0144125aeb3cde61e63ac9209137df\nparent 00ac31c11f3dc9815fc8302d38fcab4b301ec697\nauthor josibake <josibake@protonmail.com> 1720789074 +0200\ncommitter josibake <josibake@protonmail.com> 1742315609 +0100\n\ndocs: update README\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmfZoFkACgkQity1WMTz\nPWXwrhAAilU9KANO79mVb7Cm5Lvi7X+BR6fnyDji+tQlwA5aFSrtksQYuAsEfz25\ncbgamWFKIHgaS/85OuVUtfJqhN46YzZ7gjRgT1zMIa1OzAw4GfNW3ztFWx9rkoQR\nga9sXHOrHW8W6rY9+p1lXkdSRx5io5Jf0Chc/gjyfkZO4gaV+vw3ggSW832dtKwF\nMVyhByHyG1uxua3I8ui1wr+NAVNCvPuKktDmhp0KWjdGT9pf7e6Brcjxqg0K3/i6\no/Znejabp/KRMkmmj2r4qy5yJr8uUTsjsYm/x7eP9ZWwcILRkIBHq+490/UIG66x\nxyjqKifoWpSCijSoM6400sK4ZfUD1PCJul0hM1SD6+OPTqWL/KM/tOGfZAWEijIb\nXuZIoOabM9epJGNDqm65KsfP/urjh2V6ZQxuZCmf5qnxagFpqJWob2mbGzg3zkXw\nMyL7fzu4gB8/Y6OA5DNyvgOvhhBPVyPVEQBuGKjPSMY2uwLs6T+AWTTvts3JNScV\naoPo3PBVNhzqCSKzoyd8EeS4n6dH4O6m5MTACnsbCc9qNEw+6rsnmqorNLus1qzw\njoAZfxs8k/iG92bRN91XG16sB0nuLwD17/MfIiz0uGKGhthXq0u7gg9sSgGQkVc4\nrzVstxUMcRZEC116FibhJzqxjmc/N+b2SQolRcY6kBA2u7Q2oy0=\n=FubV\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/00ac31c11f3dc9815fc8302d38fcab4b301ec697",
          "sha": "00ac31c11f3dc9815fc8302d38fcab4b301ec697",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/00ac31c11f3dc9815fc8302d38fcab4b301ec697"
        }
      ],
      "message": "docs: update README",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-03-18T16:33:29Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-12T12:57:54Z"
      },
      "sha": "592f2517c44c25009e3021d06ff4ed9c8eee9069"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16840028048,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAPrvm-Q",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16840028048",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "created_at": "2025-03-18T17:02:22Z"
    },
    {
      "event": "commented",
      "id": 2734104335,
      "node_id": "IC_kwDOAP4Jqs6i9x8P",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2734104335",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T17:19:09Z",
      "updated_at": "2025-03-18T17:19:09Z",
      "author_association": "MEMBER",
      "body": "Updated https://github.com/bitcoin-core/secp256k1/commit/c31114a206bd498186eba7547f982aedc54eea27 -> https://github.com/bitcoin-core/secp256k1/commit/592f2517c44c25009e3021d06ff4ed9c8eee9069 ([bip352-silentpayments-module-rebased](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-rebased) -> [bip352-silentpayments-module-19](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-19), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-rebased..josibake:secp256k1:bip352-silentpayments-module-19))\r\n\r\nA few smaller changes, namely:\r\n\r\n* Spelling and wording fixup's\r\n* Change `k` and `m` to be `uint32_t`\r\n* Improving test coverage for malformed inputs (h/t @jonasnick)\r\n\r\nBigger changes:\r\n\r\n* Introducing magic bytes to ensure `public_data` is initialised correctly and only contains valid data - this is inspired by the approach in the new musig2 module. Looking for feedback on how I implemented this and on the choice of magic bytes (easy enough to change). Not fully satisfied with how this is implemented but figured I'd push what I had and see what others think\r\n* Reworked the example - notably, showed how to use the spend key + tweak for spending the output and added a check that demonstrates usage of the `create_labelled_spend_pubkey` function\r\n\r\nI'm still working through some of the feedback, namely improving the API documentation in the header and adding some comments in a few places.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2734104335",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 16840341856,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAPrwzlg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16840341856",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T17:19:11Z"
    },
    {
      "event": "subscribed",
      "id": 16840341896,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAPrwzmI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/16840341896",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T17:19:11Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574947042",
      "pull_request_review_id": 2015096769,
      "id": 1574947042,
      "node_id": "PRRC_kwDOAP4Jqs5d38ji",
      "diff_hunk": "@@ -433,4 +433,137 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    combined = (int)public_data->data[0];\n+    {\n+        unsigned char input_hash[32];\n+        unsigned char *input_hash_ptr;\n+        if (combined) {\n+            input_hash_ptr = NULL;\n+        } else {\n+            memset(input_hash, 0, 32);\n+            input_hash_ptr = input_hash;\n+        }\n+        if (!secp256k1_silentpayments_recipient_public_data_load(ctx, &A_sum, input_hash_ptr, public_data)) {\n+            return 0;\n+        }\n+        secp256k1_pubkey_load(ctx, &receiver_spend_pubkey_ge, receiver_spend_pubkey);\n+        if (!secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, scan_key, &A_sum, input_hash_ptr)) {\n+            return 0;\n+        }\n+    }\n+\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = receiver_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+            return 0;\n+        }\n+\n+        /* If the calculated output matches the one from the tx, we have a direct match and can\n+         * return without labels calculation (one of the two would result in point of infinity) */\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        found = 0;\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                found_outputs[n_found]->output = *tx_outputs[i];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 65,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The `found_with_label` boolean needs to be set here, to not leave it uninitialized (I guess we don't want to rely on the user zeroing the `_found_output` struct instances before scanning):\r\n```suggestion\r\n                found_outputs[n_found]->output = *tx_outputs[i];\r\n                found_outputs[n_found]->found_with_label = 0;\r\n```\r\nShould we also set `label` here to something invalid for consistency, e.g. all-zero-bytes, even though the user wouldn't evaluate it anyways? Not sure what the best practices are in cases like this and if returning uninitialized data is acceptable.\r\n\r\nMight be nice to update the tests to also check for the `found_with_label` flag. ",
      "created_at": "2024-04-22T15:21:20Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1574947042",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574947042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 497,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574962225",
      "pull_request_review_id": 2015096769,
      "id": 1574962225,
      "node_id": "PRRC_kwDOAP4Jqs5d4AQx",
      "diff_hunk": "@@ -222,6 +222,57 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *           public_tweak_data: pointer to the input public key sum (optionaly, with the `input_hash`",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 22,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *                 public_data: pointer to the input public key sum (optionaly, with the `input_hash`\r\n```",
      "created_at": "2024-04-22T15:30:04Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1574962225",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574962225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574963125",
      "pull_request_review_id": 2015096769,
      "id": 1574963125,
      "node_id": "PRRC_kwDOAP4Jqs5d4Ae1",
      "diff_hunk": "@@ -222,6 +222,57 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *           public_tweak_data: pointer to the input public key sum (optionaly, with the `input_hash`\n+ *                              multiplied in, see `_recipient_compute_public_data`).\n+ *      recipient_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                  input_hash: pointer to the input_hash. MUST be NULL if the input_hash is already\n+ *                              multipled into the input public key sum (see `_recipient_compute_public_data`)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 26,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n```\r\n(parameter doesn't exist anymore)",
      "created_at": "2024-04-22T15:30:22Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1574963125",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574963125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 246,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574976504",
      "pull_request_review_id": 2015096769,
      "id": 1574976504,
      "node_id": "PRRC_kwDOAP4Jqs5d4Dv4",
      "diff_hunk": "@@ -328,4 +328,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 34,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "4fb8716f4f1f6b10757f53024eb22263829fe888",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Not sure why I chose the constant-time point addition routines back then in #1471 (probably was inspired by `_ec_pubkey_combine`), but I strongly suspect that they are not needed for summing up public data:\r\n```suggestion\r\n        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\r\n```\r\n(also for second summing loop a few lines below)",
      "created_at": "2024-04-22T15:39:48Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1574976504",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574976504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574990516",
      "pull_request_review_id": 2015096769,
      "id": 1574990516,
      "node_id": "PRRC_kwDOAP4Jqs5d4HK0",
      "diff_hunk": "@@ -0,0 +1,264 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../../src/modules/silentpayments/vectors.h\"\n+#include \"../../../examples/examples_util.h\"\n+#include \"assert.h\"\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[10];\n+};\n+struct labels_cache labels_cache;\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j;\n+    int match;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        int ret = secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]);\n+        assert(ret);\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    ));\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[i]));\n+        match = 0;\n+        /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+        for (j = 0; j < test->num_recipient_outputs; j++) {\n+            if (secp256k1_memcmp_var(created_output, test->recipient_outputs[j], 32) == 0) {\n+                match = 1;\n+                break;\n+            }\n+        }\n+        CHECK(match);\n+    }\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey receiver_scan_pubkey;\n+    secp256k1_pubkey receiver_spend_pubkey;\n+    size_t i,j;\n+    int match;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));\n+            plain_pubkeys[i] = &plain_pubkeys_objs[i];\n+        }\n+        for (i = 0; i < test->num_taproot_inputs; i++) {\n+            CHECK(secp256k1_xonly_pubkey_parse(CTX, &xonly_pubkeys_objs[i], test->xonly_pubkeys[i]));\n+            xonly_pubkeys[i] = &xonly_pubkeys_objs[i];\n+        }\n+        CHECK(secp256k1_silentpayments_recipient_public_data_create(CTX, &public_data,\n+            test->outpoint_smallest,\n+            test->num_taproot_inputs > 0 ? xonly_pubkeys : NULL, test->num_taproot_inputs,\n+            test->num_plain_inputs > 0 ? plain_pubkeys : NULL, test->num_plain_inputs\n+        ));\n+    }\n+    /* prepare the outputs */\n+    {\n+        for (i = 0; i < test->num_to_scan_outputs; i++) {\n+            CHECK(secp256k1_xonly_pubkey_parse(CTX, &tx_output_objs[i], test->to_scan_outputs[i]));\n+            tx_outputs[i] = &tx_output_objs[i];\n+        }\n+        for (i = 0; i < test->num_found_output_pubkeys; i++) {\n+            found_outputs[i] = &found_output_objs[i];\n+        }\n+    }\n+\n+    /* scan / spend pubkeys are not in the given data of the receiver part, so let's compute them */\n+    CHECK(secp256k1_ec_pubkey_create(CTX, &receiver_scan_pubkey, test->scan_seckey));\n+    CHECK(secp256k1_ec_pubkey_create(CTX, &receiver_spend_pubkey, test->spend_seckey));\n+\n+    /* create labels cache */\n+    labels_cache.ctx = CTX;\n+    labels_cache.entries_used = 0;\n+    for (i = 0; i < test->num_labels; i++) {\n+        unsigned int m = test->label_integers[i];\n+        struct label_cache_entry *cache_entry = &labels_cache.entries[labels_cache.entries_used];\n+        CHECK(secp256k1_silentpayments_recipient_create_label_tweak(CTX, &cache_entry->label, cache_entry->label_tweak, test->scan_seckey, m));\n+        labels_cache.entries_used++;\n+    }\n+    CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX,\n+        found_outputs, &n_found,\n+        tx_outputs, test->num_to_scan_outputs,\n+        test->scan_seckey,\n+        &public_data,\n+        &receiver_spend_pubkey,\n+        label_lookup, &labels_cache)\n+    );\n+    for (i = 0; i < n_found; i++) {\n+        unsigned char full_seckey[32];\n+        secp256k1_keypair keypair;\n+        unsigned char signature[64];\n+        const unsigned char msg32[32] = /* sha256(\"message\") */\n+            {0xab,0x53,0x0a,0x13,0xe4,0x59,0x14,0x98,0x2b,0x79,0xf9,0xb7,0xe3,0xfb,0xa9,0x94,\n+             0xcf,0xd1,0xf3,0xfb,0x22,0xf7,0x1c,0xea,0x1a,0xfb,0xf0,0x2b,0x46,0x0c,0x6d,0x1d};\n+        const unsigned char aux32[32] = /* sha256(\"random auxiliary data\") */\n+            {0x0b,0x3f,0xdd,0xfd,0x67,0xbf,0x76,0xae,0x76,0x39,0xee,0x73,0x5b,0x70,0xff,0x15,\n+             0x83,0xfd,0x92,0x48,0xc0,0x57,0xd2,0x86,0x07,0xa2,0x15,0xf4,0x0b,0x0a,0x3e,0xcc};\n+        memcpy(&full_seckey, test->spend_seckey, 32);\n+        CHECK(secp256k1_ec_seckey_tweak_add(CTX, full_seckey, found_outputs[i]->tweak));\n+        CHECK(secp256k1_keypair_create(CTX, &keypair, full_seckey));\n+        CHECK(secp256k1_schnorrsig_sign32(CTX, signature, msg32, &keypair, aux32));\n+        memcpy(found_signatures[i], signature, 64);\n+    }\n+\n+    /* compare expected and scanned outputs (including calculated seckey tweaks and signatures) */\n+    for (i = 0; i < n_found; i++) {\n+        CHECK(secp256k1_xonly_pubkey_serialize(CTX, found_output, &found_outputs[i]->output));\n+        match = 0;\n+        for (j = 0; j < test->num_found_output_pubkeys; j++) {\n+            if (secp256k1_memcmp_var(&found_output, test->found_output_pubkeys[j], 32) == 0) {\n+                match = 1;\n+                CHECK(secp256k1_memcmp_var(found_outputs[i]->tweak, test->found_seckey_tweaks[j], 32) == 0);\n+                CHECK(secp256k1_memcmp_var(found_signatures[i], test->found_signatures[j], 64) == 0);\n+                break;\n+            }\n+        }\n+        CHECK(match);\n+    }\n+    CHECK(n_found == test->num_found_output_pubkeys);\n+    /* Scan as a light client\n+     * it is not recommended to use labels as a light client so here we are only\n+     * running this on tests that do not involve labels. Primarily, this test is to\n+     * ensure that _recipient_created_shared_secret and _create_shared_secret are the same\n+     */\n+    if (test->num_labels == 0) {\n+        CHECK(secp256k1_silentpayments_recipient_public_data_serialize(CTX, light_client_data, &public_data));\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(CTX, &public_data_index, light_client_data));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(CTX, shared_secret_lightclient, test->scan_seckey, &public_data_index));\n+        n_found = 0;\n+        {\n+            int found = 0;\n+            size_t k = 0;\n+            secp256k1_xonly_pubkey potential_output;\n+            unsigned char xonly_print[32];\n+\n+            while(1) {\n+\n+                CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(CTX,\n+                    &potential_output,\n+                    shared_secret_lightclient,\n+                    &receiver_spend_pubkey,\n+                    k\n+                ));\n+                /* At this point, we check that the utxo exists with a light client protocol.\n+                 * For this example, we'll just iterate through the list of pubkeys */\n+                found = 0;\n+                secp256k1_xonly_pubkey_serialize(CTX, xonly_print, &potential_output);\n+                printf(\"what we generated :\");\n+                print_hex(xonly_print, 32);",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 216,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "85946762a59c39dfe21ac899359bcac443ab8d20",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Tests are usually silent, so this should be removed (or maybe put in some verbose/debug #if block, though I'm not sure if this is considered a good idea due to increased maintenance burden):\r\n```suggestion\r\n```",
      "created_at": "2024-04-22T15:49:34Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1574990516",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574990516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 215,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575010116",
      "pull_request_review_id": 2015096769,
      "id": 1575010116,
      "node_id": "PRRC_kwDOAP4Jqs5d4L9E",
      "diff_hunk": "@@ -433,4 +433,137 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    combined = (int)public_data->data[0];\n+    {\n+        unsigned char input_hash[32];\n+        unsigned char *input_hash_ptr;\n+        if (combined) {\n+            input_hash_ptr = NULL;\n+        } else {\n+            memset(input_hash, 0, 32);\n+            input_hash_ptr = input_hash;\n+        }\n+        if (!secp256k1_silentpayments_recipient_public_data_load(ctx, &A_sum, input_hash_ptr, public_data)) {\n+            return 0;\n+        }\n+        secp256k1_pubkey_load(ctx, &receiver_spend_pubkey_ge, receiver_spend_pubkey);\n+        if (!secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, scan_key, &A_sum, input_hash_ptr)) {\n+            return 0;\n+        }\n+    }\n+\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = receiver_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+            return 0;\n+        }\n+\n+        /* If the calculated output matches the one from the tx, we have a direct match and can\n+         * return without labels calculation (one of the two would result in point of infinity) */\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        found = 0;\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                found_outputs[n_found]->output = *tx_outputs[i];\n+                secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+                found = 1;\n+                n_found++;\n+                k++;\n+                break;\n+            }\n+\n+            /* If desired, also calculate label candidates */\n+            if (label_lookup != NULL) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 74,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The handling of the first and second scan label candidate look quite similar (both their calculation and the setting of the found output / advancing the counters if the label lookup in the cache was successful), seems like quite a bit of code could be duplicated here.",
      "created_at": "2024-04-22T16:01:32Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1575010116",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575010116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 505,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 573,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575023482",
      "pull_request_review_id": 2015096769,
      "id": 1575023482,
      "node_id": "PRRC_kwDOAP4Jqs5d4PN6",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *   Args:                 ctx: pointer to a context object\n+ *    Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys, one per recipient.\n+ *                              The order of outputs here matches the original ordering of the\n+ *                              recipients array.\n+ *     In:          recipients: pointer to an array of pointers to silent payment recipients,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 23,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Considering that the array is sorted in-place, is this in the category \"In/Out\"?",
      "created_at": "2024-04-22T16:10:37Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1575023482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575023482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575037779",
      "pull_request_review_id": 2015096769,
      "id": 1575037779,
      "node_id": "PRRC_kwDOAP4Jqs5d4StT",
      "diff_hunk": "@@ -173,4 +173,94 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(plain_seckeys == NULL || n_plain_seckeys >= 1);\n+    ARG_CHECK(taproot_seckeys == NULL || n_taproot_seckeys >= 1);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    ARG_CHECK((n_plain_seckeys + n_taproot_seckeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        int ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+        VERIFY_CHECK(!secp256k1_scalar_is_zero(&a_sum_scalar));\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        int ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+        /* declassify addend_point to allow using it as a branch point (this is fine because addend_point is not a secret) */\n+        secp256k1_declassify(ctx, &addend_point, sizeof(addend_point));\n+        secp256k1_fe_normalize_var(&addend_point.y);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 56,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Now that we get the point from a keypair instance, I think these lines are not needed anymore (see e.g. [a similar secret key negation code part in the schnorrsig module](https://github.com/bitcoin-core/secp256k1/blob/da515074e3ebc8abc85a4fff3a31d7694ecf897b/src/modules/schnorrsig/main_impl.h#L154-L160)):\r\n```suggestion\r\n```",
      "created_at": "2024-04-22T16:22:16Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1575037779",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575037779"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 226,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575039817",
      "pull_request_review_id": 2015096769,
      "id": 1575039817,
      "node_id": "PRRC_kwDOAP4Jqs5d4TNJ",
      "diff_hunk": "@@ -173,4 +173,94 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(plain_seckeys == NULL || n_plain_seckeys >= 1);\n+    ARG_CHECK(taproot_seckeys == NULL || n_taproot_seckeys >= 1);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    ARG_CHECK((n_plain_seckeys + n_taproot_seckeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        int ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+        VERIFY_CHECK(!secp256k1_scalar_is_zero(&a_sum_scalar));\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        int ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 52,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should we return an error (i.e. `return 0`) here if the user passes in an invalid keypair?",
      "created_at": "2024-04-22T16:24:01Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1575039817",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575039817"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 223,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577437389",
      "pull_request_review_id": 2019121206,
      "id": 1577437389,
      "node_id": "PRRC_kwDOAP4Jqs5eBcjN",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *   Args:                 ctx: pointer to a context object\n+ *    Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys, one per recipient.\n+ *                              The order of outputs here matches the original ordering of the\n+ *                              recipients array.\n+ *     In:          recipients: pointer to an array of pointers to silent payment recipients,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 23,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": 1575023482,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good question. I would argue no, since the caller is passing the array in and then never using it again. The fact that the array is sorted in place is irrelevant to the caller since they shouldn't be reading those values again, anyways. But maybe there is a more strict definition of In/Out, that if the function can modify the parameter it is an Out param?",
      "created_at": "2024-04-24T07:46:38Z",
      "updated_at": "2024-04-24T07:46:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577437389",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577437389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577545322",
      "pull_request_review_id": 2019306258,
      "id": 1577545322,
      "node_id": "PRRC_kwDOAP4Jqs5eB25q",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *   Args:                 ctx: pointer to a context object\n+ *    Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys, one per recipient.\n+ *                              The order of outputs here matches the original ordering of the\n+ *                              recipients array.\n+ *     In:          recipients: pointer to an array of pointers to silent payment recipients,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 23,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": 1575023482,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think there's a definition for this case and I don't remember a precedent. \"In\" seems fine to me if the modified argument is not supposed to be read again. The doc also mentions already that the array is modified (\"The recipient array will be sorted in place\").",
      "created_at": "2024-04-24T08:59:58Z",
      "updated_at": "2024-04-24T08:59:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577545322",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577545322"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577601080",
      "pull_request_review_id": 2019395443,
      "id": 1577601080,
      "node_id": "PRRC_kwDOAP4Jqs5eCEg4",
      "diff_hunk": "@@ -173,4 +173,94 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(plain_seckeys == NULL || n_plain_seckeys >= 1);\n+    ARG_CHECK(taproot_seckeys == NULL || n_taproot_seckeys >= 1);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    ARG_CHECK((n_plain_seckeys + n_taproot_seckeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        int ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+        VERIFY_CHECK(!secp256k1_scalar_is_zero(&a_sum_scalar));\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        int ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 52,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": 1575039817,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Replaced both instances of `VERIFY_CHECK` in this function with `return 0;`.",
      "created_at": "2024-04-24T09:40:05Z",
      "updated_at": "2024-04-24T09:40:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577601080",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577601080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 223,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577601481",
      "pull_request_review_id": 2019396053,
      "id": 1577601481,
      "node_id": "PRRC_kwDOAP4Jqs5eCEnJ",
      "diff_hunk": "@@ -173,4 +173,94 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(plain_seckeys == NULL || n_plain_seckeys >= 1);\n+    ARG_CHECK(taproot_seckeys == NULL || n_taproot_seckeys >= 1);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    ARG_CHECK((n_plain_seckeys + n_taproot_seckeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        int ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+        VERIFY_CHECK(!secp256k1_scalar_is_zero(&a_sum_scalar));\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        int ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+        /* declassify addend_point to allow using it as a branch point (this is fine because addend_point is not a secret) */\n+        secp256k1_declassify(ctx, &addend_point, sizeof(addend_point));\n+        secp256k1_fe_normalize_var(&addend_point.y);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 56,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": 1575037779,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed.",
      "created_at": "2024-04-24T09:40:20Z",
      "updated_at": "2024-04-24T09:40:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577601481",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577601481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 226,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577607223",
      "pull_request_review_id": 2019405342,
      "id": 1577607223,
      "node_id": "PRRC_kwDOAP4Jqs5eCGA3",
      "diff_hunk": "@@ -433,4 +433,137 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    combined = (int)public_data->data[0];\n+    {\n+        unsigned char input_hash[32];\n+        unsigned char *input_hash_ptr;\n+        if (combined) {\n+            input_hash_ptr = NULL;\n+        } else {\n+            memset(input_hash, 0, 32);\n+            input_hash_ptr = input_hash;\n+        }\n+        if (!secp256k1_silentpayments_recipient_public_data_load(ctx, &A_sum, input_hash_ptr, public_data)) {\n+            return 0;\n+        }\n+        secp256k1_pubkey_load(ctx, &receiver_spend_pubkey_ge, receiver_spend_pubkey);\n+        if (!secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, scan_key, &A_sum, input_hash_ptr)) {\n+            return 0;\n+        }\n+    }\n+\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = receiver_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+            return 0;\n+        }\n+\n+        /* If the calculated output matches the one from the tx, we have a direct match and can\n+         * return without labels calculation (one of the two would result in point of infinity) */\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        found = 0;\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                found_outputs[n_found]->output = *tx_outputs[i];\n+                secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+                found = 1;\n+                n_found++;\n+                k++;\n+                break;\n+            }\n+\n+            /* If desired, also calculate label candidates */\n+            if (label_lookup != NULL) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 74,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": 1575010116,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree! I'm working on a commit now to improve this section and also minimize the conversions between `pubkey -> ge > gej`. Specifically, there was a [comment from Llyod](https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8?permalink_comment_id=4125475#gistcomment-4125475) on the original gist that mentions being able to test equality with `jacobian == affine`, which could save us conversions from `gej` to `ge`. I'm going to try and incorporate that feedback and remove some of the repeated code in a follow up commit.",
      "created_at": "2024-04-24T09:44:39Z",
      "updated_at": "2024-04-24T09:44:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577607223",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577607223"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 505,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 573,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577608530",
      "pull_request_review_id": 2019407393,
      "id": 1577608530,
      "node_id": "PRRC_kwDOAP4Jqs5eCGVS",
      "diff_hunk": "@@ -0,0 +1,264 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../../src/modules/silentpayments/vectors.h\"\n+#include \"../../../examples/examples_util.h\"\n+#include \"assert.h\"\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[10];\n+};\n+struct labels_cache labels_cache;\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j;\n+    int match;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        int ret = secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]);\n+        assert(ret);\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    ));\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[i]));\n+        match = 0;\n+        /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+        for (j = 0; j < test->num_recipient_outputs; j++) {\n+            if (secp256k1_memcmp_var(created_output, test->recipient_outputs[j], 32) == 0) {\n+                match = 1;\n+                break;\n+            }\n+        }\n+        CHECK(match);\n+    }\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey receiver_scan_pubkey;\n+    secp256k1_pubkey receiver_spend_pubkey;\n+    size_t i,j;\n+    int match;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));\n+            plain_pubkeys[i] = &plain_pubkeys_objs[i];\n+        }\n+        for (i = 0; i < test->num_taproot_inputs; i++) {\n+            CHECK(secp256k1_xonly_pubkey_parse(CTX, &xonly_pubkeys_objs[i], test->xonly_pubkeys[i]));\n+            xonly_pubkeys[i] = &xonly_pubkeys_objs[i];\n+        }\n+        CHECK(secp256k1_silentpayments_recipient_public_data_create(CTX, &public_data,\n+            test->outpoint_smallest,\n+            test->num_taproot_inputs > 0 ? xonly_pubkeys : NULL, test->num_taproot_inputs,\n+            test->num_plain_inputs > 0 ? plain_pubkeys : NULL, test->num_plain_inputs\n+        ));\n+    }\n+    /* prepare the outputs */\n+    {\n+        for (i = 0; i < test->num_to_scan_outputs; i++) {\n+            CHECK(secp256k1_xonly_pubkey_parse(CTX, &tx_output_objs[i], test->to_scan_outputs[i]));\n+            tx_outputs[i] = &tx_output_objs[i];\n+        }\n+        for (i = 0; i < test->num_found_output_pubkeys; i++) {\n+            found_outputs[i] = &found_output_objs[i];\n+        }\n+    }\n+\n+    /* scan / spend pubkeys are not in the given data of the receiver part, so let's compute them */\n+    CHECK(secp256k1_ec_pubkey_create(CTX, &receiver_scan_pubkey, test->scan_seckey));\n+    CHECK(secp256k1_ec_pubkey_create(CTX, &receiver_spend_pubkey, test->spend_seckey));\n+\n+    /* create labels cache */\n+    labels_cache.ctx = CTX;\n+    labels_cache.entries_used = 0;\n+    for (i = 0; i < test->num_labels; i++) {\n+        unsigned int m = test->label_integers[i];\n+        struct label_cache_entry *cache_entry = &labels_cache.entries[labels_cache.entries_used];\n+        CHECK(secp256k1_silentpayments_recipient_create_label_tweak(CTX, &cache_entry->label, cache_entry->label_tweak, test->scan_seckey, m));\n+        labels_cache.entries_used++;\n+    }\n+    CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX,\n+        found_outputs, &n_found,\n+        tx_outputs, test->num_to_scan_outputs,\n+        test->scan_seckey,\n+        &public_data,\n+        &receiver_spend_pubkey,\n+        label_lookup, &labels_cache)\n+    );\n+    for (i = 0; i < n_found; i++) {\n+        unsigned char full_seckey[32];\n+        secp256k1_keypair keypair;\n+        unsigned char signature[64];\n+        const unsigned char msg32[32] = /* sha256(\"message\") */\n+            {0xab,0x53,0x0a,0x13,0xe4,0x59,0x14,0x98,0x2b,0x79,0xf9,0xb7,0xe3,0xfb,0xa9,0x94,\n+             0xcf,0xd1,0xf3,0xfb,0x22,0xf7,0x1c,0xea,0x1a,0xfb,0xf0,0x2b,0x46,0x0c,0x6d,0x1d};\n+        const unsigned char aux32[32] = /* sha256(\"random auxiliary data\") */\n+            {0x0b,0x3f,0xdd,0xfd,0x67,0xbf,0x76,0xae,0x76,0x39,0xee,0x73,0x5b,0x70,0xff,0x15,\n+             0x83,0xfd,0x92,0x48,0xc0,0x57,0xd2,0x86,0x07,0xa2,0x15,0xf4,0x0b,0x0a,0x3e,0xcc};\n+        memcpy(&full_seckey, test->spend_seckey, 32);\n+        CHECK(secp256k1_ec_seckey_tweak_add(CTX, full_seckey, found_outputs[i]->tweak));\n+        CHECK(secp256k1_keypair_create(CTX, &keypair, full_seckey));\n+        CHECK(secp256k1_schnorrsig_sign32(CTX, signature, msg32, &keypair, aux32));\n+        memcpy(found_signatures[i], signature, 64);\n+    }\n+\n+    /* compare expected and scanned outputs (including calculated seckey tweaks and signatures) */\n+    for (i = 0; i < n_found; i++) {\n+        CHECK(secp256k1_xonly_pubkey_serialize(CTX, found_output, &found_outputs[i]->output));\n+        match = 0;\n+        for (j = 0; j < test->num_found_output_pubkeys; j++) {\n+            if (secp256k1_memcmp_var(&found_output, test->found_output_pubkeys[j], 32) == 0) {\n+                match = 1;\n+                CHECK(secp256k1_memcmp_var(found_outputs[i]->tweak, test->found_seckey_tweaks[j], 32) == 0);\n+                CHECK(secp256k1_memcmp_var(found_signatures[i], test->found_signatures[j], 64) == 0);\n+                break;\n+            }\n+        }\n+        CHECK(match);\n+    }\n+    CHECK(n_found == test->num_found_output_pubkeys);\n+    /* Scan as a light client\n+     * it is not recommended to use labels as a light client so here we are only\n+     * running this on tests that do not involve labels. Primarily, this test is to\n+     * ensure that _recipient_created_shared_secret and _create_shared_secret are the same\n+     */\n+    if (test->num_labels == 0) {\n+        CHECK(secp256k1_silentpayments_recipient_public_data_serialize(CTX, light_client_data, &public_data));\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(CTX, &public_data_index, light_client_data));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(CTX, shared_secret_lightclient, test->scan_seckey, &public_data_index));\n+        n_found = 0;\n+        {\n+            int found = 0;\n+            size_t k = 0;\n+            secp256k1_xonly_pubkey potential_output;\n+            unsigned char xonly_print[32];\n+\n+            while(1) {\n+\n+                CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(CTX,\n+                    &potential_output,\n+                    shared_secret_lightclient,\n+                    &receiver_spend_pubkey,\n+                    k\n+                ));\n+                /* At this point, we check that the utxo exists with a light client protocol.\n+                 * For this example, we'll just iterate through the list of pubkeys */\n+                found = 0;\n+                secp256k1_xonly_pubkey_serialize(CTX, xonly_print, &potential_output);\n+                printf(\"what we generated :\");\n+                print_hex(xonly_print, 32);",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 216,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "85946762a59c39dfe21ac899359bcac443ab8d20",
      "in_reply_to_id": 1574990516,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": ":doh: those sneaked in from my debugging, good catch!",
      "created_at": "2024-04-24T09:45:40Z",
      "updated_at": "2024-04-24T09:45:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577608530",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577608530"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 215,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577608898",
      "pull_request_review_id": 2019407957,
      "id": 1577608898,
      "node_id": "PRRC_kwDOAP4Jqs5eCGbC",
      "diff_hunk": "@@ -328,4 +328,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 34,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "4fb8716f4f1f6b10757f53024eb22263829fe888",
      "in_reply_to_id": 1574976504,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-04-24T09:45:56Z",
      "updated_at": "2024-04-24T09:45:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577608898",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577608898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577609153",
      "pull_request_review_id": 2019408344,
      "id": 1577609153,
      "node_id": "PRRC_kwDOAP4Jqs5eCGfB",
      "diff_hunk": "@@ -222,6 +222,57 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *           public_tweak_data: pointer to the input public key sum (optionaly, with the `input_hash`",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 22,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": 1574962225,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-04-24T09:46:07Z",
      "updated_at": "2024-04-24T09:46:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577609153",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577609153"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577609295",
      "pull_request_review_id": 2019408535,
      "id": 1577609295,
      "node_id": "PRRC_kwDOAP4Jqs5eCGhP",
      "diff_hunk": "@@ -222,6 +222,57 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *           public_tweak_data: pointer to the input public key sum (optionaly, with the `input_hash`\n+ *                              multiplied in, see `_recipient_compute_public_data`).\n+ *      recipient_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                  input_hash: pointer to the input_hash. MUST be NULL if the input_hash is already\n+ *                              multipled into the input public key sum (see `_recipient_compute_public_data`)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 26,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": 1574963125,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-04-24T09:46:12Z",
      "updated_at": "2024-04-24T09:46:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577609295",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577609295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 246,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577610073",
      "pull_request_review_id": 2019409884,
      "id": 1577610073,
      "node_id": "PRRC_kwDOAP4Jqs5eCGtZ",
      "diff_hunk": "@@ -433,4 +433,137 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    combined = (int)public_data->data[0];\n+    {\n+        unsigned char input_hash[32];\n+        unsigned char *input_hash_ptr;\n+        if (combined) {\n+            input_hash_ptr = NULL;\n+        } else {\n+            memset(input_hash, 0, 32);\n+            input_hash_ptr = input_hash;\n+        }\n+        if (!secp256k1_silentpayments_recipient_public_data_load(ctx, &A_sum, input_hash_ptr, public_data)) {\n+            return 0;\n+        }\n+        secp256k1_pubkey_load(ctx, &receiver_spend_pubkey_ge, receiver_spend_pubkey);\n+        if (!secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, scan_key, &A_sum, input_hash_ptr)) {\n+            return 0;\n+        }\n+    }\n+\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = receiver_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+            return 0;\n+        }\n+\n+        /* If the calculated output matches the one from the tx, we have a direct match and can\n+         * return without labels calculation (one of the two would result in point of infinity) */\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        found = 0;\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                found_outputs[n_found]->output = *tx_outputs[i];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 65,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": 1574947042,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated and for now am just setting the label with the output when the output is found without a label, but would be better if we have a \"canonical\" invalid pubkey I can use.",
      "created_at": "2024-04-24T09:46:51Z",
      "updated_at": "2024-04-24T09:48:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577610073",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577610073"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 497,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577623058",
      "pull_request_review_id": 2019430407,
      "id": 1577623058,
      "node_id": "PRRC_kwDOAP4Jqs5eCJ4S",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *   Args:                 ctx: pointer to a context object\n+ *    Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys, one per recipient.\n+ *                              The order of outputs here matches the original ordering of the\n+ *                              recipients array.\n+ *     In:          recipients: pointer to an array of pointers to silent payment recipients,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 23,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": 1575023482,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Going to leave it as \"In\" for now. I think it makes it more clear to the caller that they are supposed to read the `recipients` array after the function call.",
      "created_at": "2024-04-24T09:56:37Z",
      "updated_at": "2024-04-24T09:56:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577623058",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577623058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992204",
      "pull_request_review_id": 2026864465,
      "id": 1581992204,
      "node_id": "PRRC_kwDOAP4Jqs5eS0kM",
      "diff_hunk": "@@ -9,8 +9,36 @@\n #include \"../../../include/secp256k1.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(\n+        ((secp256k1_ec_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 18,
      "original_position": 11,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "97220f7b29b77677e66a527ec933b022ceb2cceb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`pk1`/`pk2` are addresses for _silentpayments_recipient instances, so involving double-pointers here doesn't seem to be necessary:\r\n```suggestion\r\n        &((const secp256k1_silentpayments_recipient *)pk1)->scan_pubkey,\r\n        &((const secp256k1_silentpayments_recipient *)pk2)->scan_pubkey\r\n```",
      "created_at": "2024-04-28T01:18:12Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581992204",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": 17,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": 18,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992289",
      "pull_request_review_id": 2026864465,
      "id": 1581992289,
      "node_id": "PRRC_kwDOAP4Jqs5eS0lh",
      "diff_hunk": "@@ -9,8 +9,36 @@\n #include \"../../../include/secp256k1.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(\n+        ((secp256k1_ec_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 16,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "97220f7b29b77677e66a527ec933b022ceb2cceb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could be static, since it's not part of the public API",
      "created_at": "2024-04-28T01:18:51Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581992289",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992289"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992522",
      "pull_request_review_id": 2026864465,
      "id": 1581992522,
      "node_id": "PRRC_kwDOAP4Jqs5eS0pK",
      "diff_hunk": "@@ -173,4 +173,90 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 186,
      "original_position": 26,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "could also ARG_CHECK for n_recipients here:\r\n```suggestion\r\n    ARG_CHECK(recipients != NULL);\r\n    ARG_CHECK(n_recipients >= 1);\r\n```",
      "created_at": "2024-04-28T01:21:29Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581992522",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992522"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 186,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992596",
      "pull_request_review_id": 2026864465,
      "id": 1581992596,
      "node_id": "PRRC_kwDOAP4Jqs5eS0qU",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 16,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "typo\r\n```suggestion\r\n * pairs, depending on whether the seckeys correspond to x-only outputs or not.\r\n```",
      "created_at": "2024-04-28T01:22:20Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581992596",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992596"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992633",
      "pull_request_review_id": 2026864465,
      "id": 1581992633,
      "node_id": "PRRC_kwDOAP4Jqs5eS0q5",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 18,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\r\n```",
      "created_at": "2024-04-28T01:23:07Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581992633",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993053",
      "pull_request_review_id": 2026864465,
      "id": 1581993053,
      "node_id": "PRRC_kwDOAP4Jqs5eS0xd",
      "diff_hunk": "@@ -93,6 +93,51 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan private key b_scan and a label integer m, calculate\n+ *  the corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *  label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           label_tweak: pointer to the resulting label tweak\n+ *   In:  receiver_scan_seckey: pointer to the receiver's scan private key\n+ *                           m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *receiver_scan_seckey,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate\n+ *  the corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address, consisting\n+ *  of the serialized and concatenated scan public key and (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out: l_addr_spend_pubkey33: pointer to the resulting labelled spend public key\n+ *   In: receiver_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                       label: pointer to the the receiver's label\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 44,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "aeef18499580e576f2078b20936842b899b05bd3",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: should use either `labeled` or `labelled` consistently (both seem to be correct english) for function name vs parameter",
      "created_at": "2024-04-28T01:27:04Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993053",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 134,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993106",
      "pull_request_review_id": 2026864465,
      "id": 1581993106,
      "node_id": "PRRC_kwDOAP4Jqs5eS0yS",
      "diff_hunk": "@@ -93,6 +93,51 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan private key b_scan and a label integer m, calculate\n+ *  the corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *  label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           label_tweak: pointer to the resulting label tweak\n+ *   In:  receiver_scan_seckey: pointer to the receiver's scan private key\n+ *                           m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *receiver_scan_seckey,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate\n+ *  the corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address, consisting\n+ *  of the serialized and concatenated scan public key and (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out: l_addr_spend_pubkey33: pointer to the resulting labelled spend public key",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 38,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "aeef18499580e576f2078b20936842b899b05bd3",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "the out-param description for `label` is missing",
      "created_at": "2024-04-28T01:27:36Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993106",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993106"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993315",
      "pull_request_review_id": 2026864465,
      "id": 1581993315,
      "node_id": "PRRC_kwDOAP4Jqs5eS01j",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).\n+ *\n+ *  Args:        ctx: pointer to a context object.\n+ *  Out: public_data: pointer to a silentpayments_public_data object. If 1 is returned, it is set to a\n+ *                    parsed version of input33.\n+ *  In:      input33: pointer to a serialized silentpayments_public_data.\n+ */\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:       ctx: pointer to a context object.\n+ *  Out:   output33: pointer to a 32-byte array to place the serialized key in.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 38,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  Out:   output33: pointer to a 33-byte array to place the serialized silentpayments_public_data in.\r\n```",
      "created_at": "2024-04-28T01:30:42Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993393",
      "pull_request_review_id": 2026864465,
      "id": 1581993393,
      "node_id": "PRRC_kwDOAP4Jqs5eS02x",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 19,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *           0 if the sequence is invalid (e.g. does not represent a valid public key).\r\n```",
      "created_at": "2024-04-28T01:31:17Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993393",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993506",
      "pull_request_review_id": 2026864465,
      "id": 1581993506,
      "node_id": "PRRC_kwDOAP4Jqs5eS04i",
      "diff_hunk": "@@ -324,4 +324,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 38,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "can use non-constant-time ge adding for the second loop here as well:\r\n```suggestion\r\n        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\r\n```",
      "created_at": "2024-04-28T01:32:12Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993506",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993573",
      "pull_request_review_id": 2026864465,
      "id": 1581993573,
      "node_id": "PRRC_kwDOAP4Jqs5eS05l",
      "diff_hunk": "@@ -324,4 +324,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);\n+    }\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        /* TODO: do we need a special error return code for this case? */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_load(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 56,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: not used in public API, could be made static",
      "created_at": "2024-04-28T01:33:00Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993573",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 379,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993849",
      "pull_request_review_id": 2026864465,
      "id": 1581993849,
      "node_id": "PRRC_kwDOAP4Jqs5eS095",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).\n+ *\n+ *  Args:        ctx: pointer to a context object.\n+ *  Out: public_data: pointer to a silentpayments_public_data object. If 1 is returned, it is set to a\n+ *                    parsed version of input33.\n+ *  In:      input33: pointer to a serialized silentpayments_public_data.\n+ */\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:       ctx: pointer to a context object.\n+ *  Out:   output33: pointer to a 32-byte array to place the serialized key in.\n+ *  In: public_data: pointer to an initialized silentpayments_public_data object.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute Silent Payment public data from input public keys and transaction inputs.\n+ *\n+ * Given a list of n public keys A_1...A_n (one for each silent payment\n+ * eligible input to spend) and a serialized outpoint_smallest, compute\n+ * the corresponding input public tweak data:\n+ *\n+ * A_sum = A_1 + A_2 + ... + A_n\n+ * input_hash = hash(outpoint_lowest || A_sum)\n+ *\n+ * The public keys have to be passed in via two different parameter pairs,\n+ * one for regular and one for x-only public keys, in order to avoid the need\n+ * of users converting to a common pubkey format before calling this function.\n+ * The resulting data is can be used for scanning on the recipient side, or stored\n+ * in an index for late use (e.g. wallet rescanning, vending data to light clients).\n+ *\n+ * If calling this function for scanning, the reciever must provide an output param\n+ * for the `input_hash`. If calling this function for simply aggregating the inputs\n+ * for later use, the caller can save the result with `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           public_data: pointer to public_data object containing the summed public key and\n+ *                              input_hash.\n+ *  In:    outpoint_smallest36: serialized smallest outpoint\n+ *               xonly_pubkeys: pointer to an array of pointers to taproot x-only\n+ *                              public keys (can be NULL if no taproot inputs are used)\n+ *             n_xonly_pubkeys: the number of taproot input public keys\n+ *               plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                              public keys (can be NULL if no non-taproot inputs are used)\n+ *             n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(",
      "path": "include/secp256k1_silentpayments.h",
      "position": 219,
      "original_position": 78,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could reorder that function to be above the other _public_data API functions, since that's the first one in the lifecycle of a `_public_data` instance.",
      "created_at": "2024-04-28T01:35:43Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993849",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 219,
      "original_line": 219,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993914",
      "pull_request_review_id": 2026864465,
      "id": 1581993914,
      "node_id": "PRRC_kwDOAP4Jqs5eS0-6",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 7,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  copied/moved. Created with `secp256k1_silentpayments_public_data_create`. Can be serialized as\r\n```",
      "created_at": "2024-04-28T01:36:52Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993914",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993914"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994092",
      "pull_request_review_id": 2026864465,
      "id": 1581994092,
      "node_id": "PRRC_kwDOAP4Jqs5eS1Bs",
      "diff_hunk": "@@ -222,6 +222,55 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *                 public_data: pointer to the input public key sum (optionaly, with the `input_hash`\n+ *                              multiplied in, see `_recipient_compute_public_data`).\n+ *      recipient_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                label_lookup: pointer to a callback function for looking up a label value. This fucntion\n+ *                              takes a label pubkey as an argument and returns a pointer to the label tweak\n+ *                              if the label exists, otherwise returns a nullptr (NULL if labels are not used)\n+ *               label_context: pointer to a label context object (NULL if labels are not used)\n+ */\n+\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const secp256k1_pubkey*, const void*);\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *scan_key,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 45,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "016c20d95f96a7cdbe2e36793c37fcb35532f5dd",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit, to match the spend key naming:\r\n```suggestion\r\n    const unsigned char *recipient_scan_seckey,\r\n```",
      "created_at": "2024-04-28T01:39:30Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581994092",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994092"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 266,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994368",
      "pull_request_review_id": 2026864465,
      "id": 1581994368,
      "node_id": "PRRC_kwDOAP4Jqs5eS1GA",
      "diff_hunk": "@@ -429,4 +429,139 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 519,
      "original_position": 27,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "016c20d95f96a7cdbe2e36793c37fcb35532f5dd",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "could add ARG_CHECKS for `n_found_outputs != NULL` and `n_tx_outputs >= 1` here",
      "created_at": "2024-04-28T01:40:57Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581994368",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994368"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 519,
      "original_line": 519,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994645",
      "pull_request_review_id": 2026864465,
      "id": 1581994645,
      "node_id": "PRRC_kwDOAP4Jqs5eS1KV",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: i think the else-brach can be removed (or at least, the `return 1;` in it); if keypair creation fails, we want to continue in the loop and try with another secret key",
      "created_at": "2024-04-28T01:44:35Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581994645",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994645"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588884794",
      "pull_request_review_id": 2037624531,
      "id": 1588884794,
      "node_id": "PRRC_kwDOAP4Jqs5etHU6",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": 1581994645,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-05-03T08:10:38Z",
      "updated_at": "2024-05-03T08:10:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588884794",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588884794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588885068",
      "pull_request_review_id": 2037624941,
      "id": 1588885068,
      "node_id": "PRRC_kwDOAP4Jqs5etHZM",
      "diff_hunk": "@@ -429,4 +429,139 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 519,
      "original_position": 27,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "016c20d95f96a7cdbe2e36793c37fcb35532f5dd",
      "in_reply_to_id": 1581994368,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added.",
      "created_at": "2024-05-03T08:10:53Z",
      "updated_at": "2024-05-03T08:10:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588885068",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588885068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 519,
      "original_line": 519,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886367",
      "pull_request_review_id": 2037627106,
      "id": 1588886367,
      "node_id": "PRRC_kwDOAP4Jqs5etHtf",
      "diff_hunk": "@@ -222,6 +222,55 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *                 public_data: pointer to the input public key sum (optionaly, with the `input_hash`\n+ *                              multiplied in, see `_recipient_compute_public_data`).\n+ *      recipient_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                label_lookup: pointer to a callback function for looking up a label value. This fucntion\n+ *                              takes a label pubkey as an argument and returns a pointer to the label tweak\n+ *                              if the label exists, otherwise returns a nullptr (NULL if labels are not used)\n+ *               label_context: pointer to a label context object (NULL if labels are not used)\n+ */\n+\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const secp256k1_pubkey*, const void*);\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *scan_key,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 45,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "016c20d95f96a7cdbe2e36793c37fcb35532f5dd",
      "in_reply_to_id": 1581994092,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Changed `s/receiver/recipient/` consistently. Also removed references to `seckey` and \"private,\" considering the scan key is not a private key.",
      "created_at": "2024-05-03T08:12:00Z",
      "updated_at": "2024-05-03T08:12:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588886367",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886367"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 266,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886604",
      "pull_request_review_id": 2037627449,
      "id": 1588886604,
      "node_id": "PRRC_kwDOAP4Jqs5etHxM",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 7,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993914,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:12:13Z",
      "updated_at": "2024-05-03T08:12:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588886604",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886793",
      "pull_request_review_id": 2037627751,
      "id": 1588886793,
      "node_id": "PRRC_kwDOAP4Jqs5etH0J",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).\n+ *\n+ *  Args:        ctx: pointer to a context object.\n+ *  Out: public_data: pointer to a silentpayments_public_data object. If 1 is returned, it is set to a\n+ *                    parsed version of input33.\n+ *  In:      input33: pointer to a serialized silentpayments_public_data.\n+ */\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:       ctx: pointer to a context object.\n+ *  Out:   output33: pointer to a 32-byte array to place the serialized key in.\n+ *  In: public_data: pointer to an initialized silentpayments_public_data object.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute Silent Payment public data from input public keys and transaction inputs.\n+ *\n+ * Given a list of n public keys A_1...A_n (one for each silent payment\n+ * eligible input to spend) and a serialized outpoint_smallest, compute\n+ * the corresponding input public tweak data:\n+ *\n+ * A_sum = A_1 + A_2 + ... + A_n\n+ * input_hash = hash(outpoint_lowest || A_sum)\n+ *\n+ * The public keys have to be passed in via two different parameter pairs,\n+ * one for regular and one for x-only public keys, in order to avoid the need\n+ * of users converting to a common pubkey format before calling this function.\n+ * The resulting data is can be used for scanning on the recipient side, or stored\n+ * in an index for late use (e.g. wallet rescanning, vending data to light clients).\n+ *\n+ * If calling this function for scanning, the reciever must provide an output param\n+ * for the `input_hash`. If calling this function for simply aggregating the inputs\n+ * for later use, the caller can save the result with `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           public_data: pointer to public_data object containing the summed public key and\n+ *                              input_hash.\n+ *  In:    outpoint_smallest36: serialized smallest outpoint\n+ *               xonly_pubkeys: pointer to an array of pointers to taproot x-only\n+ *                              public keys (can be NULL if no taproot inputs are used)\n+ *             n_xonly_pubkeys: the number of taproot input public keys\n+ *               plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                              public keys (can be NULL if no non-taproot inputs are used)\n+ *             n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(",
      "path": "include/secp256k1_silentpayments.h",
      "position": 219,
      "original_position": 78,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993849,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-05-03T08:12:24Z",
      "updated_at": "2024-05-03T08:12:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588886793",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 219,
      "original_line": 219,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886959",
      "pull_request_review_id": 2037628025,
      "id": 1588886959,
      "node_id": "PRRC_kwDOAP4Jqs5etH2v",
      "diff_hunk": "@@ -324,4 +324,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);\n+    }\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        /* TODO: do we need a special error return code for this case? */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_load(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 56,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993573,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-05-03T08:12:35Z",
      "updated_at": "2024-05-03T08:12:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588886959",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886959"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 379,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588887146",
      "pull_request_review_id": 2037628330,
      "id": 1588887146,
      "node_id": "PRRC_kwDOAP4Jqs5etH5q",
      "diff_hunk": "@@ -324,4 +324,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 38,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993506,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:12:48Z",
      "updated_at": "2024-05-03T08:12:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588887146",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588887146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588887330",
      "pull_request_review_id": 2037628563,
      "id": 1588887330,
      "node_id": "PRRC_kwDOAP4Jqs5etH8i",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 19,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993393,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:12:58Z",
      "updated_at": "2024-05-03T08:12:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588887330",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588887330"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588889660",
      "pull_request_review_id": 2037632371,
      "id": 1588889660,
      "node_id": "PRRC_kwDOAP4Jqs5etIg8",
      "diff_hunk": "@@ -93,6 +93,51 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan private key b_scan and a label integer m, calculate\n+ *  the corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *  label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           label_tweak: pointer to the resulting label tweak\n+ *   In:  receiver_scan_seckey: pointer to the receiver's scan private key\n+ *                           m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *receiver_scan_seckey,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate\n+ *  the corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address, consisting\n+ *  of the serialized and concatenated scan public key and (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out: l_addr_spend_pubkey33: pointer to the resulting labelled spend public key",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 38,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "aeef18499580e576f2078b20936842b899b05bd3",
      "in_reply_to_id": 1581993106,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added.",
      "created_at": "2024-05-03T08:15:27Z",
      "updated_at": "2024-05-03T08:15:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588889660",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588889660"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588889968",
      "pull_request_review_id": 2037632929,
      "id": 1588889968,
      "node_id": "PRRC_kwDOAP4Jqs5etIlw",
      "diff_hunk": "@@ -93,6 +93,51 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan private key b_scan and a label integer m, calculate\n+ *  the corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *  label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           label_tweak: pointer to the resulting label tweak\n+ *   In:  receiver_scan_seckey: pointer to the receiver's scan private key\n+ *                           m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *receiver_scan_seckey,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate\n+ *  the corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address, consisting\n+ *  of the serialized and concatenated scan public key and (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out: l_addr_spend_pubkey33: pointer to the resulting labelled spend public key\n+ *   In: receiver_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                       label: pointer to the the receiver's label\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 44,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "aeef18499580e576f2078b20936842b899b05bd3",
      "in_reply_to_id": 1581993053,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Used `labelled` throughout.",
      "created_at": "2024-05-03T08:15:50Z",
      "updated_at": "2024-05-03T08:15:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588889968",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588889968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 134,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588890103",
      "pull_request_review_id": 2037633133,
      "id": 1588890103,
      "node_id": "PRRC_kwDOAP4Jqs5etIn3",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 18,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": 1581992633,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:15:59Z",
      "updated_at": "2024-05-03T08:15:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588890103",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588890103"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588890267",
      "pull_request_review_id": 2037633411,
      "id": 1588890267,
      "node_id": "PRRC_kwDOAP4Jqs5etIqb",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 16,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": 1581992596,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:16:10Z",
      "updated_at": "2024-05-03T08:16:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588890267",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588890267"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588892139",
      "pull_request_review_id": 2037636286,
      "id": 1588892139,
      "node_id": "PRRC_kwDOAP4Jqs5etJHr",
      "diff_hunk": "@@ -173,4 +173,90 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 186,
      "original_position": 26,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": 1581992522,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added. Out of curiosity, I noticed we have `VERIFY_CHECK` and `ARG_CHECK`, do you know when one is preferred over the other? In most cases, I see `VERIFY_CHECK` being used to check the `ctx`, but there were a few places where `VERIFY_CHECK` was also being used to check the arguments.",
      "created_at": "2024-05-03T08:17:35Z",
      "updated_at": "2024-05-03T08:17:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588892139",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588892139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 186,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588892272",
      "pull_request_review_id": 2037636462,
      "id": 1588892272,
      "node_id": "PRRC_kwDOAP4Jqs5etJJw",
      "diff_hunk": "@@ -9,8 +9,36 @@\n #include \"../../../include/secp256k1.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(\n+        ((secp256k1_ec_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 16,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "97220f7b29b77677e66a527ec933b022ceb2cceb",
      "in_reply_to_id": 1581992289,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-05-03T08:17:42Z",
      "updated_at": "2024-05-03T08:17:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588892272",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588892272"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588894474",
      "pull_request_review_id": 2037639947,
      "id": 1588894474,
      "node_id": "PRRC_kwDOAP4Jqs5etJsK",
      "diff_hunk": "@@ -9,8 +9,36 @@\n #include \"../../../include/secp256k1.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(\n+        ((secp256k1_ec_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 18,
      "original_position": 11,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "97220f7b29b77677e66a527ec933b022ceb2cceb",
      "in_reply_to_id": 1581992204,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'll admit, I don't fully understand why the double pointers are necessary, but they are: when I removed them, my tests would pass locally but the branch would fail the CI. I noticed the double pointers are also used for the `secp256k1_pubkey_sort` function, so leaving for now.",
      "created_at": "2024-05-03T08:20:03Z",
      "updated_at": "2024-05-03T08:20:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588894474",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588894474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": 17,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": 18,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588895904",
      "pull_request_review_id": 2037642324,
      "id": 1588895904,
      "node_id": "PRRC_kwDOAP4Jqs5etKCg",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).\n+ *\n+ *  Args:        ctx: pointer to a context object.\n+ *  Out: public_data: pointer to a silentpayments_public_data object. If 1 is returned, it is set to a\n+ *                    parsed version of input33.\n+ *  In:      input33: pointer to a serialized silentpayments_public_data.\n+ */\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:       ctx: pointer to a context object.\n+ *  Out:   output33: pointer to a 32-byte array to place the serialized key in.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 38,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993315,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:21:36Z",
      "updated_at": "2024-05-03T08:21:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588895904",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588895904"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588905125",
      "pull_request_review_id": 2037657732,
      "id": 1588905125,
      "node_id": "PRRC_kwDOAP4Jqs5etMSl",
      "diff_hunk": "@@ -433,4 +433,137 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    combined = (int)public_data->data[0];\n+    {\n+        unsigned char input_hash[32];\n+        unsigned char *input_hash_ptr;\n+        if (combined) {\n+            input_hash_ptr = NULL;\n+        } else {\n+            memset(input_hash, 0, 32);\n+            input_hash_ptr = input_hash;\n+        }\n+        if (!secp256k1_silentpayments_recipient_public_data_load(ctx, &A_sum, input_hash_ptr, public_data)) {\n+            return 0;\n+        }\n+        secp256k1_pubkey_load(ctx, &receiver_spend_pubkey_ge, receiver_spend_pubkey);\n+        if (!secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, scan_key, &A_sum, input_hash_ptr)) {\n+            return 0;\n+        }\n+    }\n+\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = receiver_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+            return 0;\n+        }\n+\n+        /* If the calculated output matches the one from the tx, we have a direct match and can\n+         * return without labels calculation (one of the two would result in point of infinity) */\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        found = 0;\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                found_outputs[n_found]->output = *tx_outputs[i];\n+                secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+                found = 1;\n+                n_found++;\n+                k++;\n+                break;\n+            }\n+\n+            /* If desired, also calculate label candidates */\n+            if (label_lookup != NULL) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 74,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": 1575010116,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Coming back to this, I tried a few variations but found with the benchmark that comparing the generated output to the tx outputs as serialized bytes is marginally faster than the alternatives, so there wasn't much opportunity for minimizing conversions. I was able to clean up this code a bit, but will likely take a second pass at it.",
      "created_at": "2024-05-03T08:30:50Z",
      "updated_at": "2024-05-03T08:30:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588905125",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588905125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 505,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 573,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1616957538",
      "pull_request_review_id": 2082332210,
      "id": 1616957538,
      "node_id": "PRRC_kwDOAP4Jqs5gYNBi",
      "diff_hunk": "@@ -24,6 +24,21 @@ extern \"C\" {\n  * implementation without requiring any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address data.\n+ * The index field is for when more than one address is being sent to in a transaction. Index is\n+ * set based on the original ordering of the addresses and used to return the generated outputs\n+ * matching the original ordering. When more than one recipient is used the recipient array\n+ * will be sorted in place as part of generating the outputs, but the generated outputs will be\n+ * outputs will be returned original ordering specified by the index to ensure the caller is able",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 9,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ac97828119f39b3fc3f32e00a60e8cc026004306",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit, duplicated \"outputs will be\":\r\n```suggestion\r\n * returned in original ordering specified by the index to ensure the caller is able\r\n```",
      "created_at": "2024-05-28T10:08:36Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1616957538",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1616957538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1616958118",
      "pull_request_review_id": 2082332210,
      "id": 1616958118,
      "node_id": "PRRC_kwDOAP4Jqs5gYNKm",
      "diff_hunk": "@@ -24,6 +24,21 @@ extern \"C\" {\n  * implementation without requiring any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address data.\n+ * The index field is for when more than one address is being sent to in a transaction. Index is\n+ * set based on the original ordering of the addresses and used to return the generated outputs\n+ * matching the original ordering. When more than one recipient is used the recipient array\n+ * will be sorted in place as part of generating the outputs, but the generated outputs will be\n+ * outputs will be returned original ordering specified by the index to ensure the caller is able\n+ * to match up the generated outputs to the correct silent payment address (e.g. to be able to\n+ * assign the correct amounts to the correct generatetd outputs in the final transaction).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 11,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ac97828119f39b3fc3f32e00a60e8cc026004306",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n * assign the correct amounts to the correct generated outputs in the final transaction).\r\n```",
      "created_at": "2024-05-28T10:08:59Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1616958118",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1616958118"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617682290",
      "pull_request_review_id": 2082332210,
      "id": 1617682290,
      "node_id": "PRRC_kwDOAP4Jqs5ga99y",
      "diff_hunk": "@@ -173,4 +173,90 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 186,
      "original_position": 26,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": 1581992522,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sorry for the late reply, missed this comment. To my understanding, the differences are: `VERIFY_CHECK`s are not included in production builds (i.e. only done for tests), while `ARG_CHECK`s are always done. The latter call an illegal callback if the check fails, but need a `ctx` object for that, so the `ctx != NULL` condition can't be checked via `ARG_CHECK` (if it failed, `ctx->illegal_callback` would be a null pointer dereference). I don't think there is usually a good reason to do an argument check with `VERIFY_CHECK` though, as users wouldn't notice immediately if they pass something wrong. I guess you saw `VERIFY_CHECK`s for argument checks that are not for public API functions?\r\n\r\nnit: could also add `ARG_CHECK(generated_outputs != NULL)` here",
      "created_at": "2024-05-28T17:43:42Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617682290",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617682290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 186,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617695781",
      "pull_request_review_id": 2082332210,
      "id": 1617695781,
      "node_id": "PRRC_kwDOAP4Jqs5gbBQl",
      "diff_hunk": "@@ -37,4 +38,84 @@ int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+/* secp256k1_ecdh expects a hash function to be passed in or uses its default\n+ * hashing function. We don't want to hash the ECDH result yet (it will be\n+ * hashed later with a counter `k`), so we define a custom function which simply\n+ * returns the pubkey without hashing.\n+ */\n+static int secp256k1_silentpayments_ecdh_return_pubkey(unsigned char *output, const unsigned char *x32, const unsigned char *y32, void *data) {\n+    secp256k1_ge point;\n+    secp256k1_fe x, y;\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    (void)data;\n+    /* Parse point as group element */\n+    if (!secp256k1_fe_set_b32_limit(&x, x32) || !secp256k1_fe_set_b32_limit(&y, y32)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_xy(&point, &x, &y);\n+\n+    /* Serialize as compressed pubkey */\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&point, output, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == 33);\n+    (void)ser_ret;\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const unsigned char *secret_component, const secp256k1_pubkey *public_component, unsigned char *input_hash) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 68,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f35ab7daa4aa598923e3e3774c14f97bf1e522c9",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: can be made static, as it's not part of the public API (I was slightly confused as I wondered why the API description isn't added in the same commit, but the API function in a later commit calls this function rather than directly exposing it).",
      "created_at": "2024-05-28T17:56:09Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617695781",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617695781"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617696482",
      "pull_request_review_id": 2082332210,
      "id": 1617696482,
      "node_id": "PRRC_kwDOAP4Jqs5gbBbi",
      "diff_hunk": "@@ -118,4 +119,54 @@ int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx,\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 41,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "a4f35830914cde97de0082e8d695df51e0de1b8b",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: can also be made static",
      "created_at": "2024-05-28T17:56:44Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617696482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617696482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617700300",
      "pull_request_review_id": 2082332210,
      "id": 1617700300,
      "node_id": "PRRC_kwDOAP4Jqs5gbCXM",
      "diff_hunk": "@@ -139,6 +139,139 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_public_data_create`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction inputs.\n+ *\n+ * Given a list of n public keys A_1...A_n (one for each silent payment\n+ * eligible input to spend) and a serialized outpoint_smallest, compute\n+ * the corresponding input public tweak data:\n+ *\n+ * A_sum = A_1 + A_2 + ... + A_n\n+ * input_hash = hash(outpoint_lowest || A_sum)\n+ *\n+ * The public keys have to be passed in via two different parameter pairs,\n+ * one for regular and one for x-only public keys, in order to avoid the need\n+ * of users converting to a common pubkey format before calling this function.\n+ * The resulting data is can be used for scanning on the recipient side, or stored\n+ * in an index for late use (e.g. wallet rescanning, vending data to light clients).\n+ *\n+ * If calling this function for scanning, the reciever must provide an output param\n+ * for the `input_hash`. If calling this function for simply aggregating the inputs\n+ * for later use, the caller can save the result with `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           public_data: pointer to public_data object containing the summed public key and\n+ *                              input_hash.\n+ *  In:    outpoint_smallest36: serialized smallest outpoint\n+ *               xonly_pubkeys: pointer to an array of pointers to taproot x-only\n+ *                              public keys (can be NULL if no taproot inputs are used)\n+ *             n_xonly_pubkeys: the number of taproot input public keys\n+ *               plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                              public keys (can be NULL if no non-taproot inputs are used)\n+ *             n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:       ctx: pointer to a context object.\n+ *  Out:   output33: pointer to a 33-byte array to place the serialized `silentpayments_public_data` in.\n+ *  In: public_data: pointer to an initialized silentpayments_public_data object.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represent a valid public key).\n+ *\n+ *  Args:        ctx: pointer to a context object.\n+ *  Out: public_data: pointer to a silentpayments_public_data object. If 1 is returned, it is set to a\n+ *                    parsed version of input33.\n+ *  In:      input33: pointer to a serialized silentpayments_public_data.\n+ */\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *                 public_data: pointer to the input public key sum (optionaly, with the `input_hash`\n+ *                              multiplied in, see `_recipient_compute_public_data`).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 107,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "d43636b96d359b4ba5e7af5c12c7833e116ecc26",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *                              multiplied in, see `_recipient_public_data_create`).\r\n```",
      "created_at": "2024-05-28T18:00:12Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617700300",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617700300"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617702291",
      "pull_request_review_id": 2082332210,
      "id": 1617702291,
      "node_id": "PRRC_kwDOAP4Jqs5gbC2T",
      "diff_hunk": "@@ -272,6 +272,58 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)\n     SECP256K1_ARG_NONNULL(6) SECP256K1_ARG_NONNULL(7) SECP256K1_ARG_NONNULL(8);\n \n+/** Create Silent Payment shared secret.\n+ *\n+ * Given the public input data (A_tweaked = input_hash * A_sum), calculate the shared secret using ECDH:\n+ *\n+ * shared_secret = b_scan * A_tweaked   [Recipient, Light client scenario]\n+ *\n+ * The resulting shared secret is needed as input for creating silent payments\n+ * outputs belonging to the same recipient scan public key.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:       shared_secret33: pointer to the resulting 33-byte shared secret\n+ *  In:     recipient_scan_key: pointer to the recipient's scan key\n+ *                 public_data: pointer to the input public key sum, tweaked with the input_hash\n+ *                              (see `_recipient_compute_public_data`)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 18,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "b58f89117e0765759a2f3c2a3f1782d9c30eb776",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *                              (see `_recipient_public_data_create`)\r\n```",
      "created_at": "2024-05-28T18:01:56Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617702291",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617702291"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617706659",
      "pull_request_review_id": 2082332210,
      "id": 1617706659,
      "node_id": "PRRC_kwDOAP4Jqs5gbD6j",
      "diff_hunk": "@@ -179,7 +183,7 @@ int main(int argc, char** argv) {\n     char* valid_args[] = {\"ecdsa\", \"verify\", \"ecdsa_verify\", \"sign\", \"ecdsa_sign\", \"ecdh\", \"recover\",\n                          \"ecdsa_recover\", \"schnorrsig\", \"schnorrsig_verify\", \"schnorrsig_sign\", \"ec\",\n                          \"keygen\", \"ec_keygen\", \"ellswift\", \"encode\", \"ellswift_encode\", \"decode\",\n-                         \"ellswift_decode\", \"ellswift_keygen\", \"ellswift_ecdh\"};\n+                         \"ellswift_decode\", \"ellswift_keygen\", \"ellswift_ecdh\", \"silentpayments\"};",
      "path": "src/bench.c",
      "position": 38,
      "original_position": 16,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "baafed004cdf3580659e0a475b91564efef837fb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: should also add this on the `help` function on top of the file",
      "created_at": "2024-05-28T18:04:47Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617706659",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617706659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 199,
      "original_line": 199,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617720108",
      "pull_request_review_id": 2082332210,
      "id": 1617720108,
      "node_id": "PRRC_kwDOAP4Jqs5gbHMs",
      "diff_hunk": "@@ -320,4 +320,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        /* TODO: do we need a special error return code for this case? */\n+        return 0;\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 43,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "d43636b96d359b4ba5e7af5c12c7833e116ecc26",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'd say the answer to this open TODO question is \"yes\". If a user scans a tx where the silent payments eligible input's public keys cancel each other out, this probably deserves its own return code to differentiate between the cases \"user misuses API / passed in wrong data\" and \"passed in data could be legit, but we can't continue\" (as discussed before in the earlier PR, e.g. https://github.com/bitcoin-core/secp256k1/pull/1471#issuecomment-1913695251). Would be interesting to hear maintainers opinions on API design here; to my knowledge, currently there is no public API functions that returns anything different than 0 or 1. If the successful return value is still 1, having two errors codes would be e.g. 0 and 2, which seems kind of strange.",
      "created_at": "2024-05-28T18:17:35Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617720108",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617720108"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 359,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 418,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670455581",
      "pull_request_review_id": 2166196376,
      "id": 1670455581,
      "node_id": "PRRC_kwDOAP4Jqs5jkSEd",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 471,
      "original_position": 101,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "ef597945b2632862158a9477a74c1a525e92ffe9: to sanity check the test vectors themselves, if a matching `plain_seckeys[i]` entry exists, derive the public key to see that it matches. I can currently change a byte in the first test vector sec and pub key without breaking a test.",
      "created_at": "2024-07-09T12:37:42Z",
      "updated_at": "2024-07-09T12:38:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670455581",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670455581"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 471,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670483699",
      "pull_request_review_id": 2166243919,
      "id": 1670483699,
      "node_id": "PRRC_kwDOAP4Jqs5jkY7z",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 471,
      "original_position": 101,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Mmm, even if malform `vectors.h` by deleting the `struct bip352_test_vector {` line `make check` is fine. That take a `make clean`. Seems like a Makefile bug.",
      "created_at": "2024-07-09T12:56:19Z",
      "updated_at": "2024-07-09T12:56:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670483699",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670483699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 471,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670493260",
      "pull_request_review_id": 2166261003,
      "id": 1670493260,
      "node_id": "PRRC_kwDOAP4Jqs5jkbRM",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 471,
      "original_position": 101,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "So when I modify the first sec key in the first test vector the test does fail, and test-suite.log shows it happens at line 412 - which makes sense. The suggested sanity check would help debugging though.",
      "created_at": "2024-07-09T13:02:42Z",
      "updated_at": "2024-07-09T13:02:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670493260",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670493260"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 471,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670519831",
      "pull_request_review_id": 2166304629,
      "id": 1670519831,
      "node_id": "PRRC_kwDOAP4Jqs5jkhwX",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,",
      "path": "examples/silentpayments.c",
      "position": 245,
      "original_position": 201,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: it might be safer to have this function take an array of all outpoints of the previous transaction (and `N_TX_INPUTS`) and pick the \"smallest\" one. An implementer who [knows what they're doing](https://github.com/bitcoin/bitcoin/pull/28241#issuecomment-2079095313) can pick it themselves and simply pass an array of size 1.\r\n\r\nIf you keep the interface the same, then it would be good to document `unsigned char smallest_outpoint` above, because it's the only non-obvious variable in this example.",
      "created_at": "2024-07-09T13:19:29Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670519831",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670519831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 245,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670529348",
      "pull_request_review_id": 2166304629,
      "id": 1670529348,
      "node_id": "PRRC_kwDOAP4Jqs5jkkFE",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 175,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: is there a reason to make this more contrived than just a single change address? The \"Note\" below would be fine even if the second Carol address wasn't used in the example.",
      "created_at": "2024-07-09T13:25:42Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670529348",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670529348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670534893",
      "pull_request_review_id": 2166304629,
      "id": 1670534893,
      "node_id": "PRRC_kwDOAP4Jqs5jklbt",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 177,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: maybe move \"adds the index of the ...\" below to where you set `index`.",
      "created_at": "2024-07-09T13:28:50Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670534893",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670534893"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670536761",
      "pull_request_review_id": 2166304629,
      "id": 1670536761,
      "node_id": "PRRC_kwDOAP4Jqs5jkl45",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 188,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60\r\n\r\n```c\r\n/** Read the scan public key, which is the first part of a silent payment address */\r\n```",
      "created_at": "2024-07-09T13:30:08Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670536761",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670536761"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670544678",
      "pull_request_review_id": 2166304629,
      "id": 1670544678,
      "node_id": "PRRC_kwDOAP4Jqs5jkn0m",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 196,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: I find myself confused about the difference between `tx_outputs` and `generated_output_ptrs`. Can you make `tx_outputs` an array of pointers and just use that? I might have missed something.\r\n\r\nA better name might be:\r\n```c\r\n/** The x-only pubkey for each output taproot scriptPubKey. */\r\nsecp256k1_xonly_pubkey *tx_output_pubkey_ptrs[N_TX_OUTPUTS];\r\n```",
      "created_at": "2024-07-09T13:35:22Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670544678",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670544678"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670566910",
      "pull_request_review_id": 2166304629,
      "id": 1670566910,
      "node_id": "PRRC_kwDOAP4Jqs5jktP-",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 200,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If you like the above rename, then this one would be:\r\n\r\n```c\r\n/** The silent recipient for each output or null for a regular address. */\r\nconst secp256k1_silentpayments_recipient *tx_output_recipient_ptrs[N_TX_OUTPUTS];\r\n```\r\n\r\n(the description here is more important than the name, just `recipient_ptrs` is probably fine)",
      "created_at": "2024-07-09T13:48:55Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670566910",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670566910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670572194",
      "pull_request_review_id": 2166304629,
      "id": 1670572194,
      "node_id": "PRRC_kwDOAP4Jqs5jkuii",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 127,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```c\r\n/** The private key for each silent payment eligible input, null otherwise. */\r\n```",
      "created_at": "2024-07-09T13:52:14Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670572194",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670572194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670590035",
      "pull_request_review_id": 2166304629,
      "id": 1670590035,
      "node_id": "PRRC_kwDOAP4Jqs5jky5T",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 236,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60\r\n\r\n```c\r\n/** For each Silent Payment eligible input we collect all pubkeys\r\n  * found in the scriptSig or witness. For simplicity in this \r\n  * example inputs have only one pubkey.\r\n  */\r\nconst secp256k1_xonly_pubkey *tx_input_pubkey_ptrs[N_TX_INPUTS];\r\n```",
      "created_at": "2024-07-09T14:02:42Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670590035",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670590035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670599501",
      "pull_request_review_id": 2166304629,
      "id": 1670599501,
      "node_id": "PRRC_kwDOAP4Jqs5jk1NN",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 256,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: the example would be easier to follow if you first demonstrate usage without labels, since they're optional.",
      "created_at": "2024-07-09T14:08:50Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670599501",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670599501"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670602364",
      "pull_request_review_id": 2166304629,
      "id": 1670602364,
      "node_id": "PRRC_kwDOAP4Jqs5jk158",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 280,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: maybe emphasise that we only need the _scan_ private key",
      "created_at": "2024-07-09T14:10:27Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670602364",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670602364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670608423",
      "pull_request_review_id": 2166304629,
      "id": 1670608423,
      "node_id": "PRRC_kwDOAP4Jqs5jk3Yn",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and used the labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key. Storing it this way saves 32 bytes for the light client because\n+             * now it can be send as a 33 byte compressed public key instead of 33 bytes for A_sum and 32 bytes for input_hash.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,",
      "path": "examples/silentpayments.c",
      "position": 419,
      "original_position": 318,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The documentation for `secp256k1_silentpayments_recipient_scan_outputs` needs to be moved below the typedef and struct. At least otherwise VSCode doesn't find it.",
      "created_at": "2024-07-09T14:14:27Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670608423",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670608423"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 419,
      "original_line": 419,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670624345",
      "pull_request_review_id": 2166304629,
      "id": 1670624345,
      "node_id": "PRRC_kwDOAP4Jqs5jk7RZ",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 265,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Can be demystified with something like this:\r\n\r\n```c\r\n/** Public data is an x-only (?) public key that can be generated\r\n  * for each transaction without knowledge of either the input\r\n  * private keys or the recipient silent payment address. This\r\n  * function performs ECDH on it and checks if any found_output_ptrs\r\n  * contains the resulting x-only pubkey - indication it's a silent\r\n  * payment to us.\r\n  * See also light client scanning below.\r\n  */\r\n```",
      "created_at": "2024-07-09T14:24:24Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670624345",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670624345"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670637013",
      "pull_request_review_id": 2166504001,
      "id": 1670637013,
      "node_id": "PRRC_kwDOAP4Jqs5jk-XV",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 265,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It might even make sense to move the light client example up, since by necessity it explains some of the things that happen automagically.",
      "created_at": "2024-07-09T14:31:39Z",
      "updated_at": "2024-07-09T14:31:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670637013",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670637013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670750586",
      "pull_request_review_id": 2166692075,
      "id": 1670750586,
      "node_id": "PRRC_kwDOAP4Jqs5jlaF6",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 471,
      "original_position": 101,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Mmm, even if malform vectors.h by deleting the struct bip352_test_vector { line make check is fine.\r\n\r\nSounds like make is not picking up that `vectors.h` changed? Will look into this.\r\n\r\n> to sanity check the test vectors themselves, if a matching plain_seckeys[i] entry exists, derive the public key to see that it matches\r\n\r\nThis would make the tests run slower, and I don't really see the value. Since the values for the tests are static, seems sufficient to do a one-time manual check as part of testing vs make this run every time in the CI?",
      "created_at": "2024-07-09T15:36:18Z",
      "updated_at": "2024-07-09T15:36:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670750586",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670750586"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 471,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673610346",
      "pull_request_review_id": 2171240854,
      "id": 1673610346,
      "node_id": "PRRC_kwDOAP4Jqs5jwURq",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 471,
      "original_position": 101,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> a one-time manual check\r\n\r\nMaybe the Python script can do it?",
      "created_at": "2024-07-11T08:22:17Z",
      "updated_at": "2024-07-11T08:22:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673610346",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673610346"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 471,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673629197",
      "pull_request_review_id": 2171270367,
      "id": 1673629197,
      "node_id": "PRRC_kwDOAP4Jqs5jwY4N",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 471,
      "original_position": 101,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You can add the file here:\r\nhttps://github.com/bitcoin-core/secp256k1/blob/0055b86780f2aa7272a1c307f6b9cd298584340f/Makefile.am#L237-L243 \r\n\r\nThen CI will check that the files match:\r\nhttps://github.com/bitcoin-core/secp256k1/blob/0055b86780f2aa7272a1c307f6b9cd298584340f/ci/ci.sh#L138-L147\r\n\r\nNote in case you're wondering: There's no CMake equivalent for this. It's our own internal stuff, so there was no need to port it to CMake.\r\n\r\n",
      "created_at": "2024-07-11T08:35:48Z",
      "updated_at": "2024-07-11T08:35:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673629197",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673629197"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 471,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673641829",
      "pull_request_review_id": 2171290605,
      "id": 1673641829,
      "node_id": "PRRC_kwDOAP4Jqs5jwb9l",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 265,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> ```c\r\n> /** Public data is an x-only (?) public key that can be generated\r\n>   * for each transaction without knowledge of either the input\r\n>   * private keys or the recipient silent payment address. This\r\n>   * function performs ECDH on it and checks if any found_output_ptrs\r\n>   * contains the resulting x-only pubkey - indication it's a silent\r\n>   * payment to us.\r\n>   * See also light client scanning below.\r\n>   */\r\n> ```\r\n\r\nDemystifying is a good idea, but I think we shouldn't mix API usage with protocol internals. (If people want to know how it works under the hood, they should just read the BIP.)\r\n\r\n - The public data is public data that can be generated for each transaction without knowledge of either the input private keys or the recipient silent payment address. Whether it's a public key is not relevant for API users. \r\n - This checks if it's (potential) silent payment to us. The fact that it does an ECDH key exchange is a detail of the protocol. \r\n\r\nedit: Of course, this is not a strict requirement but rather a rule of thumb. For example, the first few lines of the module docs in `include/secp256k1_silentpayments.h` mention ECDH, and I guess that's fine as a tiny bit of background what this module does at all.",
      "created_at": "2024-07-11T08:44:43Z",
      "updated_at": "2024-07-11T08:50:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673641829",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673641829"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673706429",
      "pull_request_review_id": 2171391280,
      "id": 1673706429,
      "node_id": "PRRC_kwDOAP4Jqs5jwru9",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 265,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I wrote most of this based on my own initial confusion with the example code, and I have read the BIP. Agree it shouldn't duplicate the whole thing, just enough so people understand what the code is trying to do.\r\n\r\nE.g. the only reason I understood what \"public data\" referred to was from @josibake's way of phrasing stuff in a podcast.",
      "created_at": "2024-07-11T09:26:44Z",
      "updated_at": "2024-07-11T09:28:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673706429",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673706429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673724190",
      "pull_request_review_id": 2171419611,
      "id": 1673724190,
      "node_id": "PRRC_kwDOAP4Jqs5jwwEe",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,",
      "path": "examples/silentpayments.c",
      "position": 245,
      "original_position": 201,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670519831,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'd prefer to keep the interface the same, but agree \"smallest outpoint\" needs better documentation.\r\n\r\nIf we change this to accept an array of outpoints, it doesn't actually prevent the caller from making a mistake: they can pass an array of size 1 with the wrong outpoint, or pass a subset of outpoints that doesn't include the smallest outpoint. It does, however, require the caller to pass extra data to the function that is then immediately discarded and makes the API a bit more complicated.\r\n\r\nIn this case, seems better to prefer the simpler API along with good documentation on the importance of choosing this value correctly.",
      "created_at": "2024-07-11T09:38:24Z",
      "updated_at": "2024-07-11T09:38:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673724190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673724190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 245,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673837049",
      "pull_request_review_id": 2171602423,
      "id": 1673837049,
      "node_id": "PRRC_kwDOAP4Jqs5jxLn5",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 265,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> E.g. the only reason I understood what \"public data\" referred to was from @josibake's way of phrasing stuff in a podcast.\r\n\r\nPerhaps we can find a better term? (Public) scanning data?\r\n\r\nBy the way, I listened to that epsiode yesterday... :)",
      "created_at": "2024-07-11T11:12:14Z",
      "updated_at": "2024-07-11T11:12:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673837049",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673837049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673844535",
      "pull_request_review_id": 2171615005,
      "id": 1673844535,
      "node_id": "PRRC_kwDOAP4Jqs5jxNc3",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 175,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670529348,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The reason is to demonstrate how to create multiple outputs for the same user. This is mentioned in the documentation for the API but I felt this would be a good one to have an example for, e.g., to show how to set the indexes on the recipient object correctly and to demonstrate how the generated outputs are matched back up to the correct recipients.\r\n\r\nI think it's better to have a more complicated example for demonstrating the API usage considering in this case, all that's needed for a more simple use case is to just remove objects from the recipient array.",
      "created_at": "2024-07-11T11:19:05Z",
      "updated_at": "2024-07-11T11:19:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673844535",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673844535"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673851404",
      "pull_request_review_id": 2171626279,
      "id": 1673851404,
      "node_id": "PRRC_kwDOAP4Jqs5jxPIM",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 196,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670544678,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch, I think this would be less confusing if more consistent naming were used, e.g., `tx_outputs; tx_output_ptrs`. Regarding the API: arrays are passed as a pointer to an array of pointers to objects. This means we need to first create the array of objects (`tx_outputs`), and then create the array of pointers to those objects (`tx_output_ptrs`).\r\n\r\nIn the case of `tx_outputs`, it's less obvious why the we want the pointer to array of pointers approach, but I think its better to keep the API consistent, i.e., if passing an array to the function, it must be a pointer to an array of pointers.\r\n\r\nI think this might warrant a `doc/silentpayments.md` explaining the usage of the API, similar to the musig2 PR.",
      "created_at": "2024-07-11T11:25:15Z",
      "updated_at": "2024-07-11T11:52:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673851404",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673851404"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673854679",
      "pull_request_review_id": 2171631797,
      "id": 1673854679,
      "node_id": "PRRC_kwDOAP4Jqs5jxP7X",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 236,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670590035,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Actually, the eligible inputs from the BIP were chosen so that there is only one public key per input. This is why `OP_CHECKMULTISIG` inputs are not eligible for silent payments, for example.",
      "created_at": "2024-07-11T11:28:13Z",
      "updated_at": "2024-07-11T11:28:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673854679",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673854679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673857157",
      "pull_request_review_id": 2171635848,
      "id": 1673857157,
      "node_id": "PRRC_kwDOAP4Jqs5jxQiF",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 256,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670599501,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I considered this, but as mentioned in https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673844535, the goal of the example is to provide guidance for the more complicated usage of the API. In this case, the goal is to give a concrete example of what the `label_context` is.\r\n\r\nPerhaps its worth adding a comment mentioning that labels are optional and using without labels is as simple as calling the function with `NULL, NULL` for label_lookup and label_context.",
      "created_at": "2024-07-11T11:30:23Z",
      "updated_at": "2024-07-11T11:30:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673857157",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673857157"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673858218",
      "pull_request_review_id": 2171637646,
      "id": 1673858218,
      "node_id": "PRRC_kwDOAP4Jqs5jxQyq",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 280,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670602364,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm not sure what you mean here? In order to scan, Bob needs his `scan` key _and_ spend public key.",
      "created_at": "2024-07-11T11:31:21Z",
      "updated_at": "2024-07-11T11:31:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673858218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673858218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673858617",
      "pull_request_review_id": 2171638377,
      "id": 1673858617,
      "node_id": "PRRC_kwDOAP4Jqs5jxQ45",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and used the labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key. Storing it this way saves 32 bytes for the light client because\n+             * now it can be send as a 33 byte compressed public key instead of 33 bytes for A_sum and 32 bytes for input_hash.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,",
      "path": "examples/silentpayments.c",
      "position": 419,
      "original_position": 318,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670608423,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nice catch! Will fix and add documentation for the struct.",
      "created_at": "2024-07-11T11:31:44Z",
      "updated_at": "2024-07-11T11:31:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673858617",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673858617"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 419,
      "original_line": 419,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673946164",
      "pull_request_review_id": 2171781333,
      "id": 1673946164,
      "node_id": "PRRC_kwDOAP4Jqs5jxmQ0",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 200,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670566910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The array here would never contain nulls for \"regular addresses,\" so I don't think the description here is accurate.",
      "created_at": "2024-07-11T12:41:27Z",
      "updated_at": "2024-07-11T12:41:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673946164",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673946164"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673946884",
      "pull_request_review_id": 2171782382,
      "id": 1673946884,
      "node_id": "PRRC_kwDOAP4Jqs5jxmcE",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 127,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670572194,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Same comment as above, these arrays would never contain non-silent payment eligible data.",
      "created_at": "2024-07-11T12:41:56Z",
      "updated_at": "2024-07-11T12:41:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673946884",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673946884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673973270",
      "pull_request_review_id": 2171825201,
      "id": 1673973270,
      "node_id": "PRRC_kwDOAP4Jqs5jxs4W",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 265,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I agree its better to refer people to the BIP if they are interested in the internals. For `public_data` specifically, I think the documentation for `_public_data_create` should be sufficient for explaining to the caller what a `public_data` object is.\r\n\r\nAs @Sjors pointed out in a different comment, `smallest_outpoint` isn't well documented, but aside from that I think referring to this function should be sufficient for the caller.",
      "created_at": "2024-07-11T12:58:04Z",
      "updated_at": "2024-07-11T12:58:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673973270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673973270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674828546",
      "pull_request_review_id": 2173313611,
      "id": 1674828546,
      "node_id": "PRRC_kwDOAP4Jqs5j09sC",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 18,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "as this function always succeeds, it could just be `void` with the `return 1;` removed",
      "created_at": "2024-07-11T23:48:36Z",
      "updated_at": "2024-07-12T00:24:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1674828546",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674828546"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674829069",
      "pull_request_review_id": 2173313611,
      "id": 1674829069,
      "node_id": "PRRC_kwDOAP4Jqs5j090N",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 68,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "micro-nit: `len` is a pure out-parameter for `_eckey_pubkey_serialize`, so it doesn't need to be initialized (in contrast to the public API function `_ec_pubkey_serialize` where it is an In/Out param)\r\n```suggestion\r\n    size_t len;\r\n```",
      "created_at": "2024-07-11T23:49:34Z",
      "updated_at": "2024-07-12T00:24:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1674829069",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674829069"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674831667",
      "pull_request_review_id": 2173313611,
      "id": 1674831667,
      "node_id": "PRRC_kwDOAP4Jqs5j0-cz",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 76,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this call should always succeed (same as in `_silentpayments_calculate_input_hash` above), given that the only reason to return 0 is if the passed group element is the point at inifinity, which should never happen? If that assumption is right, then we could make the whole function `void`, and a `VERIFY_CHECK` on `ret` and `len` would be sufficient",
      "created_at": "2024-07-11T23:55:04Z",
      "updated_at": "2024-07-12T00:24:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1674831667",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674831667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674851580",
      "pull_request_review_id": 2173313611,
      "id": 1674851580,
      "node_id": "PRRC_kwDOAP4Jqs5j1DT8",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+\n+    /* This will fail if B_spend + t_k*G is the point at infinity */\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    /* TODO: any concerns here with multiplying a \"secret\" by a scalar here, i.e., input_hash * a_sum\n+     * Mostly concerned about cases where a_sum is a single key and leaking information about a_sum\n+     * since input_hash can be calculated by anyone\n+     */\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 209,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Regarding the TODO, I strongly assume that this is fine. For example, in `secp256k1_ecdsa_sig_sign` we also have a `_scalar_mul` call with a scalar corresponding to a secret key.",
      "created_at": "2024-07-12T00:14:40Z",
      "updated_at": "2024-07-12T00:24:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1674851580",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674851580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 209,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674861098",
      "pull_request_review_id": 2173313611,
      "id": 1674861098,
      "node_id": "PRRC_kwDOAP4Jqs5j1Foq",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 109,
      "original_position": 97,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`hash_ser` should probably also be cleaned out, as it's just another representation of `t_k_scalar` (which is in turn cleaned out in the calling function below)",
      "created_at": "2024-07-12T00:19:15Z",
      "updated_at": "2024-07-12T00:24:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1674861098",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674861098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675214177",
      "pull_request_review_id": 2173748186,
      "id": 1675214177,
      "node_id": "PRRC_kwDOAP4Jqs5j2b1h",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+\n+    /* This will fail if B_spend + t_k*G is the point at infinity */\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    /* TODO: any concerns here with multiplying a \"secret\" by a scalar here, i.e., input_hash * a_sum\n+     * Mostly concerned about cases where a_sum is a single key and leaking information about a_sum\n+     * since input_hash can be calculated by anyone\n+     */\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 209,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674851580,
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "But if `a_sum` is a single key, is it possible to calculate the secret key, given any derived public information (such as the generated output) ?",
      "created_at": "2024-07-12T04:00:24Z",
      "updated_at": "2024-07-12T04:00:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675214177",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675214177"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 209,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675423437",
      "pull_request_review_id": 2174042925,
      "id": 1675423437,
      "node_id": "PRRC_kwDOAP4Jqs5j3O7N",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,",
      "path": "examples/silentpayments.c",
      "position": 245,
      "original_position": 201,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670519831,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good documentation sounds fine too. IIRC the main gotcha is to not interpret the output position as an integer when doing the comparison, as most wallets probably store outpoints as `{uint256, uint32}` instead of 36 (?) serialized bytes.",
      "created_at": "2024-07-12T07:16:29Z",
      "updated_at": "2024-07-12T07:17:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675423437",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675423437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 245,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675430786",
      "pull_request_review_id": 2174054366,
      "id": 1675430786,
      "node_id": "PRRC_kwDOAP4Jqs5j3QuC",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 175,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670529348,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The problem with complicated examples in general is that they distract the reader into trying to understand what the example is about, rather than focus on how to code it.\r\n\r\nAnother approach could be:\r\n\r\n```c\r\nsp_addresses[0] = &carol_address; /* : 1.0 BTC */\r\nsp_addresses[1] = &bob_address;   /* : 2.0 BTC */\r\n/*\r\n * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\r\n * address again, e.g.:\r\n * \r\n * sp_addresses[2] = &carol_address; /* : 3.0 BTC */\r\n * \r\n */",
      "created_at": "2024-07-12T07:23:34Z",
      "updated_at": "2024-07-12T07:24:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675430786",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675430786"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675436453",
      "pull_request_review_id": 2174063598,
      "id": 1675436453,
      "node_id": "PRRC_kwDOAP4Jqs5j3SGl",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 196,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670544678,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree it's better to keep the API consistent.\r\n\r\nThere's no magical C way to create an array of pointers to objects without first going through an array of objects? In any case the naming change makes it clear that `tx_outputs` and `tx_output_ptrs` refer to the same \"stuff\".",
      "created_at": "2024-07-12T07:28:35Z",
      "updated_at": "2024-07-12T07:28:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675436453",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675436453"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675437422",
      "pull_request_review_id": 2174065075,
      "id": 1675437422,
      "node_id": "PRRC_kwDOAP4Jqs5j3SVu",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 200,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670566910,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Then what's in the output positions that aren't a silent payment?",
      "created_at": "2024-07-12T07:29:28Z",
      "updated_at": "2024-07-12T07:29:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675437422",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675437422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675439259",
      "pull_request_review_id": 2174067878,
      "id": 1675439259,
      "node_id": "PRRC_kwDOAP4Jqs5j3Syb",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+\n+    /* This will fail if B_spend + t_k*G is the point at infinity */\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    /* TODO: any concerns here with multiplying a \"secret\" by a scalar here, i.e., input_hash * a_sum\n+     * Mostly concerned about cases where a_sum is a single key and leaking information about a_sum\n+     * since input_hash can be calculated by anyone\n+     */\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 209,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674851580,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I strongly assume that this is fine\r\n\r\nSame. Left the comment more to draw eyes from the \"Friendly Neighborhood Cryptographers.\" I'm not aware of any timing attacks that work with multiplying scalars or information that could be leaked, but wanted to double check.\r\n\r\n> is it possible to calculate the secret key, given any derived public information\r\n\r\nNo. This is a question about whether or not an attacker can learn anything from the multiplication step.",
      "created_at": "2024-07-12T07:31:04Z",
      "updated_at": "2024-07-12T07:31:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675439259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675439259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 209,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675442354",
      "pull_request_review_id": 2174072251,
      "id": 1675442354,
      "node_id": "PRRC_kwDOAP4Jqs5j3Tiy",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 236,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670590035,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, nice! In that case:\r\n\r\n```c\r\n/** For each Silent Payment eligible input we collect the pubkey\r\n  * found in its scriptSig or witness. See Inputs For Shared Secret Derivation\r\n  * in the BIP.\r\n  */\r\n```\r\n",
      "created_at": "2024-07-12T07:33:36Z",
      "updated_at": "2024-07-12T07:34:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675442354",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675442354"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675447695",
      "pull_request_review_id": 2174080834,
      "id": 1675447695,
      "node_id": "PRRC_kwDOAP4Jqs5j3U2P",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 256,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670599501,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Same reaction. I think you need to guide people through a simple usage before covering a more advanced one. Otherwise anyone just looking for the simple use case will give up confused. And most people looking for an advanced use case probably want to start with the simple one and then expand it.\r\n\r\nIt's already clear from the comment that labels are optional, but it's not clear how to avoid using them (without staring for a long time). You could perhaps add comments along the lines of \"// Skip this if you're not using labels\".",
      "created_at": "2024-07-12T07:38:32Z",
      "updated_at": "2024-07-12T07:38:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675447695",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675447695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675452696",
      "pull_request_review_id": 2174088666,
      "id": 1675452696,
      "node_id": "PRRC_kwDOAP4Jqs5j3WEY",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 280,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670602364,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, it's already loaded.\r\n\r\n```c\r\n/* Load Bob's spend public key. We already loaded his scan (secret) key. */\r\n```",
      "created_at": "2024-07-12T07:43:07Z",
      "updated_at": "2024-07-12T07:43:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675452696",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675452696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675452763",
      "pull_request_review_id": 2174088750,
      "id": 1675452763,
      "node_id": "PRRC_kwDOAP4Jqs5j3WFb",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,",
      "path": "examples/silentpayments.c",
      "position": 245,
      "original_position": 201,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670519831,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yep, this was an issue we ran into before. There is now a test for exactly this mistake in the test vectors.",
      "created_at": "2024-07-12T07:43:10Z",
      "updated_at": "2024-07-12T07:43:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675452763",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675452763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 245,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675459644",
      "pull_request_review_id": 2174099940,
      "id": 1675459644,
      "node_id": "PRRC_kwDOAP4Jqs5j3Xw8",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 265,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The term \"public data\" doesn't occur in the BIP. Even if you point to the section \"Creating outputs\" it's not obvious. But it might be better to clarify this in the BIP instead of in the demo. It could more clearly separate the derivation that needs only public data from the tweaks with the private key.",
      "created_at": "2024-07-12T07:49:32Z",
      "updated_at": "2024-07-12T07:50:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675459644",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675459644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675460730",
      "pull_request_review_id": 2174101556,
      "id": 1675460730,
      "node_id": "PRRC_kwDOAP4Jqs5j3YB6",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 175,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670529348,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> The problem with complicated examples in general is that they distract the reader into trying to understand what the example is about, rather than focus on how to code it.\r\n\r\nI don't think that is the case here. I'd prefer to keep the line in, considering it's about as complicated as the comment.",
      "created_at": "2024-07-12T07:50:27Z",
      "updated_at": "2024-07-12T07:50:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675460730",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675460730"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675466437",
      "pull_request_review_id": 2174110444,
      "id": 1675466437,
      "node_id": "PRRC_kwDOAP4Jqs5j3ZbF",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and used the labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key. Storing it this way saves 32 bytes for the light client because\n+             * now it can be send as a 33 byte compressed public key instead of 33 bytes for A_sum and 32 bytes for input_hash.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,",
      "path": "examples/silentpayments.c",
      "position": 419,
      "original_position": 318,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670608423,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T07:55:26Z",
      "updated_at": "2024-07-12T07:55:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675466437",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675466437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 419,
      "original_line": 419,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675467092",
      "pull_request_review_id": 2174111556,
      "id": 1675467092,
      "node_id": "PRRC_kwDOAP4Jqs5j3ZlU",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 265,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated the wording and added documentation for `smallest_outpoint`.",
      "created_at": "2024-07-12T07:56:02Z",
      "updated_at": "2024-07-12T07:56:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675467092",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675467092"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675471958",
      "pull_request_review_id": 2174119654,
      "id": 1675471958,
      "node_id": "PRRC_kwDOAP4Jqs5j3axW",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 256,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670599501,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'd prefer to keep labels in the example since it shows usage of the `secp256k1_silentpayments_recipient_create_label_tweak` function. I added a comment near the top that makes it more clear that labels are optional and that the function can be called with `NULL, NULL` if not using labels. This comment is then reiterated in the scanning section with a comment at the call site of the scanning function.",
      "created_at": "2024-07-12T08:00:24Z",
      "updated_at": "2024-07-12T08:00:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675471958",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675471958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675483412",
      "pull_request_review_id": 2174137797,
      "id": 1675483412,
      "node_id": "PRRC_kwDOAP4Jqs5j3dkU",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 236,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670590035,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This comment still feels like protocol exposition and doesn't add any information on how to use the API, which is what the example is aimed at, so I'd prefer to keep it as is.",
      "created_at": "2024-07-12T08:10:22Z",
      "updated_at": "2024-07-12T08:10:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675483412",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675483412"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675499986",
      "pull_request_review_id": 2174163192,
      "id": 1675499986,
      "node_id": "PRRC_kwDOAP4Jqs5j3hnS",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 471,
      "original_position": 101,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added.",
      "created_at": "2024-07-12T08:24:14Z",
      "updated_at": "2024-07-12T08:24:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675499986",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675499986"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 471,
      "original_line": 471,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675523065",
      "pull_request_review_id": 2174199522,
      "id": 1675523065,
      "node_id": "PRRC_kwDOAP4Jqs5j3nP5",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 230,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: s/Or/or (https://github.com/bitcoin-core/secp256k1/pull/1551/commits/fe4fbaa7f3eaa404f7ded669e611e28260839f9c)",
      "created_at": "2024-07-12T08:43:16Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675523065",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675523065"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675526075",
      "pull_request_review_id": 2174199522,
      "id": 1675526075,
      "node_id": "PRRC_kwDOAP4Jqs5j3n-7",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 25,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: We typically have spaces after the commas here.",
      "created_at": "2024-07-12T08:45:40Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675526075",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675526075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675543067",
      "pull_request_review_id": 2174199522,
      "id": 1675543067,
      "node_id": "PRRC_kwDOAP4Jqs5j3sIb",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+#!/usr/bin/env python3\n+import hashlib\n+import json\n+import sys\n+\n+import bech32m\n+import ripemd160\n+\n+NUMS_H = bytes.fromhex(\"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\")\n+MAX_INPUTS_PER_TEST_CASE = 3\n+MAX_OUTPUTS_PER_TEST_CASE = 4\n+MAX_PERMUTATIONS_PER_SENDING_TEST_CASE = 12\n+\n+def sha256(s):\n+    return hashlib.sha256(s).digest()\n+\n+def hash160(s):\n+    return ripemd160.ripemd160(sha256(s))\n+\n+def smallest_outpoint(outpoints):\n+    serialized_outpoints = [bytes.fromhex(txid)[::-1] + n.to_bytes(4, 'little') for txid, n in outpoints]\n+    return sorted(serialized_outpoints)[0]\n+\n+def decode_silent_payments_address(address):\n+    _, data = bech32m.decode(\"sp\", address)\n+    data = bytes(data)  # convert from list to bytes\n+    assert len(data) == 66\n+    return data[:33], data[33:]\n+\n+def is_p2tr(s):  # OP_1 OP_PUSHBYTES_32 <32 bytes>\n+    return (len(s) == 34) and (s[0] == 0x51) and (s[1] == 0x20)\n+\n+def is_p2wpkh(s):  # OP_0 OP_PUSHBYTES_20 <20 bytes>\n+    return (len(s) == 22) and (s[0] == 0x00) and (s[1] == 0x14)\n+\n+def is_p2sh(s):  # OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUAL\n+    return (len(s) == 23) and (s[0] == 0xA9) and (s[1] == 0x14) and (s[-1] == 0x87)\n+\n+def is_p2pkh(s):  # OP_DUP OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUALVERIFY OP_CHECKSIG\n+    return (len(s) == 25) and (s[0] == 0x76) and (s[1] == 0xA9) and (s[2] == 0x14) and \\\n+        (s[-2] == 0x88) and (s[-1] == 0xAC)\n+\n+def get_pubkey_from_input(spk, script_sig, witness):\n+    # build witness stack from raw witness data\n+    witness_stack = []\n+    no_witness_items = 0\n+    if len(witness) > 0:\n+        no_witness_items = witness[0]\n+        witness = witness[1:]\n+    for i in range(no_witness_items):\n+        item_len = witness[0]\n+        witness_stack.append(witness[1:item_len+1])\n+        witness = witness[item_len+1:]\n+\n+    if is_p2pkh(spk):\n+        spk_pkh = spk[3:3 + 20]\n+        for i in range(len(script_sig), 0, -1):\n+            if i - 33 >= 0:\n+                pk = script_sig[i - 33:i]\n+                if hash160(pk) == spk_pkh:\n+                    return pk\n+    elif is_p2sh(spk) and is_p2wpkh(script_sig[1:]):\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2wpkh(spk):\n+        # the witness must contain two items and the second item is the pubkey\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2tr(spk):\n+        if len(witness_stack) > 1 and witness_stack[-1][0] == 0x50:\n+            witness_stack.pop()\n+        if len(witness_stack) > 1:  # script-path spend?\n+            control_block = witness_stack[-1]\n+            internal_key = control_block[1:33]\n+            if internal_key == NUMS_H:  # skip\n+                return b''\n+        return spk[2:]\n+\n+    return b''\n+\n+def to_c_array(x):\n+    if x == \"\":\n+        return \"\"\n+    s = ',0x'.join(a+b for a,b in zip(x[::2], x[1::2]))\n+    return \"0x\" + s\n+\n+def emit_key_material(comment, keys, include_count=False):\n+    global out\n+    if include_count:\n+        out += f\"        {len(keys)},\" + \"\\n\"\n+    out += f\"        {{ /* {comment} */\" + \"\\n\"\n+    for i in range(MAX_INPUTS_PER_TEST_CASE):\n+        out += \"            \"\n+        if i < len(keys):\n+            out += \"{\"\n+            out += to_c_array(keys[i])\n+            out += \"}\"\n+        else:\n+            out += '\"\"'\n+        if i != MAX_INPUTS_PER_TEST_CASE - 1:\n+            out += ','",
      "path": "tools/tests_silentpayments_generate.py",
      "position": null,
      "original_position": 103,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0b6827182d29c2ca78085f0c435a87eeb9d59501",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Believe it or not, but C89 allows trailing commas here, so you don't need to check.",
      "created_at": "2024-07-12T08:55:24Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675543067",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675543067"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 102,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675549354",
      "pull_request_review_id": 2174199522,
      "id": 1675549354,
      "node_id": "PRRC_kwDOAP4Jqs5j3tqq",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 147,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I think it will be good to limit the lines to 80 chars if possible/reasonable. (We have a rule about this in CONTRIBUTING.md for headers. I guess it should apply to examples, too.)",
      "created_at": "2024-07-12T09:00:42Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675549354",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675549354"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 146,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675550482",
      "pull_request_review_id": 2174199522,
      "id": 1675550482,
      "node_id": "PRRC_kwDOAP4Jqs5j3t8S",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 224,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: spacing",
      "created_at": "2024-07-12T09:01:43Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675550482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675550482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675553262",
      "pull_request_review_id": 2174199522,
      "id": 1675553262,
      "node_id": "PRRC_kwDOAP4Jqs5j3unu",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": 1581994645,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Really done? \r\n\r\nedit: Well, we should change the other examples and perhaps also the API docs. Creating keys in a while loop is not good practice. If you hit an invalid key, you're most probably not very lucky, but very unlucky because your randomness is broken. But hey, yeah, let's just yolo and try again. :)\r\n\r\nSo I guess either is fine for now: keep the loop for consistency with the other examples, or just return 1 here, but having a loop *and* the else branch is certainly a smell.  \r\n\r\n",
      "created_at": "2024-07-12T09:03:59Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675553262",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675553262"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675559211",
      "pull_request_review_id": 2174199522,
      "id": 1675559211,
      "node_id": "PRRC_kwDOAP4Jqs5j3wEr",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 182,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: s/bitcoin/BTC for consistency>",
      "created_at": "2024-07-12T09:09:14Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675559211",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675559211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675563261",
      "pull_request_review_id": 2174199522,
      "id": 1675563261,
      "node_id": "PRRC_kwDOAP4Jqs5j3xD9",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_TX_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL if scanning without labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &found_outputs[i].output);\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the transaction outputs. This\n+             * means she will need to first generate an output, check if it exists in the UTXO set (e.g.\n+             * BIP158 or some other means of querying) and only proceed to check the next output (by\n+             * incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the transaction inputs and prevout information,\n+             * so she uses the `public_data` object creatd by Bob's full node earlier. This serialized `public_data` object\n+             * contains everything she needs for generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of time but we are cheating here\n+             * to keep the example simple.\n+             */\n+            unsigned char ser_found_outputs[2][32];\n+            unsigned char shared_secret[33];\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_silentpayments_public_data public_data;\n+            size_t n_found_outputs;\n+\n+            /* Load Carol's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, carol_address[1], 33);\n+            assert(ret);\n+\n+            /* Scan one output at a time, using the serialized `public_data` created by Bob's full node */\n+            ret = secp256k1_silentpayments_recipient_public_data_parse(ctx, &public_data, light_client_data33);\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_create_shared_secret(ctx,\n+                shared_secret,\n+                carol_scan_key,\n+                &public_data\n+            );\n+            assert(ret);\n+            n_found_outputs = 0;\n+            {\n+                int found = 0;\n+                size_t k = 0;\n+                secp256k1_xonly_pubkey potential_output;\n+\n+                while(1) {\n+",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 390,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: add space after `while` and remove the empty line ",
      "created_at": "2024-07-12T09:12:32Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675563261",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675563261"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 389,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675565206",
      "pull_request_review_id": 2174199522,
      "id": 1675565206,
      "node_id": "PRRC_kwDOAP4Jqs5j3xiW",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 293,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Do you think this could be simplified by working with the serializations of the pubkeys?",
      "created_at": "2024-07-12T09:14:17Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675565206",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675565206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 290,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675567599",
      "pull_request_review_id": 2174199522,
      "id": 1675567599,
      "node_id": "PRRC_kwDOAP4Jqs5j3yHv",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_TX_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL if scanning without labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &found_outputs[i].output);\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the transaction outputs. This\n+             * means she will need to first generate an output, check if it exists in the UTXO set (e.g.\n+             * BIP158 or some other means of querying) and only proceed to check the next output (by\n+             * incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the transaction inputs and prevout information,\n+             * so she uses the `public_data` object creatd by Bob's full node earlier. This serialized `public_data` object",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 358,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: created",
      "created_at": "2024-07-12T09:16:22Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675567599",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675567599"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 358,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675573384",
      "pull_request_review_id": 2174199522,
      "id": 1675573384,
      "node_id": "PRRC_kwDOAP4Jqs5j3ziI",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 2,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Our current recommendation is to skip all years and author info in new files (also in the C files), see the ellswift module for example. If there's no data, it cannot become wrong and outdated, and the git history anyway does a better job here. (And copyright notices are simply not required to obtain copyright.) But this is really just a recommendation, feel free to keep your name if you feel that attribution is a good idea.",
      "created_at": "2024-07-12T09:21:10Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675573384",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675573384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675577891",
      "pull_request_review_id": 2174199522,
      "id": 1675577891,
      "node_id": "PRRC_kwDOAP4Jqs5j30oj",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 312,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: \"vend\" is a word that I had to look up, which is a bit uncommon for me, even as a non-native speaker. Maybe you can find a more common word. Perhaps just \"provide\"?",
      "created_at": "2024-07-12T09:24:50Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675577891",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675577891"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675578061",
      "pull_request_review_id": 2174199522,
      "id": 1675578061,
      "node_id": "PRRC_kwDOAP4Jqs5j30rN",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 321,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "s/null/NULL",
      "created_at": "2024-07-12T09:24:59Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675578061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675578061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 321,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675579758",
      "pull_request_review_id": 2174287912,
      "id": 1675579758,
      "node_id": "PRRC_kwDOAP4Jqs5j31Fu",
      "diff_hunk": "@@ -63,6 +63,10 @@ static void help(int default_iters) {\n     printf(\"    ellswift_ecdh     : ECDH on ElligatorSwift keys\\n\");\n #endif\n \n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    printf(\"    silentpayments    : Silent payments recipient scanning\\n\");",
      "path": "src/bench.c",
      "position": 16,
      "original_position": 5,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Not just scanning, right?",
      "created_at": "2024-07-12T09:26:24Z",
      "updated_at": "2024-07-12T09:26:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675579758",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675579758"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 76,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675748763",
      "pull_request_review_id": 2174566516,
      "id": 1675748763,
      "node_id": "PRRC_kwDOAP4Jqs5j4eWb",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 293,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675565206,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good question! Initially, I think I was worried going from `ge -> secp256k1_pubkey -> bytes` would add extra overhead during scanning, but since then I've discovered we can go from `ge -> bytes`. I also benchmarked using `secp256k1_pubkey` vs `unsigned char` for the label callback and there was no difference in scanning.\r\n\r\nI'd say this is preferable too because now the callback function doesn't need to be aware of `secp256k1_pubkey` and it's very likely the labels will be stored in the labels cache as bytes (which would mean in the previous version the callback function would need to do the serialization, anyways).",
      "created_at": "2024-07-12T12:03:06Z",
      "updated_at": "2024-07-12T12:03:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675748763",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675748763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 290,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675750550",
      "pull_request_review_id": 2174569515,
      "id": 1675750550,
      "node_id": "PRRC_kwDOAP4Jqs5j4eyW",
      "diff_hunk": "@@ -63,6 +63,10 @@ static void help(int default_iters) {\n     printf(\"    ellswift_ecdh     : ECDH on ElligatorSwift keys\\n\");\n #endif\n \n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    printf(\"    silentpayments    : Silent payments recipient scanning\\n\");",
      "path": "src/bench.c",
      "position": 16,
      "original_position": 5,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "in_reply_to_id": 1675579758,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Currently, I only have a benchmark for the scanning function (since that's the only function were performance is absolutely critical). Perhaps I can update this to `silentpayments_scanning` ? ",
      "created_at": "2024-07-12T12:04:57Z",
      "updated_at": "2024-07-12T12:04:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675750550",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675750550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 76,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675755647",
      "pull_request_review_id": 2174577664,
      "id": 1675755647,
      "node_id": "PRRC_kwDOAP4Jqs5j4gB_",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": 1581994645,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Whoops! I think I had a local commit for this but forgot to squash it in.\r\n\r\nRegarding best practices, creating the keys in a loop seemed excessive to me but figured I'd just copy the existing examples in case there was something I wasn't understanding.\r\n\r\nConsidering this is new code, seems fine to me to break from the other examples and then I can open a separate PR to clean up the examples/API docs.",
      "created_at": "2024-07-12T12:10:01Z",
      "updated_at": "2024-07-12T12:10:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675755647",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675755647"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675765972",
      "pull_request_review_id": 2174594552,
      "id": 1675765972,
      "node_id": "PRRC_kwDOAP4Jqs5j4ijU",
      "diff_hunk": "@@ -63,6 +63,10 @@ static void help(int default_iters) {\n     printf(\"    ellswift_ecdh     : ECDH on ElligatorSwift keys\\n\");\n #endif\n \n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    printf(\"    silentpayments    : Silent payments recipient scanning\\n\");",
      "path": "src/bench.c",
      "position": 16,
      "original_position": 5,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "in_reply_to_id": 1675579758,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I only have a benchmark for the scanning function\r\n\r\nAh, nevermind, I got this wrong.",
      "created_at": "2024-07-12T12:19:53Z",
      "updated_at": "2024-07-12T12:19:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675765972",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675765972"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 76,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675769443",
      "pull_request_review_id": 2174600420,
      "id": 1675769443,
      "node_id": "PRRC_kwDOAP4Jqs5j4jZj",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+\n+    /* This will fail if B_spend + t_k*G is the point at infinity */\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    /* TODO: any concerns here with multiplying a \"secret\" by a scalar here, i.e., input_hash * a_sum\n+     * Mostly concerned about cases where a_sum is a single key and leaking information about a_sum\n+     * since input_hash can be calculated by anyone\n+     */\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 209,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674851580,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is fine. The entire scalar module treats scalars as secrets (because they typically represent secret keys).",
      "created_at": "2024-07-12T12:23:21Z",
      "updated_at": "2024-07-12T12:23:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675769443",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675769443"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 209,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675985940",
      "pull_request_review_id": 2174997157,
      "id": 1675985940,
      "node_id": "PRRC_kwDOAP4Jqs5j5YQU",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 230,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675523065,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:08:54Z",
      "updated_at": "2024-07-12T14:08:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675985940",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675985940"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986081",
      "pull_request_review_id": 2174997382,
      "id": 1675986081,
      "node_id": "PRRC_kwDOAP4Jqs5j5YSh",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 25,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675526075,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:08:59Z",
      "updated_at": "2024-07-12T14:09:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675986081",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986081"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986582",
      "pull_request_review_id": 2174998300,
      "id": 1675986582,
      "node_id": "PRRC_kwDOAP4Jqs5j5YaW",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 147,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675549354,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:09:25Z",
      "updated_at": "2024-07-12T14:09:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675986582",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986582"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 146,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986806",
      "pull_request_review_id": 2174998701,
      "id": 1675986806,
      "node_id": "PRRC_kwDOAP4Jqs5j5Yd2",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 224,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675550482,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:09:36Z",
      "updated_at": "2024-07-12T14:09:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675986806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675987377",
      "pull_request_review_id": 2174999641,
      "id": 1675987377,
      "node_id": "PRRC_kwDOAP4Jqs5j5Ymx",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 182,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675559211,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:10:00Z",
      "updated_at": "2024-07-12T14:10:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675987377",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675987377"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675987860",
      "pull_request_review_id": 2175000479,
      "id": 1675987860,
      "node_id": "PRRC_kwDOAP4Jqs5j5YuU",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 293,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675565206,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated to use `unsigned char`, thanks for the suggestion!",
      "created_at": "2024-07-12T14:10:21Z",
      "updated_at": "2024-07-12T14:10:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675987860",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675987860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 290,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988045",
      "pull_request_review_id": 2175000724,
      "id": 1675988045,
      "node_id": "PRRC_kwDOAP4Jqs5j5YxN",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 2,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675573384,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:10:29Z",
      "updated_at": "2024-07-12T14:10:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675988045",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988045"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988188",
      "pull_request_review_id": 2175000958,
      "id": 1675988188,
      "node_id": "PRRC_kwDOAP4Jqs5j5Yzc",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 312,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675577891,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:10:36Z",
      "updated_at": "2024-07-12T14:10:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675988188",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988188"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988285",
      "pull_request_review_id": 2175001128,
      "id": 1675988285,
      "node_id": "PRRC_kwDOAP4Jqs5j5Y09",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 321,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675578061,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:10:42Z",
      "updated_at": "2024-07-12T14:10:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675988285",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988285"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 321,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988636",
      "pull_request_review_id": 2175001675,
      "id": 1675988636,
      "node_id": "PRRC_kwDOAP4Jqs5j5Y6c",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_TX_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL if scanning without labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &found_outputs[i].output);\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the transaction outputs. This\n+             * means she will need to first generate an output, check if it exists in the UTXO set (e.g.\n+             * BIP158 or some other means of querying) and only proceed to check the next output (by\n+             * incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the transaction inputs and prevout information,\n+             * so she uses the `public_data` object creatd by Bob's full node earlier. This serialized `public_data` object",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 358,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675567599,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:10:58Z",
      "updated_at": "2024-07-12T14:10:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675988636",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 358,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675989403",
      "pull_request_review_id": 2175002925,
      "id": 1675989403,
      "node_id": "PRRC_kwDOAP4Jqs5j5ZGb",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_TX_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL if scanning without labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &found_outputs[i].output);\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the transaction outputs. This\n+             * means she will need to first generate an output, check if it exists in the UTXO set (e.g.\n+             * BIP158 or some other means of querying) and only proceed to check the next output (by\n+             * incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the transaction inputs and prevout information,\n+             * so she uses the `public_data` object creatd by Bob's full node earlier. This serialized `public_data` object\n+             * contains everything she needs for generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of time but we are cheating here\n+             * to keep the example simple.\n+             */\n+            unsigned char ser_found_outputs[2][32];\n+            unsigned char shared_secret[33];\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_silentpayments_public_data public_data;\n+            size_t n_found_outputs;\n+\n+            /* Load Carol's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, carol_address[1], 33);\n+            assert(ret);\n+\n+            /* Scan one output at a time, using the serialized `public_data` created by Bob's full node */\n+            ret = secp256k1_silentpayments_recipient_public_data_parse(ctx, &public_data, light_client_data33);\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_create_shared_secret(ctx,\n+                shared_secret,\n+                carol_scan_key,\n+                &public_data\n+            );\n+            assert(ret);\n+            n_found_outputs = 0;\n+            {\n+                int found = 0;\n+                size_t k = 0;\n+                secp256k1_xonly_pubkey potential_output;\n+\n+                while(1) {\n+",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 390,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675563261,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Missed this but will address in the next round of review",
      "created_at": "2024-07-12T14:11:34Z",
      "updated_at": "2024-07-12T14:11:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675989403",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675989403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 389,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675990256",
      "pull_request_review_id": 2175004301,
      "id": 1675990256,
      "node_id": "PRRC_kwDOAP4Jqs5j5ZTw",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+#!/usr/bin/env python3\n+import hashlib\n+import json\n+import sys\n+\n+import bech32m\n+import ripemd160\n+\n+NUMS_H = bytes.fromhex(\"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\")\n+MAX_INPUTS_PER_TEST_CASE = 3\n+MAX_OUTPUTS_PER_TEST_CASE = 4\n+MAX_PERMUTATIONS_PER_SENDING_TEST_CASE = 12\n+\n+def sha256(s):\n+    return hashlib.sha256(s).digest()\n+\n+def hash160(s):\n+    return ripemd160.ripemd160(sha256(s))\n+\n+def smallest_outpoint(outpoints):\n+    serialized_outpoints = [bytes.fromhex(txid)[::-1] + n.to_bytes(4, 'little') for txid, n in outpoints]\n+    return sorted(serialized_outpoints)[0]\n+\n+def decode_silent_payments_address(address):\n+    _, data = bech32m.decode(\"sp\", address)\n+    data = bytes(data)  # convert from list to bytes\n+    assert len(data) == 66\n+    return data[:33], data[33:]\n+\n+def is_p2tr(s):  # OP_1 OP_PUSHBYTES_32 <32 bytes>\n+    return (len(s) == 34) and (s[0] == 0x51) and (s[1] == 0x20)\n+\n+def is_p2wpkh(s):  # OP_0 OP_PUSHBYTES_20 <20 bytes>\n+    return (len(s) == 22) and (s[0] == 0x00) and (s[1] == 0x14)\n+\n+def is_p2sh(s):  # OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUAL\n+    return (len(s) == 23) and (s[0] == 0xA9) and (s[1] == 0x14) and (s[-1] == 0x87)\n+\n+def is_p2pkh(s):  # OP_DUP OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUALVERIFY OP_CHECKSIG\n+    return (len(s) == 25) and (s[0] == 0x76) and (s[1] == 0xA9) and (s[2] == 0x14) and \\\n+        (s[-2] == 0x88) and (s[-1] == 0xAC)\n+\n+def get_pubkey_from_input(spk, script_sig, witness):\n+    # build witness stack from raw witness data\n+    witness_stack = []\n+    no_witness_items = 0\n+    if len(witness) > 0:\n+        no_witness_items = witness[0]\n+        witness = witness[1:]\n+    for i in range(no_witness_items):\n+        item_len = witness[0]\n+        witness_stack.append(witness[1:item_len+1])\n+        witness = witness[item_len+1:]\n+\n+    if is_p2pkh(spk):\n+        spk_pkh = spk[3:3 + 20]\n+        for i in range(len(script_sig), 0, -1):\n+            if i - 33 >= 0:\n+                pk = script_sig[i - 33:i]\n+                if hash160(pk) == spk_pkh:\n+                    return pk\n+    elif is_p2sh(spk) and is_p2wpkh(script_sig[1:]):\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2wpkh(spk):\n+        # the witness must contain two items and the second item is the pubkey\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2tr(spk):\n+        if len(witness_stack) > 1 and witness_stack[-1][0] == 0x50:\n+            witness_stack.pop()\n+        if len(witness_stack) > 1:  # script-path spend?\n+            control_block = witness_stack[-1]\n+            internal_key = control_block[1:33]\n+            if internal_key == NUMS_H:  # skip\n+                return b''\n+        return spk[2:]\n+\n+    return b''\n+\n+def to_c_array(x):\n+    if x == \"\":\n+        return \"\"\n+    s = ',0x'.join(a+b for a,b in zip(x[::2], x[1::2]))\n+    return \"0x\" + s\n+\n+def emit_key_material(comment, keys, include_count=False):\n+    global out\n+    if include_count:\n+        out += f\"        {len(keys)},\" + \"\\n\"\n+    out += f\"        {{ /* {comment} */\" + \"\\n\"\n+    for i in range(MAX_INPUTS_PER_TEST_CASE):\n+        out += \"            \"\n+        if i < len(keys):\n+            out += \"{\"\n+            out += to_c_array(keys[i])\n+            out += \"}\"\n+        else:\n+            out += '\"\"'\n+        if i != MAX_INPUTS_PER_TEST_CASE - 1:\n+            out += ','",
      "path": "tools/tests_silentpayments_generate.py",
      "position": null,
      "original_position": 103,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0b6827182d29c2ca78085f0c435a87eeb9d59501",
      "in_reply_to_id": 1675543067,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "A rare instance where C89 is not evil :laughing: , will fix in the next round of review.",
      "created_at": "2024-07-12T14:12:13Z",
      "updated_at": "2024-07-12T14:12:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675990256",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675990256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 102,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675990671",
      "pull_request_review_id": 2175004870,
      "id": 1675990671,
      "node_id": "PRRC_kwDOAP4Jqs5j5ZaP",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 109,
      "original_position": 97,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674861098,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:12:29Z",
      "updated_at": "2024-07-12T14:12:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675990671",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675990671"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992250",
      "pull_request_review_id": 2175007435,
      "id": 1675992250,
      "node_id": "PRRC_kwDOAP4Jqs5j5Zy6",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+\n+    /* This will fail if B_spend + t_k*G is the point at infinity */\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    /* TODO: any concerns here with multiplying a \"secret\" by a scalar here, i.e., input_hash * a_sum\n+     * Mostly concerned about cases where a_sum is a single key and leaking information about a_sum\n+     * since input_hash can be calculated by anyone\n+     */\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 209,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674851580,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed the comment. I left a few of the other TODO comments in regarding `_cmov` and loading unsigned char secret keys into scalars because that's something I'd appreciate some eyes on / feedback.",
      "created_at": "2024-07-12T14:13:39Z",
      "updated_at": "2024-07-12T14:13:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675992250",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992250"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 209,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992709",
      "pull_request_review_id": 2175008151,
      "id": 1675992709,
      "node_id": "PRRC_kwDOAP4Jqs5j5Z6F",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 76,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674831667,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated, good call!",
      "created_at": "2024-07-12T14:14:01Z",
      "updated_at": "2024-07-12T14:14:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675992709",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992709"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992928",
      "pull_request_review_id": 2175008675,
      "id": 1675992928,
      "node_id": "PRRC_kwDOAP4Jqs5j5Z9g",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 68,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674829069,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:14:11Z",
      "updated_at": "2024-07-12T14:14:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675992928",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992928"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675993175",
      "pull_request_review_id": 2175009158,
      "id": 1675993175,
      "node_id": "PRRC_kwDOAP4Jqs5j5aBX",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 18,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674828546,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nice, fixed.",
      "created_at": "2024-07-12T14:14:24Z",
      "updated_at": "2024-07-12T14:14:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675993175",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675993175"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675995871",
      "pull_request_review_id": 2175013713,
      "id": 1675995871,
      "node_id": "PRRC_kwDOAP4Jqs5j5arf",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": 1581994645,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_Actually_ fixed this time to take out the while loop and return if it fails to create the key. ",
      "created_at": "2024-07-12T14:16:28Z",
      "updated_at": "2024-07-12T14:16:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675995871",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675995871"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676103693",
      "pull_request_review_id": 2175186854,
      "id": 1676103693,
      "node_id": "PRRC_kwDOAP4Jqs5j51AN",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": 1581994645,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "see https://github.com/bitcoin-core/secp256k1/pull/1570",
      "created_at": "2024-07-12T15:26:28Z",
      "updated_at": "2024-07-12T15:27:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1676103693",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676103693"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676183139",
      "pull_request_review_id": 2175311571,
      "id": 1676183139,
      "node_id": "PRRC_kwDOAP4Jqs5j6IZj",
      "diff_hunk": "@@ -157,6 +157,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data is can be used for scanning on the recipient side, or",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 36,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  The resulting data can be used for scanning on the recipient side, or\r\n```",
      "created_at": "2024-07-12T16:37:37Z",
      "updated_at": "2024-07-12T17:14:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1676183139",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676183139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676186434",
      "pull_request_review_id": 2175311571,
      "id": 1676186434,
      "node_id": "PRRC_kwDOAP4Jqs5j6JNC",
      "diff_hunk": "@@ -157,6 +157,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data is can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belong to",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 139,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  B_spend, and the relevant transaction outputs, scan for outputs belonging to\r\n```",
      "created_at": "2024-07-12T16:40:53Z",
      "updated_at": "2024-07-12T17:14:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1676186434",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676186434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676211210",
      "pull_request_review_id": 2175311571,
      "id": 1676211210,
      "node_id": "PRRC_kwDOAP4Jqs5j6PQK",
      "diff_hunk": "@@ -300,4 +300,304 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 60,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "could use internal function `_eckey_pubkey_serialize` instead, which accepts a group element, so the pubkey object `A_sum` is not needed anymore (verified that the tests still pass):\r\n```diff\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\nindex a1d4e15..840c9b0 100644\r\n--- a/src/modules/silentpayments/main_impl.h\r\n+++ b/src/modules/silentpayments/main_impl.h\r\n@@ -311,7 +311,6 @@ int secp256k1_silentpayments_recipient_public_data_create(\r\n ) {\r\n     size_t i;\r\n     size_t pubkeylen = 65;\r\n-    secp256k1_pubkey A_sum;\r\n     secp256k1_ge A_sum_ge, addend;\r\n     secp256k1_gej A_sum_gej;\r\n     unsigned char input_hash_local[32];\r\n@@ -353,10 +352,9 @@ int secp256k1_silentpayments_recipient_public_data_create(\r\n     /* Compute input_hash = hash(outpoint_L || A_sum) */\r\n     secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\r\n     secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\r\n-    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\r\n     /* serialize the public_data struct */\r\n     public_data->data[0] = 0;\r\n-    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);\r\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\r\n     memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\r\n     return ret;\r\n }\r\n```\r\nMaybe there are other places as well where internal functions can be used to need less variables/code.",
      "created_at": "2024-07-12T17:05:26Z",
      "updated_at": "2024-07-12T17:14:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1676211210",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676211210"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676215290",
      "pull_request_review_id": 2175311571,
      "id": 1676215290,
      "node_id": "PRRC_kwDOAP4Jqs5j6QP6",
      "diff_hunk": "@@ -300,4 +300,304 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    /* If there is something wrong with the recipient scan key or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        /* TODO: any concerns with leaking the scan key when multiplying by a publicly known scalar? */\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 166,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "seems like this TODO can be removed as well (see https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675769443).",
      "created_at": "2024-07-12T17:08:07Z",
      "updated_at": "2024-07-12T17:14:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1676215290",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676215290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 464,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 540,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115169",
      "pull_request_review_id": 2176634470,
      "id": 1677115169,
      "node_id": "PRRC_kwDOAP4Jqs5j9r8h",
      "diff_hunk": "@@ -300,4 +300,304 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    /* If there is something wrong with the recipient scan key or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        /* TODO: any concerns with leaking the scan key when multiplying by a publicly known scalar? */\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 166,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": 1676215290,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-07-14T11:33:42Z",
      "updated_at": "2024-07-14T11:33:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677115169",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 464,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 540,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115270",
      "pull_request_review_id": 2176634593,
      "id": 1677115270,
      "node_id": "PRRC_kwDOAP4Jqs5j9r-G",
      "diff_hunk": "@@ -300,4 +300,304 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 60,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": 1676211210,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch! Fixed.",
      "created_at": "2024-07-14T11:34:18Z",
      "updated_at": "2024-07-14T11:34:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677115270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115309",
      "pull_request_review_id": 2176634645,
      "id": 1677115309,
      "node_id": "PRRC_kwDOAP4Jqs5j9r-t",
      "diff_hunk": "@@ -157,6 +157,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data is can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belong to",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 139,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": 1676186434,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-14T11:34:35Z",
      "updated_at": "2024-07-14T11:34:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677115309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115328",
      "pull_request_review_id": 2176634679,
      "id": 1677115328,
      "node_id": "PRRC_kwDOAP4Jqs5j9r_A",
      "diff_hunk": "@@ -157,6 +157,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data is can be used for scanning on the recipient side, or",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 36,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": 1676183139,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-14T11:34:45Z",
      "updated_at": "2024-07-14T11:34:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677115328",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115351",
      "pull_request_review_id": 2176634718,
      "id": 1677115351,
      "node_id": "PRRC_kwDOAP4Jqs5j9r_X",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+#!/usr/bin/env python3\n+import hashlib\n+import json\n+import sys\n+\n+import bech32m\n+import ripemd160\n+\n+NUMS_H = bytes.fromhex(\"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\")\n+MAX_INPUTS_PER_TEST_CASE = 3\n+MAX_OUTPUTS_PER_TEST_CASE = 4\n+MAX_PERMUTATIONS_PER_SENDING_TEST_CASE = 12\n+\n+def sha256(s):\n+    return hashlib.sha256(s).digest()\n+\n+def hash160(s):\n+    return ripemd160.ripemd160(sha256(s))\n+\n+def smallest_outpoint(outpoints):\n+    serialized_outpoints = [bytes.fromhex(txid)[::-1] + n.to_bytes(4, 'little') for txid, n in outpoints]\n+    return sorted(serialized_outpoints)[0]\n+\n+def decode_silent_payments_address(address):\n+    _, data = bech32m.decode(\"sp\", address)\n+    data = bytes(data)  # convert from list to bytes\n+    assert len(data) == 66\n+    return data[:33], data[33:]\n+\n+def is_p2tr(s):  # OP_1 OP_PUSHBYTES_32 <32 bytes>\n+    return (len(s) == 34) and (s[0] == 0x51) and (s[1] == 0x20)\n+\n+def is_p2wpkh(s):  # OP_0 OP_PUSHBYTES_20 <20 bytes>\n+    return (len(s) == 22) and (s[0] == 0x00) and (s[1] == 0x14)\n+\n+def is_p2sh(s):  # OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUAL\n+    return (len(s) == 23) and (s[0] == 0xA9) and (s[1] == 0x14) and (s[-1] == 0x87)\n+\n+def is_p2pkh(s):  # OP_DUP OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUALVERIFY OP_CHECKSIG\n+    return (len(s) == 25) and (s[0] == 0x76) and (s[1] == 0xA9) and (s[2] == 0x14) and \\\n+        (s[-2] == 0x88) and (s[-1] == 0xAC)\n+\n+def get_pubkey_from_input(spk, script_sig, witness):\n+    # build witness stack from raw witness data\n+    witness_stack = []\n+    no_witness_items = 0\n+    if len(witness) > 0:\n+        no_witness_items = witness[0]\n+        witness = witness[1:]\n+    for i in range(no_witness_items):\n+        item_len = witness[0]\n+        witness_stack.append(witness[1:item_len+1])\n+        witness = witness[item_len+1:]\n+\n+    if is_p2pkh(spk):\n+        spk_pkh = spk[3:3 + 20]\n+        for i in range(len(script_sig), 0, -1):\n+            if i - 33 >= 0:\n+                pk = script_sig[i - 33:i]\n+                if hash160(pk) == spk_pkh:\n+                    return pk\n+    elif is_p2sh(spk) and is_p2wpkh(script_sig[1:]):\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2wpkh(spk):\n+        # the witness must contain two items and the second item is the pubkey\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2tr(spk):\n+        if len(witness_stack) > 1 and witness_stack[-1][0] == 0x50:\n+            witness_stack.pop()\n+        if len(witness_stack) > 1:  # script-path spend?\n+            control_block = witness_stack[-1]\n+            internal_key = control_block[1:33]\n+            if internal_key == NUMS_H:  # skip\n+                return b''\n+        return spk[2:]\n+\n+    return b''\n+\n+def to_c_array(x):\n+    if x == \"\":\n+        return \"\"\n+    s = ',0x'.join(a+b for a,b in zip(x[::2], x[1::2]))\n+    return \"0x\" + s\n+\n+def emit_key_material(comment, keys, include_count=False):\n+    global out\n+    if include_count:\n+        out += f\"        {len(keys)},\" + \"\\n\"\n+    out += f\"        {{ /* {comment} */\" + \"\\n\"\n+    for i in range(MAX_INPUTS_PER_TEST_CASE):\n+        out += \"            \"\n+        if i < len(keys):\n+            out += \"{\"\n+            out += to_c_array(keys[i])\n+            out += \"}\"\n+        else:\n+            out += '\"\"'\n+        if i != MAX_INPUTS_PER_TEST_CASE - 1:\n+            out += ','",
      "path": "tools/tests_silentpayments_generate.py",
      "position": null,
      "original_position": 103,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "0b6827182d29c2ca78085f0c435a87eeb9d59501",
      "in_reply_to_id": 1675543067,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-14T11:35:00Z",
      "updated_at": "2024-07-14T11:35:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677115351",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115351"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 102,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677116688",
      "pull_request_review_id": 2176635998,
      "id": 1677116688,
      "node_id": "PRRC_kwDOAP4Jqs5j9sUQ",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 200,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670566910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You would never include non-silent payment outputs when calling this module. These functions are not for general transaction construction and only for the silent payments specific logic needed during transaction construction.\r\n",
      "created_at": "2024-07-14T11:41:47Z",
      "updated_at": "2024-07-14T11:41:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677116688",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677116688"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677116792",
      "pull_request_review_id": 2176636098,
      "id": 1677116792,
      "node_id": "PRRC_kwDOAP4Jqs5j9sV4",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_TX_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL if scanning without labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &found_outputs[i].output);\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the transaction outputs. This\n+             * means she will need to first generate an output, check if it exists in the UTXO set (e.g.\n+             * BIP158 or some other means of querying) and only proceed to check the next output (by\n+             * incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the transaction inputs and prevout information,\n+             * so she uses the `public_data` object creatd by Bob's full node earlier. This serialized `public_data` object\n+             * contains everything she needs for generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of time but we are cheating here\n+             * to keep the example simple.\n+             */\n+            unsigned char ser_found_outputs[2][32];\n+            unsigned char shared_secret[33];\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_silentpayments_public_data public_data;\n+            size_t n_found_outputs;\n+\n+            /* Load Carol's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, carol_address[1], 33);\n+            assert(ret);\n+\n+            /* Scan one output at a time, using the serialized `public_data` created by Bob's full node */\n+            ret = secp256k1_silentpayments_recipient_public_data_parse(ctx, &public_data, light_client_data33);\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_create_shared_secret(ctx,\n+                shared_secret,\n+                carol_scan_key,\n+                &public_data\n+            );\n+            assert(ret);\n+            n_found_outputs = 0;\n+            {\n+                int found = 0;\n+                size_t k = 0;\n+                secp256k1_xonly_pubkey potential_output;\n+\n+                while(1) {\n+",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 390,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675563261,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-07-14T11:42:25Z",
      "updated_at": "2024-07-14T11:42:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677116792",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677116792"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 389,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677117635",
      "pull_request_review_id": 2176636938,
      "id": 1677117635,
      "node_id": "PRRC_kwDOAP4Jqs5j9sjD",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 200,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670566910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Perhaps the confusion is coming from the fact these variables are named `N_TX_INPUTS` and `N_TX_OUTPUTS` ? Considering this example is \"hardcoded\" to a set number of inputs and outputs, might as well just use numbers here instead of variables. I'll update this if I end up touching the example again.",
      "created_at": "2024-07-14T11:47:23Z",
      "updated_at": "2024-07-14T11:47:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677117635",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677117635"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1678634760",
      "pull_request_review_id": 2179013693,
      "id": 1678634760,
      "node_id": "PRRC_kwDOAP4Jqs5kDe8I",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+",
      "path": "examples/silentpayments.c",
      "position": 272,
      "original_position": 260,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "in_reply_to_id": null,
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The example file can also show how to use the `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey` function.\r\nHere is a suggestion.\r\n\r\n```suggestion\r\n{\r\n        /*** Label ***/\r\n\r\n        unsigned char label_tweak[32];\r\n        secp256k1_pubkey label;\r\n        secp256k1_pubkey labelled_spend_pubkey;\r\n        secp256k1_pubkey bob_spend_ec_pubkey;\r\n        unsigned char labelled_spend_pubkey_print[33];\r\n        size_t outputlen = 33;\r\n\r\n        ret = secp256k1_ec_pubkey_parse(ctx, &bob_spend_ec_pubkey, bob_spend_pubkey, sizeof(bob_spend_pubkey));\r\n        assert(ret);\r\n\r\n        ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx, &label, label_tweak, bob_scan_key, 1);\r\n        assert(ret);\r\n        ret = secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(ctx, &labelled_spend_pubkey, &bob_spend_ec_pubkey, &label);\r\n        assert(ret);\r\n\r\n        ret = secp256k1_ec_pubkey_serialize(ctx, labelled_spend_pubkey_print, &outputlen, &labelled_spend_pubkey, SECP256K1_EC_COMPRESSED);\r\n        assert(ret);\r\n        printf(\"Labelled Bob Spend Pubkey: \");\r\n        print_hex(labelled_spend_pubkey_print, sizeof(labelled_spend_pubkey_print));\r\n        assert(memcmp(labelled_spend_pubkey_print, bob_address[1], 33) == 0);\r\n        printf(\"It is the same as bob_address[1]. This is how we derive labeled addresses.\\n\");\r\n    }\r\n    \r\n```",
      "created_at": "2024-07-16T01:24:53Z",
      "updated_at": "2024-07-16T01:26:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1678634760",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1678634760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 272,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698662623",
      "pull_request_review_id": 2210420185,
      "id": 1698662623,
      "node_id": "PRRC_kwDOAP4Jqs5lP4jf",
      "diff_hunk": "@@ -2,28 +2,111 @@\n #define SECP256K1_SILENTPAYMENTS_H\n \n #include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n-/* This module provides an implementation for Silent Payments, as specified in BIP352.\n- * This particularly involves the creation of input tweak data by summing up private\n- * or public keys and the derivation of a shared secret using Elliptic Curve Diffie-Hellman.\n- * Combined are either:\n- *   - spender's private keys and recipient's public key (a * B, sender side)\n- *   - spender's public keys and recipient's private key (A * b, recipient side)\n- * With this result, the necessary key material for ultimately creating/scanning\n- * or spending Silent Payment outputs can be determined.\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret\n+ * using Elliptic Curve Diffie-Hellman. Combined are either: - spender's\n+ * private keys and recipient's public key (a * B, sender side) - spender's\n+ * public keys and recipient's private key (A * b, recipient side) With this\n+ * result, the necessary key material for ultimately creating/scanning or\n+ * spending Silent Payment outputs can be determined.\n  *\n  * Note that this module is _not_ a full implementation of BIP352, as it\n  * inherently doesn't deal with higher-level concepts like addresses, output\n- * script types or transactions. The intent is to provide a module for abstracting away\n- * the elliptic-curve operations required for the protocol. For any wallet software already\n- * using libsecp256k1, this API should provide all the functions needed for a Silent Payments\n- * implementation without requiring any further elliptic-curve operations from the wallet.\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol.\n+ * For any wallet software already using libsecp256k1, this API should provide\n+ * all the functions needed for a Silent Payments implementation without\n+ * requiring any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 67,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "79562d0cd116caaa160094e77245e0781b4342d7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  transaction inputs, otherwise the recipient will be unable to find the\r\n *  payment.\r\n```",
      "created_at": "2024-07-31T14:54:54Z",
      "updated_at": "2024-07-31T15:28:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1698662623",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698662623"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 55,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698665482",
      "pull_request_review_id": 2210420185,
      "id": 1698665482,
      "node_id": "PRRC_kwDOAP4Jqs5lP5QK",
      "diff_hunk": "@@ -107,6 +107,56 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m) label = label_tweak * G",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 9,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "23c7aead6374af9e6ae9128209e77304acc833d4",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "seems like a newline got lost here:\r\n```suggestion\r\n *  label_tweak = hash(b_scan || m)\r\n *  label = label_tweak * G\r\n```",
      "created_at": "2024-07-31T14:56:38Z",
      "updated_at": "2024-07-31T15:28:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1698665482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698665482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698714811",
      "pull_request_review_id": 2210420185,
      "id": 1698714811,
      "node_id": "PRRC_kwDOAP4Jqs5lQFS7",
      "diff_hunk": "@@ -7,10 +7,237 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len;\n+    int ret;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 124,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "79562d0cd116caaa160094e77245e0781b4342d7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should we check the return value of `secp256k1_pubkey_load`, here and at other places? Note sure if there's a general guideline in this library whether passed in `secp256k1_pubkey` instance parameters can be just treated as valid due to its type (after all, they must have been created before with libsecp as well) or a check is preferred as belts-and-suspenders.\r\n\r\nFor example, the ellswift module does a verification check:\r\nhttps://github.com/bitcoin-core/secp256k1/blob/fded437c4cec1a29921c90be325d62ba866f44ce/src/modules/ellswift/main_impl.h#L406\r\nwhile the ECDH module doesn't:\r\nhttps://github.com/bitcoin-core/secp256k1/blob/fded437c4cec1a29921c90be325d62ba866f44ce/src/modules/ecdh/main_impl.h#L47\r\n\r\n(Probably it also depends on the code following, haven't gone deeper there yet...)",
      "created_at": "2024-07-31T15:28:55Z",
      "updated_at": "2024-07-31T15:28:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1698714811",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698714811"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1702281913",
      "pull_request_review_id": 2216342387,
      "id": 1702281913,
      "node_id": "PRRC_kwDOAP4Jqs5ldsK5",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret\n+ * using Elliptic Curve Diffie-Hellman. Combined are either: - spender's\n+ * private keys and recipient's public key (a * B, sender side) - spender's\n+ * public keys and recipient's private key (A * b, recipient side) With this\n+ * result, the necessary key material for ultimately creating/scanning or\n+ * spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol.\n+ * For any wallet software already using libsecp256k1, this API should provide\n+ * all the functions needed for a Silent Payments implementation without\n+ * requiring any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of non-taproot inputs (can be NULL\n+ *                            if no private keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input private\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 104,
      "original_position": 101,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "in_reply_to_id": null,
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is there any reason not to make the outer pointer constant since it is not modified in this function?\r\n\r\n```suggestion\r\n    const secp256k1_silentpayments_recipient * const *recipients,\r\n```",
      "created_at": "2024-08-02T20:16:41Z",
      "updated_at": "2024-08-02T20:17:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1702281913",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1702281913"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 104,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703410080",
      "pull_request_review_id": 2217828154,
      "id": 1703410080,
      "node_id": "PRRC_kwDOAP4Jqs5lh_mg",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret\n+ * using Elliptic Curve Diffie-Hellman. Combined are either: - spender's\n+ * private keys and recipient's public key (a * B, sender side) - spender's\n+ * public keys and recipient's private key (A * b, recipient side) With this\n+ * result, the necessary key material for ultimately creating/scanning or\n+ * spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol.\n+ * For any wallet software already using libsecp256k1, this API should provide\n+ * all the functions needed for a Silent Payments implementation without\n+ * requiring any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of non-taproot inputs (can be NULL\n+ *                            if no private keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input private\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m) label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 133,
      "original_position": 129,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "in_reply_to_id": null,
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: this change makes it clear that what is expected is the secret key\r\n\r\n```suggestion\r\n    const unsigned char *recipient_scan_seckey,\r\n```",
      "created_at": "2024-08-04T22:49:14Z",
      "updated_at": "2024-08-04T22:49:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1703410080",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1703410080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 133,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705255080",
      "pull_request_review_id": 2220837779,
      "id": 1705255080,
      "node_id": "PRRC_kwDOAP4Jqs5lpCCo",
      "diff_hunk": "@@ -7,10 +7,237 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len;\n+    int ret;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 124,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "79562d0cd116caaa160094e77245e0781b4342d7",
      "in_reply_to_id": 1698714811,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`secp256k1_pubkey_load` fails if `ge->x` is zero, so in our case I think we should check the return value since the spend public key is a user supplied value and its not inconceivable someone would try to pass an illegal public key as a argument.",
      "created_at": "2024-08-06T09:53:32Z",
      "updated_at": "2024-08-06T09:53:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1705255080",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705255080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705335097",
      "pull_request_review_id": 2220969842,
      "id": 1705335097,
      "node_id": "PRRC_kwDOAP4Jqs5lpVk5",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret\n+ * using Elliptic Curve Diffie-Hellman. Combined are either: - spender's\n+ * private keys and recipient's public key (a * B, sender side) - spender's\n+ * public keys and recipient's private key (A * b, recipient side) With this\n+ * result, the necessary key material for ultimately creating/scanning or\n+ * spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol.\n+ * For any wallet software already using libsecp256k1, this API should provide\n+ * all the functions needed for a Silent Payments implementation without\n+ * requiring any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of non-taproot inputs (can be NULL\n+ *                            if no private keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input private\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 104,
      "original_position": 101,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "in_reply_to_id": 1702281913,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The recipients array is passed to `secp256k1_hsort`, where the array is sorted in place.",
      "created_at": "2024-08-06T10:58:13Z",
      "updated_at": "2024-08-06T10:58:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1705335097",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705335097"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 104,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705342098",
      "pull_request_review_id": 2220981030,
      "id": 1705342098,
      "node_id": "PRRC_kwDOAP4Jqs5lpXSS",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret\n+ * using Elliptic Curve Diffie-Hellman. Combined are either: - spender's\n+ * private keys and recipient's public key (a * B, sender side) - spender's\n+ * public keys and recipient's private key (A * b, recipient side) With this\n+ * result, the necessary key material for ultimately creating/scanning or\n+ * spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol.\n+ * For any wallet software already using libsecp256k1, this API should provide\n+ * all the functions needed for a Silent Payments implementation without\n+ * requiring any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of non-taproot inputs (can be NULL\n+ *                            if no private keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input private\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m) label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 133,
      "original_position": 129,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "in_reply_to_id": 1703410080,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The scan key isn't _really_ a secret key, so I've been trying to avoid using `seckey` in the variable names. Conceptually, a scan key is more similar to an xpub in that whoever has the scan key can find the transactions, but cannot spend them. The scan key is also safe to give to a 3rd party without loss of funds. In hindsight, we probably should have chosen a better name in the BIP e.g. scan entropy or scan code (like chain code).",
      "created_at": "2024-08-06T11:04:08Z",
      "updated_at": "2024-08-06T11:04:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1705342098",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705342098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 133,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705366285",
      "pull_request_review_id": 2221026519,
      "id": 1705366285,
      "node_id": "PRRC_kwDOAP4Jqs5lpdMN",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+",
      "path": "examples/silentpayments.c",
      "position": 272,
      "original_position": 260,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "in_reply_to_id": 1678634760,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for the suggestion! I tried a few ways to work this into the example but was never satisfied with the result. It always ended up making the example more complicated (first create bob's address, then do the sending, then do the receiving), and I don't think it adds much since this function is fairly self explanatory.",
      "created_at": "2024-08-06T11:22:11Z",
      "updated_at": "2024-08-06T11:22:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1705366285",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705366285"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 272,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705503373",
      "pull_request_review_id": 2221250021,
      "id": 1705503373,
      "node_id": "PRRC_kwDOAP4Jqs5lp-qN",
      "diff_hunk": "@@ -7,10 +7,237 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len;\n+    int ret;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 124,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "79562d0cd116caaa160094e77245e0781b4342d7",
      "in_reply_to_id": 1698714811,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added error handling for `secp256k1_pubkey_load`, since in the case of the `recipient_spend_pubkey` this is a value the caller is responsible for setting.",
      "created_at": "2024-08-06T13:04:07Z",
      "updated_at": "2024-08-06T13:04:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1705503373",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705503373"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705503620",
      "pull_request_review_id": 2221250501,
      "id": 1705503620,
      "node_id": "PRRC_kwDOAP4Jqs5lp-uE",
      "diff_hunk": "@@ -107,6 +107,56 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m) label = label_tweak * G",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 9,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "23c7aead6374af9e6ae9128209e77304acc833d4",
      "in_reply_to_id": 1698665482,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-08-06T13:04:17Z",
      "updated_at": "2024-08-06T13:04:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1705503620",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705503620"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705503883",
      "pull_request_review_id": 2221251021,
      "id": 1705503883,
      "node_id": "PRRC_kwDOAP4Jqs5lp-yL",
      "diff_hunk": "@@ -2,28 +2,111 @@\n #define SECP256K1_SILENTPAYMENTS_H\n \n #include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n-/* This module provides an implementation for Silent Payments, as specified in BIP352.\n- * This particularly involves the creation of input tweak data by summing up private\n- * or public keys and the derivation of a shared secret using Elliptic Curve Diffie-Hellman.\n- * Combined are either:\n- *   - spender's private keys and recipient's public key (a * B, sender side)\n- *   - spender's public keys and recipient's private key (A * b, recipient side)\n- * With this result, the necessary key material for ultimately creating/scanning\n- * or spending Silent Payment outputs can be determined.\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret\n+ * using Elliptic Curve Diffie-Hellman. Combined are either: - spender's\n+ * private keys and recipient's public key (a * B, sender side) - spender's\n+ * public keys and recipient's private key (A * b, recipient side) With this\n+ * result, the necessary key material for ultimately creating/scanning or\n+ * spending Silent Payment outputs can be determined.\n  *\n  * Note that this module is _not_ a full implementation of BIP352, as it\n  * inherently doesn't deal with higher-level concepts like addresses, output\n- * script types or transactions. The intent is to provide a module for abstracting away\n- * the elliptic-curve operations required for the protocol. For any wallet software already\n- * using libsecp256k1, this API should provide all the functions needed for a Silent Payments\n- * implementation without requiring any further elliptic-curve operations from the wallet.\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol.\n+ * For any wallet software already using libsecp256k1, this API should provide\n+ * all the functions needed for a Silent Payments implementation without\n+ * requiring any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 67,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "79562d0cd116caaa160094e77245e0781b4342d7",
      "in_reply_to_id": 1698662623,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2024-08-06T13:04:26Z",
      "updated_at": "2024-08-06T13:04:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1705503883",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1705503883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 55,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709578025",
      "pull_request_review_id": 2227982140,
      "id": 1709578025,
      "node_id": "PRRC_kwDOAP4Jqs5l5hcp",
      "diff_hunk": "@@ -7,10 +7,241 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len;\n+    int ret;\n+    memset(shared_secret33, 0, 33);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 68,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "31a6da2cf73675ac1daa32895177fcefa8e37133",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I think this memset can be removed, as there is no early return in this function and it's guaranteed that `shared_secret33` will be filled with the _pubkey_serialize call below",
      "created_at": "2024-08-08T14:00:55Z",
      "updated_at": "2024-08-08T17:23:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1709578025",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709578025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709585421",
      "pull_request_review_id": 2227982140,
      "id": 1709585421,
      "node_id": "PRRC_kwDOAP4Jqs5l5jQN",
      "diff_hunk": "@@ -7,10 +7,241 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len;\n+    int ret;\n+    memset(shared_secret33, 0, 33);\n+    /* By the time we call _create_shared_secret, the public_component has been created by us and validated\n+     * or loaded from a public_data object and validated, so this call will never fail\n+     */\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+}",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 84,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "31a6da2cf73675ac1daa32895177fcefa8e37133",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "could clear out the ge/gej shared secret representations at the end (with the same \"while not technically 'secret' data...\" argumentation that's already used in other functions)\r\n```suggestion\r\n    (void)ret;\r\n    secp256k1_ge_clear(&ss);\r\n    secp256k1_gej_clear(&ss_j);\r\n}\r\n```",
      "created_at": "2024-08-08T14:04:24Z",
      "updated_at": "2024-08-08T17:23:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1709585421",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709585421"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709817501",
      "pull_request_review_id": 2227982140,
      "id": 1709817501,
      "node_id": "PRRC_kwDOAP4Jqs5l6b6d",
      "diff_hunk": "@@ -244,4 +244,71 @@ int secp256k1_silentpayments_sender_create_outputs(\n     return ret;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 355,
      "original_position": 62,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "bc9ac6237fbf3f61451d2f80d9655c08b0343ccc",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should we add a check here if the result is the point at infinity and return 0?",
      "created_at": "2024-08-08T15:53:34Z",
      "updated_at": "2024-08-08T17:23:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1709817501",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709817501"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 355,
      "original_line": 355,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709903047",
      "pull_request_review_id": 2227982140,
      "id": 1709903047,
      "node_id": "PRRC_kwDOAP4Jqs5l6wzH",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occured.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *           recipient_scan_key: pointer to the recipient's scan key\n+ *                  public_data: pointer to the input public key sum\n+ *                               (optionally, with the `input_hash` multiplied\n+ *                               in, see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+  *                label_lookup: pointer to a callback function for looking up",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 164,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "6b1f86b3e5cc2e64121271ad6969097748ef67ae",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "whitespace nit\r\n```suggestion\r\n *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\r\n *                 label_lookup: pointer to a callback function for looking up\r\n```",
      "created_at": "2024-08-08T16:43:29Z",
      "updated_at": "2024-08-08T17:23:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1709903047",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709903047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 321,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709908361",
      "pull_request_review_id": 2227982140,
      "id": 1709908361,
      "node_id": "PRRC_kwDOAP4Jqs5l6yGJ",
      "diff_hunk": "@@ -311,4 +311,301 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 58,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "6b1f86b3e5cc2e64121271ad6969097748ef67ae",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "could check the return value and `pubkeylen` here if VERIFY is set (like also done in e.g. `_silentpayments_calculate_input_hash`), e.g.\r\n```suggestion\r\n    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\r\n    VERIFY_CHECK(ser_ret && pubkeylen == 65);\r\n    (void)ser_ret;\r\n```",
      "created_at": "2024-08-08T16:47:07Z",
      "updated_at": "2024-08-08T17:23:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1709908361",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709908361"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 380,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709936221",
      "pull_request_review_id": 2227982140,
      "id": 1709936221,
      "node_id": "PRRC_kwDOAP4Jqs5l645d",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 129,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "2f39991873c5d9c1e07b215e4951c0784a959794",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "missing dot nit\r\n```suggestion \r\n    /* Randomizing the context is recommended to protect against side-channel\r\n     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\r\n```",
      "created_at": "2024-08-08T17:05:16Z",
      "updated_at": "2024-08-08T17:23:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1709936221",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709936221"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 128,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709946444",
      "pull_request_review_id": 2227982140,
      "id": 1709946444,
      "node_id": "PRRC_kwDOAP4Jqs5l67ZM",
      "diff_hunk": "@@ -2,28 +2,111 @@\n #define SECP256K1_SILENTPAYMENTS_H\n \n #include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n-/* This module provides an implementation for Silent Payments, as specified in BIP352.\n- * This particularly involves the creation of input tweak data by summing up private\n- * or public keys and the derivation of a shared secret using Elliptic Curve Diffie-Hellman.\n- * Combined are either:\n- *   - spender's private keys and recipient's public key (a * B, sender side)\n- *   - spender's public keys and recipient's private key (A * b, recipient side)\n- * With this result, the necessary key material for ultimately creating/scanning\n- * or spending Silent Payment outputs can be determined.\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret\n+ * using Elliptic Curve Diffie-Hellman. Combined are either: - spender's\n+ * private keys and recipient's public key (a * B, sender side) - spender's\n+ * public keys and recipient's private key (A * b, recipient side) With this\n+ * result, the necessary key material for ultimately creating/scanning or\n+ * spending Silent Payment outputs can be determined.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 25,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "31a6da2cf73675ac1daa32895177fcefa8e37133",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "here and below: seems like these format changes should be already part of the first commit",
      "created_at": "2024-08-08T17:11:30Z",
      "updated_at": "2024-08-08T17:23:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1709946444",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1709946444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 10,
      "start_side": "LEFT",
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1722389172",
      "pull_request_review_id": 2246526213,
      "id": 1722389172,
      "node_id": "PRRC_kwDOAP4Jqs5mqZK0",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 225,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n             * It's very unlikely that the scan public key is invalid by this point, since this means the caller would\r\n```",
      "created_at": "2024-08-19T21:52:03Z",
      "updated_at": "2024-08-20T16:35:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1722389172",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1722389172"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1722442900",
      "pull_request_review_id": 2246526213,
      "id": 1722442900,
      "node_id": "PRRC_kwDOAP4Jqs5mqmSU",
      "diff_hunk": "@@ -107,6 +107,57 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding serialized labelled spend public key:",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 31,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "7229d49d1bfa2367cee54b106fead4575edc5118",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  corresponding labelled spend public key:\r\n```\r\n(I assume that's a leftover from an earlier version of the API where the resulting label was indeed serialized)",
      "created_at": "2024-08-19T22:22:44Z",
      "updated_at": "2024-08-20T16:35:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1722442900",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1722442900"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1722461616",
      "pull_request_review_id": 2246526213,
      "id": 1722461616,
      "node_id": "PRRC_kwDOAP4Jqs5mqq2w",
      "diff_hunk": "@@ -225,9 +225,36 @@ static void test_send_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 1, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n }\n \n+static void test_label_api(void) {\n+    secp256k1_pubkey l, s, ls, e; /* label pk, spend pk, labelled spend pk, expected labelled spend pk */\n+    unsigned char lt[32];         /* label tweak */\n+    const unsigned char expected[33] = {\n+        0x03,0xdc,0x7f,0x09,0x9a,0xbe,0x95,0x7a,\n+        0x58,0x43,0xd2,0xb6,0xbb,0x35,0x79,0x61,\n+        0x5c,0x60,0x36,0xa4,0x9b,0x86,0xf4,0xbe,\n+        0x46,0x38,0x60,0x28,0xa8,0x1a,0x77,0xd4,0x91\n+    };\n+\n+    /* Create a label and labelled spend public key, verify we get the expected result */\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &s, BOB_ADDRESS[1], 33));\n+    CHECK(secp256k1_silentpayments_recipient_create_label_tweak(CTX, &l, lt, ALICE_SECKEY, 1));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 16,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "7229d49d1bfa2367cee54b106fead4575edc5118",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could also check the label and label tweak results here",
      "created_at": "2024-08-19T22:33:43Z",
      "updated_at": "2024-08-20T16:35:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1722461616",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1722461616"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 240,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1722488496",
      "pull_request_review_id": 2246526213,
      "id": 1722488496,
      "node_id": "PRRC_kwDOAP4Jqs5mqxaw",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occured.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *           recipient_scan_key: pointer to the recipient's scan key\n+ *                  public_data: pointer to the input public key sum\n+ *                               (optionally, with the `input_hash` multiplied\n+ *                               in, see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a nullptr (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)\n+    SECP256K1_ARG_NONNULL(6) SECP256K1_ARG_NONNULL(7) SECP256K1_ARG_NONNULL(8);\n+\n+/** Create Silent Payment shared secret.\n+ *\n+ *  Given the public input data (secp256k1_silentpayments_public_data),\n+ *  calculate the shared secret.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 190,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  Given the public input data (secp256k1_silentpayments_public_data)\r\n *  and a recipient's scan key, calculate the shared secret.\r\n```",
      "created_at": "2024-08-19T22:57:33Z",
      "updated_at": "2024-08-20T16:35:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1722488496",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1722488496"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 346,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1722499156",
      "pull_request_review_id": 2246526213,
      "id": 1722499156,
      "node_id": "PRRC_kwDOAP4Jqs5mq0BU",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+        ret &= !overflow;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k overflows the curver order, but this is statistically improbable",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 183,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n         * This can fail if t_k overflows the curve order, but this is statistically improbable\r\n```",
      "created_at": "2024-08-19T23:18:09Z",
      "updated_at": "2024-08-20T16:35:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1722499156",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1722499156"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 504,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1723615465",
      "pull_request_review_id": 2246526213,
      "id": 1723615465,
      "node_id": "PRRC_kwDOAP4Jqs5mvEjp",
      "diff_hunk": "@@ -251,10 +271,89 @@ static void test_label_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(CTX, &ls, &s, NULL));\n }\n \n+static void test_recipient_api(void) {\n+    secp256k1_silentpayments_public_data pd;      /* public data */\n+    secp256k1_silentpayments_found_output f;      /* a silent payment found output */\n+    secp256k1_silentpayments_found_output *fp[1]; /* array of pointers to found outputs */\n+    secp256k1_xonly_pubkey t;                     /* taproot x-only public key */\n+    secp256k1_xonly_pubkey const *tp[1];          /* array of pointers to xonly pks */\n+    secp256k1_pubkey p;                           /* plain public key */\n+    secp256k1_pubkey const *pp[1];                /* array of pointers to plain pks */\n+    unsigned char o[33];                          /* serialized public data, serialized shared secret */\n+    unsigned char malformed[33] = { 0x01 };       /* malformed public key serialization */\n+    size_t n_f;                                   /* number of found outputs */\n+\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &p, BOB_ADDRESS[0], 33));\n+    CHECK(secp256k1_xonly_pubkey_parse(CTX, &t, &BOB_ADDRESS[0][1]));\n+    tp[0] = &t;\n+    pp[0] = &p;\n+    fp[0] = &f;\n+    CHECK(secp256k1_silentpayments_recipient_public_data_create(CTX, &pd, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+\n+    /* Check null values are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_create(CTX, NULL, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_create(CTX, &pd, NULL, tp, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_create(CTX, &pd, SMALLEST_OUTPOINT, NULL, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_create(CTX, &pd, SMALLEST_OUTPOINT, tp, 1, NULL, 1));\n+\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_serialize(CTX, NULL, &pd));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_serialize(CTX, o, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_parse(CTX, NULL, o));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_parse(CTX, &pd, NULL));\n+\n+    /* Check that malformed serializations are rejected */\n+    CHECK(secp256k1_silentpayments_recipient_public_data_parse(CTX, &pd, malformed) == 0);\n+\n+    /* This public_data object was created with combined = 0, i.e., it has both the input hash and summed public keypair.\n+     * In instances where the caller has access the the full transaction, they should use `_scan_outputs` instead, so\n+     * verify trying to use `_recipient_create_shared_secret` will fail */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_shared_secret(CTX, o, ALICE_SECKEY, &pd));\n+\n+    /* Parse a public_data object from a 33 byte serialization and check that trying to serialize this public_data object will fail */\n+    CHECK(secp256k1_silentpayments_recipient_public_data_parse(CTX, &pd, BOB_ADDRESS[0]));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_serialize(CTX, o, &pd));\n+    /* Try to create a shared secret with a malformed recipient scan key (all zeros) */\n+    CHECK(secp256k1_silentpayments_recipient_create_shared_secret(CTX, o, MALFORMED_SECKEY, &pd) == 0);\n+    /* Try to create a shared secret with a malformed public key (all zeros) */\n+    memset(&pd.data[1], 0, sizeof(&pd.data - 1));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 75,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this was meant to be\r\n```suggestion\r\n    memset(&pd.data[1], 0, sizeof(pd.data) - 1));\r\n```\r\n(resulting in 97, rather than 8 due to being the `sizeof` a pointer)",
      "created_at": "2024-08-20T16:27:36Z",
      "updated_at": "2024-08-20T16:35:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1723615465",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1723615465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1748098579",
      "pull_request_review_id": 2287502358,
      "id": 1748098579,
      "node_id": "PRRC_kwDOAP4Jqs5oMd4T",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            ret &= secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey);\n+            if (!ret) break;\n+            secp256k1_silentpayments_create_shared_secret(shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        ret &= secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k);\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 501,
      "original_position": 444,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could label_context (here and in the callback type) be made mutable? Is there a particular reason it is `const`?",
      "created_at": "2024-09-07T14:04:01Z",
      "updated_at": "2024-09-07T14:04:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1748098579",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1748098579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 501,
      "original_line": 501,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1748533624",
      "pull_request_review_id": 2287924957,
      "id": 1748533624,
      "node_id": "PRRC_kwDOAP4Jqs5oOIF4",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            ret &= secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey);\n+            if (!ret) break;\n+            secp256k1_silentpayments_create_shared_secret(shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        ret &= secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k);\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 501,
      "original_position": 444,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1748098579,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Does this actually disallow (make undefined behavior) mutating the context from the callback?",
      "created_at": "2024-09-07T16:01:58Z",
      "updated_at": "2024-09-07T16:01:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1748533624",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1748533624"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 501,
      "original_line": 501,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1748595895",
      "pull_request_review_id": 2287996221,
      "id": 1748595895,
      "node_id": "PRRC_kwDOAP4Jqs5oOXS3",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            ret &= secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey);\n+            if (!ret) break;\n+            secp256k1_silentpayments_create_shared_secret(shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        ret &= secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k);\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 469,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is the label_context ARG_CHECK'ed, shouldn't this be treated as opaque data for the callback alone?",
      "created_at": "2024-09-07T16:23:13Z",
      "updated_at": "2024-09-07T16:23:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1748595895",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1748595895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 465,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1749793252",
      "pull_request_review_id": 2289169904,
      "id": 1749793252,
      "node_id": "PRRC_kwDOAP4Jqs5oS7nk",
      "diff_hunk": "@@ -0,0 +1,297 @@\n+#!/usr/bin/env python3",
      "path": "tools/tests_silentpayments_generate.py",
      "position": 1,
      "original_position": 1,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "5ce0db1c124aa98f62e13274eef22765da0ee335",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "5ce0db1c124aa98f62e13274eef22765da0ee335\r\n\r\n```python\r\n+'''\r\n+A script to convert BIP352 test vectors from JSON to a C header.\r\n+\r\n+Usage:\r\n+\r\n+    ./tools/tests_silentpayments_generate.py src/modules/silentpayments/bip352_send_and_receive_test_vectors.json  > ./src/modules/silentpayments/vectors.h\r\n+'''\r\n```",
      "created_at": "2024-09-09T08:18:38Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1749793252",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1749793252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1749794907",
      "pull_request_review_id": 2289169904,
      "id": 1749794907,
      "node_id": "PRRC_kwDOAP4Jqs5oS8Bb",
      "diff_hunk": "@@ -0,0 +1,297 @@\n+#!/usr/bin/env python3\n+import hashlib\n+import json\n+import sys\n+\n+import bech32m\n+import ripemd160\n+\n+NUMS_H = bytes.fromhex(\"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\")\n+MAX_INPUTS_PER_TEST_CASE = 3\n+MAX_OUTPUTS_PER_TEST_CASE = 4\n+MAX_PERMUTATIONS_PER_SENDING_TEST_CASE = 12\n+\n+def sha256(s):\n+    return hashlib.sha256(s).digest()\n+\n+def hash160(s):\n+    return ripemd160.ripemd160(sha256(s))\n+\n+def smallest_outpoint(outpoints):\n+    serialized_outpoints = [bytes.fromhex(txid)[::-1] + n.to_bytes(4, 'little') for txid, n in outpoints]\n+    return sorted(serialized_outpoints)[0]\n+\n+def decode_silent_payments_address(address):\n+    _, data = bech32m.decode(\"sp\", address)\n+    data = bytes(data)  # convert from list to bytes\n+    assert len(data) == 66\n+    return data[:33], data[33:]\n+\n+def is_p2tr(s):  # OP_1 OP_PUSHBYTES_32 <32 bytes>\n+    return (len(s) == 34) and (s[0] == 0x51) and (s[1] == 0x20)\n+\n+def is_p2wpkh(s):  # OP_0 OP_PUSHBYTES_20 <20 bytes>\n+    return (len(s) == 22) and (s[0] == 0x00) and (s[1] == 0x14)\n+\n+def is_p2sh(s):  # OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUAL\n+    return (len(s) == 23) and (s[0] == 0xA9) and (s[1] == 0x14) and (s[-1] == 0x87)\n+\n+def is_p2pkh(s):  # OP_DUP OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUALVERIFY OP_CHECKSIG\n+    return (len(s) == 25) and (s[0] == 0x76) and (s[1] == 0xA9) and (s[2] == 0x14) and \\\n+        (s[-2] == 0x88) and (s[-1] == 0xAC)\n+\n+def get_pubkey_from_input(spk, script_sig, witness):\n+    # build witness stack from raw witness data\n+    witness_stack = []\n+    no_witness_items = 0\n+    if len(witness) > 0:\n+        no_witness_items = witness[0]\n+        witness = witness[1:]\n+    for i in range(no_witness_items):\n+        item_len = witness[0]\n+        witness_stack.append(witness[1:item_len+1])\n+        witness = witness[item_len+1:]\n+\n+    if is_p2pkh(spk):\n+        spk_pkh = spk[3:3 + 20]\n+        for i in range(len(script_sig), 0, -1):\n+            if i - 33 >= 0:\n+                pk = script_sig[i - 33:i]\n+                if hash160(pk) == spk_pkh:\n+                    return pk\n+    elif is_p2sh(spk) and is_p2wpkh(script_sig[1:]):\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2wpkh(spk):\n+        # the witness must contain two items and the second item is the pubkey\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2tr(spk):\n+        if len(witness_stack) > 1 and witness_stack[-1][0] == 0x50:\n+            witness_stack.pop()\n+        if len(witness_stack) > 1:  # script-path spend?\n+            control_block = witness_stack[-1]\n+            internal_key = control_block[1:33]\n+            if internal_key == NUMS_H:  # skip\n+                return b''\n+        return spk[2:]\n+\n+    return b''\n+\n+def to_c_array(x):\n+    if x == \"\":\n+        return \"\"\n+    s = ',0x'.join(a+b for a,b in zip(x[::2], x[1::2]))\n+    return \"0x\" + s\n+\n+def emit_key_material(comment, keys, include_count=False):\n+    global out\n+    if include_count:\n+        out += f\"        {len(keys)},\" + \"\\n\"\n+    out += f\"        {{ /* {comment} */\" + \"\\n\"\n+    for i in range(MAX_INPUTS_PER_TEST_CASE):\n+        out += \"            \"\n+        if i < len(keys):\n+            out += \"{\"\n+            out += to_c_array(keys[i])\n+            out += \"}\"\n+        else:\n+            out += '\"\"'\n+        out += \",\\n\"\n+    out +=  \"        },\\n\"\n+\n+def emit_recipient_addr_material(recipient_addresses):\n+    global out\n+    out += f\"        {len(recipient_addresses)},\" + \"\\n\"\n+    out +=  \"        { /* recipient pubkeys (address data) */\\n\"\n+    for i in range(MAX_OUTPUTS_PER_TEST_CASE):\n+        out += \"            {\\n\"\n+        if i < len(recipient_addresses):\n+            B_scan, B_spend = decode_silent_payments_address(recipient_addresses[i])\n+            out += \"                {\"\n+            out += to_c_array(B_scan.hex())\n+            out += \"},\\n\"\n+            out += \"                {\"\n+            out += to_c_array(B_spend.hex())\n+            out += \"},\\n\"\n+        else:\n+            out += '                \"\",\\n'\n+            out += '                \"\",\\n'\n+        out += \"            }\"\n+        out += \",\\n\"\n+    out += \"        },\\n\"\n+\n+def emit_sending_outputs(comment, output_sets, include_count=False):\n+    global out\n+    if include_count:\n+        out += f\"        {len(output_sets)},\" + \"\\n\"\n+        out += f\"        {len(output_sets[0])},\" + \"\\n\"\n+    if comment:\n+        out += f\"        {{ /* {comment} */\" + \"\\n\"\n+    else:\n+        out += \"         {\\n\"\n+    for i in range(MAX_PERMUTATIONS_PER_SENDING_TEST_CASE):\n+        if i < len(output_sets):\n+            emit_outputs(comment=None, outputs=output_sets[i], include_count=False, spacing=12)\n+        else:\n+            emit_outputs(comment=None, outputs=[], include_count=False, spacing=12)\n+    out += \"        }\"\n+    out += \",\"\n+    out += \"\\n\"\n+\n+def emit_outputs(comment, outputs, include_count=False, last=False, spacing=8):\n+    global out\n+    if include_count:\n+        out += spacing*\" \" + f\"{len(outputs)},\" + \"\\n\"\n+    if comment:\n+        out += spacing*\" \" + f\"{{ /* {comment} */\" + \"\\n\"\n+    else:\n+        out += spacing*\" \" + \"{\\n\"\n+    for i in range(MAX_OUTPUTS_PER_TEST_CASE):\n+        if i < len(outputs):\n+            out += spacing*\" \" + \"    {\"\n+            out += to_c_array(outputs[i])\n+            out += \"}\"\n+        else:\n+            out += spacing*' ' + '    \"\"'\n+        out += \",\\n\"\n+    out += spacing*\" \" + \"}\"\n+    if not last:\n+        out += \",\"\n+    out += \"\\n\"\n+",
      "path": "tools/tests_silentpayments_generate.py",
      "position": 173,
      "original_position": 164,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "5ce0db1c124aa98f62e13274eef22765da0ee335",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "5ce0db1c124aa98f62e13274eef22765da0ee335\r\n\r\n```python\r\nif len(sys.argv) != 2:\r\n    print(\"Usage: tests_silentpayments_generate.py vectors.json > vectors.h\")\r\n    sys.exit(1)\r\n```",
      "created_at": "2024-09-09T08:19:43Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1749794907",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1749794907"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 173,
      "original_line": 173,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1749822076",
      "pull_request_review_id": 2289169904,
      "id": 1749822076,
      "node_id": "PRRC_kwDOAP4Jqs5oTCp8",
      "diff_hunk": "@@ -0,0 +1,233 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"include/secp256k1.h\"",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 10,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f4aed4691463f9c591e147df6a0ccfbca3: You don't need this include and it breaks the cmake build.\r\n\r\n\r\n```\r\ncd build\r\ncmake .. -DSECP256K1_ENABLE_MODULE_SILENT_PAYMENTS=O\r\ncmake --build .\r\n...\r\n.../secp256k1/src/modules/silentpayments/tests_impl.h:11:10: fatal error: 'include/secp256k1.h' file not found\r\n#include \"include/secp256k1.h\"\r\n```",
      "created_at": "2024-09-09T08:35:17Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1749822076",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1749822076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1749829684",
      "pull_request_review_id": 2289169904,
      "id": 1749829684,
      "node_id": "PRRC_kwDOAP4Jqs5oTEg0",
      "diff_hunk": "@@ -188,6 +188,10 @@ AC_ARG_ENABLE(module_ellswift,\n     AS_HELP_STRING([--enable-module-ellswift],[enable ElligatorSwift module [default=yes]]), [],\n     [SECP_SET_DEFAULT([enable_module_ellswift], [yes], [yes])])\n \n+AC_ARG_ENABLE(module_silentpayments,\n+    AS_HELP_STRING([--enable-module-silentpayments],[enable Silent Payments module [default=no]]), [],",
      "path": "configure.ac",
      "position": null,
      "original_position": 5,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "1c749416ccf4878fff5d103db81dadca367c10c0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "1c749416ccf4878fff5d103db81dadca367c10c0: can we just break the convention and make it  `--enable-module-silent-payments`? :-)",
      "created_at": "2024-09-09T08:39:55Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1749829684",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1749829684"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1749953465",
      "pull_request_review_id": 2289169904,
      "id": 1749953465,
      "node_id": "PRRC_kwDOAP4Jqs5oTiu5",
      "diff_hunk": "@@ -25,6 +26,87 @@ extern \"C\" {\n  * any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 69,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f4aed4691463f9c591e147df6a0ccfbca3: the `36` suffix is weird. `outpoint36_smallest` would be slightly more clear.\r\n\r\nSuggest adding to the doc (instead):  `(36 bytes)`\r\n\r\nGiven how many times this has gone wrong, the following warning seems justified:\r\n\r\n```\r\nLexicographical sorting applies to the concatenated outpoint hash and\r\nindex (vout). The latter is little-endian encoded, so must not be\r\nsorted in its integer representation.\r\n``` \r\n\r\nThe test vector in this PR doesn't prevent this, because sorting is left to the implementer.\r\n\r\nTest vectors in the BIP don't necessary prevent this either, because implementers will assume it's all covered in libsecp.",
      "created_at": "2024-09-09T09:52:08Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1749953465",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1749953465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750022590",
      "pull_request_review_id": 2289169904,
      "id": 1750022590,
      "node_id": "PRRC_kwDOAP4Jqs5oTzm-",
      "diff_hunk": "@@ -25,6 +26,87 @@ extern \"C\" {\n  * any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 51,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f4aed4691463f9c591e147df6a0ccfbca3: the words \"matches the original ordering\" had me thoroughly confused, because I thought it referred to the _array_ order. Try instead:\r\n\r\n```\r\nThe outputs here are sorted by the index value provided in recipients. \r\n```",
      "created_at": "2024-09-09T10:42:23Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750022590",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750022590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750029044",
      "pull_request_review_id": 2289169904,
      "id": 1750029044,
      "node_id": "PRRC_kwDOAP4Jqs5oT1L0",
      "diff_hunk": "@@ -25,6 +26,87 @@ extern \"C\" {\n  * any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": 76,
      "original_position": 56,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f4aed4691463f9c591e147df6a0ccfbca3: `grouped by scan and spend key,`",
      "created_at": "2024-09-09T10:47:20Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750029044",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750029044"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 76,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750039449",
      "pull_request_review_id": 2289169904,
      "id": 1750039449,
      "node_id": "PRRC_kwDOAP4Jqs5oT3uZ",
      "diff_hunk": "@@ -25,6 +26,87 @@ extern \"C\" {\n  * any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte",
      "path": "include/secp256k1_silentpayments.h",
      "position": 94,
      "original_position": 74,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f4aed4691463f9c591e147df6a0ccfbca3: why can't this be `secp256k1_keypair` as well? If not documented in the API, at least a clarifying code comment would be useful.\r\n\r\nThe PR description implies the logic is the other way around:\r\n\r\n> taproot_seckeys are passed as keypairs to avoid the function needing to compute the public key to determine parity.\r\n\r\nSo you want to save the caller from having to use `secp256k1_keypair`? But only for legacy inputs, so that doesn't seem that useful towards the future.",
      "created_at": "2024-09-09T10:55:15Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750039449",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750039449"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 94,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750117328",
      "pull_request_review_id": 2289169904,
      "id": 1750117328,
      "node_id": "PRRC_kwDOAP4Jqs5oUKvQ",
      "diff_hunk": "@@ -52,9 +52,14 @@ option(SECP256K1_ENABLE_MODULE_RECOVERY \"Enable ECDSA pubkey recovery module.\" O\n option(SECP256K1_ENABLE_MODULE_EXTRAKEYS \"Enable extrakeys module.\" ON)\n option(SECP256K1_ENABLE_MODULE_SCHNORRSIG \"Enable schnorrsig module.\" ON)\n option(SECP256K1_ENABLE_MODULE_ELLSWIFT \"Enable ElligatorSwift module.\" ON)\n+option(SECP256K1_ENABLE_MODULE_SILENTPAYMENTS \"Enable Silent Payments module.\" OFF)",
      "path": "CMakeLists.txt",
      "position": null,
      "original_position": 4,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "1c749416ccf4878fff5d103db81dadca367c10c0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "1c749416ccf4878fff5d103db81dadca367c10c0: since the next commit adds a dependency on extrakeys, and silent payments obviously depends on schnorr:\r\n\r\n```patch\r\ndiff --git a/CMakeLists.txt b/CMakeLists.txt\r\nindex 8b450bf..f036a3f 100644\r\n--- a/CMakeLists.txt\r\n+++ b/CMakeLists.txt\r\n@@ -55,10 +55,17 @@ option(SECP256K1_ENABLE_MODULE_ELLSWIFT \"Enable ElligatorSwift module.\" ON)\r\n option(SECP256K1_ENABLE_MODULE_SILENTPAYMENTS \"Enable Silent Payments module.\" OFF)\r\n \r\n # Processing must be done in a topological sorting of the dependency graph\r\n # (dependent module first).\r\n if(SECP256K1_ENABLE_MODULE_SILENTPAYMENTS)\r\n+  if(DEFINED SECP256K1_ENABLE_MODULE_SCHNORRSIG AND NOT SECP256K1_ENABLE_MODULE_SCHNORRSIG)\r\n+    message(FATAL_ERROR \"Module dependency error: You have disabled the schnorrsig module explicitly, but it is required by the silentpayments module.\")\r\n+  endif()\r\n+  if(DEFINED SECP256K1_ENABLE_MODULE_EXTRAKEYS AND NOT SECP256K1_ENABLE_MODULE_EXTRAKEYS)\r\n+    message(FATAL_ERROR \"Module dependency error: You have disabled the extrakeys module explicitly, but it is required by the silentpayments module.\")\r\n+  endif()\r\n+  set(SECP256K1_ENABLE_MODULE_EXTRAKEYS ON)\r\n   add_compile_definitions(ENABLE_MODULE_SILENTPAYMENTS=1)\r\n endif()\r\n \r\n if(SECP256K1_ENABLE_MODULE_ELLSWIFT)\r\n   add_compile_definitions(ENABLE_MODULE_ELLSWIFT=1)\r\ndiff --git a/configure.ac b/configure.ac\r\nindex fe778b1..da6f707 100644\r\n--- a/configure.ac\r\n+++ b/configure.ac\r\n@@ -397,10 +397,20 @@ SECP_CFLAGS=\"$SECP_CFLAGS $WERROR_CFLAGS\"\r\n ###\r\n \r\n # Processing must be done in a reverse topological sorting of the dependency graph\r\n # (dependent module first).\r\n if test x\"$enable_module_silentpayments\" = x\"yes\"; then\r\n+  if test x\"$enable_module_schnorrsig\" = x\"no\"; then\r\n+    AC_MSG_ERROR([Module dependency error: You have disabled the schnorrsig module explicitly, but it is required by the silentpayments module.])\r\n+  fi\r\n+  enable_module_schnorrsig=yes\r\n+\r\n+  if test x\"$enable_module_extrakeys\" = x\"no\"; then\r\n+    AC_MSG_ERROR([Module dependency error: You have disabled the extrakeys module explicitly, but it is required by the silentpayments module.])\r\n+  fi\r\n+  enable_module_extrakeys=yes\r\n+\r\n   SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_SILENTPAYMENTS=1\"\r\n fi\r\n \r\n if test x\"$enable_module_ellswift\" = x\"yes\"; then\r\n   SECP_CONFIG_DEFINES=\"$SECP_CONFIG_DEFINES -DENABLE_MODULE_ELLSWIFT=1\"\r\n```\r\n\r\n`extrakeys` already checks for `schnorr`, but I added it an explicit check for `schnorr` because otherwise the error is confusing.\r\n\r\nTry with: \r\n* `./configure --enable-module-silentpayments --disable-module-extrakeys`\r\n* `cmake .. -DSECP256K1_ENABLE_MODULE_SILENTPAYMENTS=ON -DSECP256K1_ENABLE_MODULE_SCHNORRSIG=OFF`\r\n* etc",
      "created_at": "2024-09-09T11:52:22Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750117328",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750117328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750148052",
      "pull_request_review_id": 2289169904,
      "id": 1750148052,
      "node_id": "PRRC_kwDOAP4Jqs5oUSPU",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 15,
      "original_position": 10,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f4aed4691463f9c591e147df6a0ccfbca3: shouldn't this also sort by spend key, and use `index` as a tie breaker? It seems BIP352 is ambiguous here. IIUC it doesn't matter in the end, because the recipient is expected to reconsider all remaining outputs for each increment of k.",
      "created_at": "2024-09-09T12:15:17Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750148052",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750148052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 15,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750207837",
      "pull_request_review_id": 2289169904,
      "id": 1750207837,
      "node_id": "PRRC_kwDOAP4Jqs5oUg1d",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 200,
      "original_position": 182,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f4aed4691463f9c591e147df6a0ccfbca3: a wallet might want to use the output index here. So maybe just enforce that each number is strictly higher than the previous? Or even just uniqueness. The documentation should clarify what is expected, because libsecp errors are no fun to debug.",
      "created_at": "2024-09-09T12:54:45Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750207837",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750207837"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 200,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750229213",
      "pull_request_review_id": 2289169904,
      "id": 1750229213,
      "node_id": "PRRC_kwDOAP4Jqs5oUmDd",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 199,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f4aed4691463f9c591e147df6a0ccfbca3: My impression is that `_cmov` is used to clear `addend` in case `_load` fails. But since we don't have an early return inside the loop, might as well do it at the end of the loop.",
      "created_at": "2024-09-09T13:08:30Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750229213",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750229213"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750240569",
      "pull_request_review_id": 2289169904,
      "id": 1750240569,
      "node_id": "PRRC_kwDOAP4Jqs5oUo05",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 228,
      "original_position": 202,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could simplify the early return below by:\r\n\r\n9d6769f4aed4691463f9c591e147df6a0ccfbca3: `ret &=`",
      "created_at": "2024-09-09T13:15:25Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750240569",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750240569"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 228,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750241217",
      "pull_request_review_id": 2289169904,
      "id": 1750241217,
      "node_id": "PRRC_kwDOAP4Jqs5oUo_B",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 232,
      "original_position": 206,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f4aed4691463f9c591e147df6a0ccfbca3\r\n\r\n\r\n```c\r\nconst int zero = 0;\r\nsecp256k1_int_cmov(addend, &zero, !ret);\r\nsecp256k1_int_cmov(a_sum_scalar, &zero, !ret);\r\n\r\n/* If there are any failures ... */\r\nif (!ret) return 0;\r\n\r\n```",
      "created_at": "2024-09-09T13:15:50Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750241217",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750241217"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 232,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750358674",
      "pull_request_review_id": 2289169904,
      "id": 1750358674,
      "node_id": "PRRC_kwDOAP4Jqs5oVFqS",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 10,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: there is no `secp256k1_silentpayments_public_data_serialize`, did you mean `secp256k1_silentpayments_recipient_public_data_serialize`? Did you also mean to drop \"as a compressed public key\" (since it contains more than that)?\r\n\r\nI do think it's useful to briefly document what is in the opaque structure: the summed public key and input_hash.\r\n\r\n\r\nAlso, is there a light client use case that requires more than just tweak data? If not, then this struct could be reduced to 33 bytes. That's what the index uses.",
      "created_at": "2024-09-09T14:16:45Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750358674",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750358674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750359408",
      "pull_request_review_id": 2289169904,
      "id": 1750359408,
      "node_id": "PRRC_kwDOAP4Jqs5oVF1w",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 13,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: `secp256k1_silentpayments_recipient_public_data_parse`",
      "created_at": "2024-09-09T14:17:13Z",
      "updated_at": "2024-09-09T14:30:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1750359408",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1750359408"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751601763",
      "pull_request_review_id": 2291890621,
      "id": 1751601763,
      "node_id": "PRRC_kwDOAP4Jqs5oZ1Jj",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 10,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1750358674,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Alright, this is thoroughly confusing, but I think I figured it out.\r\n\r\nI rewrote the documentation to fix the method names and make it more clear that:\r\n1. this struct can be created in two ways\r\n2. the struct itself is not intended to be sent to light clients\r\n3. use terminology from the BIP (\"public tweak data\")\r\n\r\n```diff\r\ndiff --git a/include/secp256k1_silentpayments.h b/include/secp256k1_silentpayments.h\r\nindex 05cabb8..11164e1 100644\r\n--- a/include/secp256k1_silentpayments.h\r\n+++ b/include/secp256k1_silentpayments.h\r\n@@ -159,17 +159,20 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\r\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\r\n \r\n /** Opaque data structure that holds silent payments public input data.\r\n  *\r\n  *  This structure does not contain secret data. Guaranteed to be 98 bytes in\r\n- *  size. It can be safely copied/moved. Created with\r\n- *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\r\n- *  compressed public key using\r\n- *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\r\n- *  intended for sending the public input data to light clients. Light clients\r\n- *  can use this serialization with\r\n- *  `secp256k1_silentpayments_public_data_parse`.\r\n+ *  size. It can be safely copied/moved.\r\n+ *\r\n+ *  When the summed public key and input_hash are available, it's created using\r\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Otherwise it can be\r\n+ *  constructed from a compressed public key with the `input_hash` multiplied in\r\n+ *  (public tweak data) using secp256k1_silentpayments_recipient_public_data_parse.\r\n+ *\r\n+ *  To serve light clients, the public tweak data can generated and serialized to\r\n+ *  33 bytes using `secp256k1_silentpayments_recipient_public_data_serialize`,\r\n+ *  which they can parse with `secp256k1_silentpayments_recipient_public_data_parse`.\r\n  */\r\n typedef struct {\r\n     unsigned char data[98];\r\n```",
      "created_at": "2024-09-10T09:26:59Z",
      "updated_at": "2024-09-10T09:29:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751601763",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751601763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751661608",
      "pull_request_review_id": 2291984643,
      "id": 1751661608,
      "node_id": "PRRC_kwDOAP4Jqs5oaDwo",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 60,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: why are you doing this twice?\r\n\r\nMaybe use a compressed key? I know the struct doesn't need to be particularly small, but it seems better to use compressed keys by default unless there's a reason not to.",
      "created_at": "2024-09-10T10:05:42Z",
      "updated_at": "2024-09-10T10:05:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751661608",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751661608"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 413,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751768005",
      "pull_request_review_id": 2292150689,
      "id": 1751768005,
      "node_id": "PRRC_kwDOAP4Jqs5oadvF",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 79,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: the name of this function implies:\r\n1. That it serializes everything in the struct, which it doesn't\r\n2. That it merely serializes data, which it doesn't - it performs a hash\r\n\r\nMaybe call it `secp256k1_silentpayments_get_serialized_public_tweak_data`?\r\n\r\nAnd to make it more clear that this thing can go in the function below, you could make a:\r\n\r\n```c\r\n/** Can be sent to light clients */\r\ntypedef struct {\r\n     unsigned char public_tweak_data[33];\r\n}\r\n```",
      "created_at": "2024-09-10T11:24:51Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751768005",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751768005"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 241,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751783901",
      "pull_request_review_id": 2292150689,
      "id": 1751783901,
      "node_id": "PRRC_kwDOAP4Jqs5oahnd",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 110,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: BIP352 does not define the terms \"label tweak\" and \"label value\". I'm guessing \"tweak\" refers to `hash(bscan || m)·G`?\r\n\r\nMaybe just add \"See secp256k1_silentpayments_recipient_create_label_tweak\". From the formula there it seems that \"value\" is `B1 - Bspend`. Could call that \"tweak point\".",
      "created_at": "2024-09-10T11:37:05Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751783901",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751783901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751805479",
      "pull_request_review_id": 2292150689,
      "id": 1751805479,
      "node_id": "PRRC_kwDOAP4Jqs5oam4n",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 138,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: `, a recipient's scan key b_scan and spend public key`",
      "created_at": "2024-09-10T11:53:45Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751805479",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751805479"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751821116",
      "pull_request_review_id": 2292150689,
      "id": 1751821116,
      "node_id": "PRRC_kwDOAP4Jqs5oaqs8",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occured.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *           recipient_scan_key: pointer to the recipient's scan key\n+ *                  public_data: pointer to the input public key sum\n+ *                               (optionally, with the `input_hash` multiplied\n+ *                               in, see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a nullptr (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)\n+    SECP256K1_ARG_NONNULL(6) SECP256K1_ARG_NONNULL(7) SECP256K1_ARG_NONNULL(8);\n+\n+/** Create Silent Payment shared secret.\n+ *\n+ *  Given the public input data (secp256k1_silentpayments_public_data),\n+ *  calculate the shared secret.\n+ *\n+ *  The resulting shared secret is needed as input for creating silent payments\n+ *  outputs belonging to the same recipient scan public key. This function is\n+ *  intended for light clients, i.e., scenarios where the caller does not have\n+ *  access to the full transaction. If the caller does have access to the full\n+ *  transaction, `secp256k1_silentpayments_recipient_scan_outputs` should be\n+ *  used instead.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:       shared_secret33: pointer to the resulting 33-byte shared secret\n+ *  In:     recipient_scan_key: pointer to the recipient's scan key\n+ *                 public_data: pointer to the input public key sum, tweaked\n+ *                              with the input_hash (see\n+ *                              `_recipient_public_data_create`)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_shared_secret(",
      "path": "include/secp256k1_silentpayments.h",
      "position": 372,
      "original_position": 207,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: `derive_` instead of `create_`? (from the POV of the universe, the sender created it)\r\n\r\nDitto for `recipient_create_output_pubkey` below.",
      "created_at": "2024-09-10T12:05:04Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751821116",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751821116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 372,
      "original_line": 372,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751827569",
      "pull_request_review_id": 2292150689,
      "id": 1751827569,
      "node_id": "PRRC_kwDOAP4Jqs5oasRx",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occured.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *           recipient_scan_key: pointer to the recipient's scan key\n+ *                  public_data: pointer to the input public key sum\n+ *                               (optionally, with the `input_hash` multiplied\n+ *                               in, see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a nullptr (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)\n+    SECP256K1_ARG_NONNULL(6) SECP256K1_ARG_NONNULL(7) SECP256K1_ARG_NONNULL(8);\n+\n+/** Create Silent Payment shared secret.\n+ *\n+ *  Given the public input data (secp256k1_silentpayments_public_data),\n+ *  calculate the shared secret.\n+ *\n+ *  The resulting shared secret is needed as input for creating silent payments",
      "path": "include/secp256k1_silentpayments.h",
      "position": 357,
      "original_position": 192,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: here the word \"deriving\" would reduce confusion imo. Otherwise it's sounds like this is a sender creating an output (of a transaction).\r\n\r\nMaybe make it:\r\n\r\n```c\r\n* .. deriving silent payment\r\n* pubkeys for this recipient scan public key, which can be\r\n* matched against transaction outputs.\r\n```",
      "created_at": "2024-09-10T12:09:52Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751827569",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751827569"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 357,
      "original_line": 357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751883073",
      "pull_request_review_id": 2292150689,
      "id": 1751883073,
      "node_id": "PRRC_kwDOAP4Jqs5oa51B",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *",
      "path": "include/secp256k1_silentpayments.h",
      "position": 263,
      "original_position": 103,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: `Lookup the tweak corresponding to a tweak point.`\r\n\r\n(or something to that effect, to make it more clear why you need a lookup table)",
      "created_at": "2024-09-10T12:46:39Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751883073",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751883073"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 263,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751890155",
      "pull_request_review_id": 2292150689,
      "id": 1751890155,
      "node_id": "PRRC_kwDOAP4Jqs5oa7jr",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 265,
      "original_position": 105,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: the term \"cache\" is confusing. It implies data that you can derive yourself, but is quicker to lookup. But the function that uses this callback can't do that derivation.\r\n\r\n(from a higher level perspective it _is_ a cache, since a wallet will do the necessarily derivations just once)\r\n\r\nBetter to say \"recipients label tweak lookup table\" (as the function name does)",
      "created_at": "2024-09-10T12:51:14Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751890155",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751890155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 265,
      "original_line": 265,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751923521",
      "pull_request_review_id": 2292150689,
      "id": 1751923521,
      "node_id": "PRRC_kwDOAP4Jqs5obDtB",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 149,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: leaking privacy still sucks, and afaik the `_cmov` is super cheap. So just do it?",
      "created_at": "2024-09-10T13:12:19Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751923521",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751923521"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 501,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751926251",
      "pull_request_review_id": 2292150689,
      "id": 1751926251,
      "node_id": "PRRC_kwDOAP4Jqs5obEXr",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            ret &= secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey);\n+            if (!ret) break;\n+            secp256k1_silentpayments_create_shared_secret(shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        ret &= secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k);\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 469,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1748595895,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That means the (wallet) implementer has to make sure to perform these checks in their implementation of `secp256k1_silentpayments_label_lookup`. Seems better to do it here.",
      "created_at": "2024-09-10T13:13:41Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751926251",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751926251"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 465,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751965874",
      "pull_request_review_id": 2292150689,
      "id": 1751965874,
      "node_id": "PRRC_kwDOAP4Jqs5obOCy",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 161,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: so much for opaque datatype :-)\r\n\r\nMaybe add a helper function `secp256k1_silentpayments_recipient_public_data_get_tweak_data_scalar(&rsk_scalar, recipient_scan_key, public_data)` \r\n",
      "created_at": "2024-09-10T13:26:10Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1751965874",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1751965874"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 522,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1752011795",
      "pull_request_review_id": 2292150689,
      "id": 1752011795,
      "node_id": "PRRC_kwDOAP4Jqs5obZQT",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+        ret &= !overflow;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k overflows the curver order, but this is statistically improbable\n+         */\n+        ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 564,
      "original_position": 188,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f54299dfc83aa34bc92f9f861808449a23: could be slightly optimised by skipping over outputs where you already `found` something. But this loop seems reasonably cheap.",
      "created_at": "2024-09-10T13:45:55Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1752011795",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1752011795"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 564,
      "original_line": 564,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1752109718",
      "pull_request_review_id": 2292150689,
      "id": 1752109718,
      "node_id": "PRRC_kwDOAP4Jqs5obxKW",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+",
      "path": "examples/silentpayments.c",
      "position": 8,
      "original_position": 8,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "5c546e2874012dccc40a3e91ed2502c538a00356",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "5c546e2874012dccc40a3e91ed2502c538a00356 for cmake:\r\n\r\n```diff\r\ndiff --git a/examples/CMakeLists.txt b/examples/CMakeLists.txt\r\nindex fd1ebce..66e989e 100644\r\n--- a/examples/CMakeLists.txt\r\n+++ b/examples/CMakeLists.txt\r\n@@ -3,6 +3,7 @@ function(add_example name)\r\n   add_executable(${target_name} ${name}.c)\r\n   target_include_directories(${target_name} PRIVATE\r\n     ${PROJECT_SOURCE_DIR}/include\r\n+    ${PROJECT_SOURCE_DIR}\r\n   )\r\n   target_link_libraries(${target_name}\r\n     secp256k1\r\n@@ -32,3 +33,7 @@ endif()\r\n if(SECP256K1_ENABLE_MODULE_ELLSWIFT)\r\n   add_example(ellswift)\r\n endif()\r\n+\r\n+if(SECP256K1_ENABLE_MODULE_SILENTPAYMENTS)\r\n+  add_example(silentpayments)\r\n+endif()\r\n```\r\n\r\n```sh\r\ncmake .. -DSECP256K1_BUILD_EXAMPLES=1 -DSECP256K1_ENABLE_MODULE_SILENTPAYMENTS=1\r\n```",
      "created_at": "2024-09-10T14:32:35Z",
      "updated_at": "2024-09-10T14:37:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1752109718",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1752109718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 8,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1753671066",
      "pull_request_review_id": 2296116262,
      "id": 1753671066,
      "node_id": "PRRC_kwDOAP4Jqs5ohuWa",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            ret &= secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey);\n+            if (!ret) break;\n+            secp256k1_silentpayments_create_shared_secret(shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        ret &= secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k);\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 469,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1748595895,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That seems unnecessary, as both the callback and the context pointer are passed by the caller. If the caller wants to use global state or some other way that does not require `label_context` it should be allowed to set it to `NULL`.",
      "created_at": "2024-09-11T08:54:08Z",
      "updated_at": "2024-09-11T08:54:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1753671066",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1753671066"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 465,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796962989",
      "pull_request_review_id": 2362819079,
      "id": 1796962989,
      "node_id": "PRRC_kwDOAP4Jqs5rG3qt",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning its easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,",
      "path": "examples/silentpayments.c",
      "position": 331,
      "original_position": 330,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This `ret` is unused.",
      "created_at": "2024-10-11T13:30:38Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1796962989",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796962989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 331,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796964888",
      "pull_request_review_id": 2362819079,
      "id": 1796964888,
      "node_id": "PRRC_kwDOAP4Jqs5rG4IY",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning its easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 342,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`ret` is only checked after `ec_pubkey_serialize`.",
      "created_at": "2024-10-11T13:32:02Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1796964888",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796964888"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796965631",
      "pull_request_review_id": 2362819079,
      "id": 1796965631,
      "node_id": "PRRC_kwDOAP4Jqs5rG4T_",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning its easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objecs, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in vending this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,",
      "path": "examples/silentpayments.c",
      "position": 419,
      "original_position": 384,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`ret` is unchecked.",
      "created_at": "2024-10-11T13:32:38Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1796965631",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796965631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 419,
      "original_line": 419,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796973910",
      "pull_request_review_id": 2362819079,
      "id": 1796973910,
      "node_id": "PRRC_kwDOAP4Jqs5rG6VW",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning its easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objecs, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in vending this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx,\n+                    xonly_print,\n+                    &found_outputs[i].output\n+                );\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the\n+             * transaction outputs. This means she will need to first generate\n+             * an output, check if it exists in the UTXO set (e.g. BIP158 or\n+             * some other means of querying) and only proceed to check the next\n+             * output (by incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the\n+             * transaction inputs and prevout information, so she uses the\n+             * `public_data` object created by Bob's full node earlier. This\n+             * serialized `public_data` object contains everything she needs for\n+             * generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of\n+             * time but we are cheating here to keep the example simple.\n+             */\n+            unsigned char ser_found_outputs[2][32];\n+            unsigned char shared_secret[33];\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_silentpayments_public_data public_data;\n+            size_t n_found_outputs;\n+\n+            /* Load Carol's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &spend_pubkey,\n+                carol_address[1],\n+                33\n+            );\n+            assert(ret);\n+\n+            /* Scan one output at a time, using the serialized `public_data`\n+             * created by Bob's full node\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_parse(ctx,\n+                &public_data,\n+                light_client_data33\n+            );\n+            assert(ret);",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 443,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "IIUC `public_data` typically comes from an untrusted source, so I don't think callers want to assert this. I think there are other places in the code where an `assert` may mislead readers of the example. For example, when parsing the recipient address. It may also make sense to add a comment to `assert(n_found_outputs == 1);` explaining that this is only true in this particular test. And btw, I noticed that the number of found outputs is not asserted for Carol.",
      "created_at": "2024-10-11T13:38:55Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1796973910",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796973910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 439,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 443,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796975448",
      "pull_request_review_id": 2362819079,
      "id": 1796975448,
      "node_id": "PRRC_kwDOAP4Jqs5rG6tY",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 137,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is this called `sender_seckeys` instead of `sender_keypair`? Same in the `silentpayments.h`.",
      "created_at": "2024-10-11T13:39:59Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1796975448",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796975448"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796977800",
      "pull_request_review_id": 2362819079,
      "id": 1796977800,
      "node_id": "PRRC_kwDOAP4Jqs5rG7SI",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 141,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Why have a separate `generated_outputs` when it's identical to `tx_outputs`? If \r\n```C\r\n        for (i = 0; i < N_OUTPUTS; i++) {\r\n            tx_output_ptrs[i] = &tx_outputs[i];\r\n        }\r\n```\r\nfrom below is moved to the top, then `generated_output_ptrs` could be replaced by `tx_output_ptrs`.",
      "created_at": "2024-10-11T13:41:37Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1796977800",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796977800"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 140,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796994695",
      "pull_request_review_id": 2362819079,
      "id": 1796994695,
      "node_id": "PRRC_kwDOAP4Jqs5rG_aH",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+",
      "path": "examples/silentpayments.c",
      "position": 272,
      "original_position": 260,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "in_reply_to_id": 1678634760,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "IMHO demonstrating key generation in the example would make sense. I don't really know why it would be particularly complicated, but maybe I'm missing something. If key generation is not added, then maybe we could add a few comments to the beginning of the file, where the keys are defined.",
      "created_at": "2024-10-11T13:53:36Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1796994695",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1796994695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 272,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797000175",
      "pull_request_review_id": 2362819079,
      "id": 1797000175,
      "node_id": "PRRC_kwDOAP4Jqs5rHAvv",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning its easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 317,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit\r\n```suggestion\r\n                 *  In this case, since Bob has access to the full transaction\r\n                 *  outputs when scanning, it's easy for him to scan with labels,\r\n                 *  as demonstrated below. For efficient scanning, Bob keeps a\r\n```",
      "created_at": "2024-10-11T13:57:16Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1797000175",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797000175"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 315,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797004442",
      "pull_request_review_id": 2362819079,
      "id": 1797004442,
      "node_id": "PRRC_kwDOAP4Jqs5rHBya",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning its easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objecs, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in vending this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 368,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n            /* Bob collects the public data from the transaction inputs and\r\n             * creates a `secp256k1_silentpayments_public_data` object. He uses\r\n             * this for his own scanning and also serializes the `public_data`\r\n             * object to send to light clients. We will use this later for\r\n             * Carol, who is scanning as a light client. Note, anyone can create\r\n             * and provide these `public_data` objects, i.e. you don't need to be\r\n             * a silent payments wallet, just someone interested in vending this\r\n             * data to light clients, e.g. a wallet service provider. In our\r\n             * example, Bob is scanning for himself but also sharing this data\r\n             * with light clients.\r\n             */\r\n```\r\n\r\nnit: Also, \"vending\" sounds a bit strange.",
      "created_at": "2024-10-11T14:00:15Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1797004442",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797004442"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 358,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 392,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797053964",
      "pull_request_review_id": 2362819079,
      "id": 1797053964,
      "node_id": "PRRC_kwDOAP4Jqs5rHN4M",
      "diff_hunk": "@@ -0,0 +1,406 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret using",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 13,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "s/private/secret key for consistency with the rest of the lib",
      "created_at": "2024-10-11T14:37:51Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1797053964",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797053964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797058355",
      "pull_request_review_id": 2362819079,
      "id": 1797058355,
      "node_id": "PRRC_kwDOAP4Jqs5rHO8z",
      "diff_hunk": "@@ -0,0 +1,406 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret using\n+ * Elliptic Curve Diffie-Hellman. Combined are either:\n+ *   - spender's private keys and recipient's public key (a * B, sender side)\n+ *   - spender's public keys and recipient's private key (A * b, recipient side)\n+ * With this result, the necessary key material for ultimately creating/scanning\n+ * or spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol. For\n+ * any wallet software already using libsecp256k1, this API should provide all\n+ * the functions needed for a Silent Payments implementation without requiring\n+ * any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of non-taproot inputs (can be NULL\n+ *                            if no private keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input private\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 126,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "micronit: could be just called `secp256k1_silentpayments_recipient_create_label` to save typing because it computes  both label and tweak.",
      "created_at": "2024-10-11T14:40:56Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1797058355",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797058355"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797058734",
      "pull_request_review_id": 2362819079,
      "id": 1797058734,
      "node_id": "PRRC_kwDOAP4Jqs5rHPCu",
      "diff_hunk": "@@ -0,0 +1,406 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret using\n+ * Elliptic Curve Diffie-Hellman. Combined are either:\n+ *   - spender's private keys and recipient's public key (a * B, sender side)\n+ *   - spender's public keys and recipient's private key (A * b, recipient side)\n+ * With this result, the necessary key material for ultimately creating/scanning\n+ * or spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol. For\n+ * any wallet software already using libsecp256k1, this API should provide all\n+ * the functions needed for a Silent Payments implementation without requiring\n+ * any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of non-taproot inputs (can be NULL\n+ *                            if no private keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input private\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:   labelled_spend_pubkey: pointer to the resulting labelled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labelled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 177,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  inputs.\r\n```",
      "created_at": "2024-10-11T14:41:12Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1797058734",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797058734"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797060514",
      "pull_request_review_id": 2362819079,
      "id": 1797060514,
      "node_id": "PRRC_kwDOAP4Jqs5rHPei",
      "diff_hunk": "@@ -0,0 +1,406 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret using\n+ * Elliptic Curve Diffie-Hellman. Combined are either:\n+ *   - spender's private keys and recipient's public key (a * B, sender side)\n+ *   - spender's public keys and recipient's private key (A * b, recipient side)\n+ * With this result, the necessary key material for ultimately creating/scanning\n+ * or spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol. For\n+ * any wallet software already using libsecp256k1, this API should provide all\n+ * the functions needed for a Silent Payments implementation without requiring\n+ * any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of non-taproot inputs (can be NULL\n+ *                            if no private keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input private\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:   labelled_spend_pubkey: pointer to the resulting labelled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labelled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 295,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "maybe just \"public data\" would be clearer than \"input public sum and input_hash\".",
      "created_at": "2024-10-11T14:42:37Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1797060514",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797060514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797062982",
      "pull_request_review_id": 2362819079,
      "id": 1797062982,
      "node_id": "PRRC_kwDOAP4Jqs5rHQFG",
      "diff_hunk": "@@ -0,0 +1,406 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret using\n+ * Elliptic Curve Diffie-Hellman. Combined are either:\n+ *   - spender's private keys and recipient's public key (a * B, sender side)\n+ *   - spender's public keys and recipient's private key (A * b, recipient side)\n+ * With this result, the necessary key material for ultimately creating/scanning\n+ * or spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol. For\n+ * any wallet software already using libsecp256k1, this API should provide all\n+ * the functions needed for a Silent Payments implementation without requiring\n+ * any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of non-taproot inputs (can be NULL\n+ *                            if no private keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input private\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:   labelled_spend_pubkey: pointer to the resulting labelled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labelled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occured.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *           recipient_scan_key: pointer to the recipient's scan key\n+ *                  public_data: pointer to the input public key sum\n+ *                               (optionally, with the `input_hash` multiplied\n+ *                               in, see `_recipient_public_data_create`).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 319,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I didn't find anything in the `_recipient_public_data_create` doc that would explain this optional multiplication.",
      "created_at": "2024-10-11T14:44:33Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1797062982",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797062982"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 317,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 319,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797063662",
      "pull_request_review_id": 2362819079,
      "id": 1797063662,
      "node_id": "PRRC_kwDOAP4Jqs5rHQPu",
      "diff_hunk": "@@ -0,0 +1,406 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret using\n+ * Elliptic Curve Diffie-Hellman. Combined are either:\n+ *   - spender's private keys and recipient's public key (a * B, sender side)\n+ *   - spender's public keys and recipient's private key (A * b, recipient side)\n+ * With this result, the necessary key material for ultimately creating/scanning\n+ * or spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol. For\n+ * any wallet software already using libsecp256k1, this API should provide all\n+ * the functions needed for a Silent Payments implementation without requiring\n+ * any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of non-taproot inputs (can be NULL\n+ *                            if no private keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input private\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:   labelled_spend_pubkey: pointer to the resulting labelled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labelled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. ",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 244,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "trailing whitespace",
      "created_at": "2024-10-11T14:45:02Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1797063662",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797063662"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797064554",
      "pull_request_review_id": 2362819079,
      "id": 1797064554,
      "node_id": "PRRC_kwDOAP4Jqs5rHQdq",
      "diff_hunk": "@@ -0,0 +1,406 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret using\n+ * Elliptic Curve Diffie-Hellman. Combined are either:\n+ *   - spender's private keys and recipient's public key (a * B, sender side)\n+ *   - spender's public keys and recipient's private key (A * b, recipient side)\n+ * With this result, the necessary key material for ultimately creating/scanning\n+ * or spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol. For\n+ * any wallet software already using libsecp256k1, this API should provide all\n+ * the functions needed for a Silent Payments implementation without requiring\n+ * any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of non-taproot inputs (can be NULL\n+ *                            if no private keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input private\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:   labelled_spend_pubkey: pointer to the resulting labelled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labelled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occured.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *           recipient_scan_key: pointer to the recipient's scan key\n+ *                  public_data: pointer to the input public key sum\n+ *                               (optionally, with the `input_hash` multiplied\n+ *                               in, see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a nullptr (NULL if labels are not",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 325,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`s/nullptr/NULL pointer` would be more consistent.",
      "created_at": "2024-10-11T14:45:39Z",
      "updated_at": "2024-10-11T14:58:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1797064554",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1797064554"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 325,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1798109567",
      "pull_request_review_id": 2364836373,
      "id": 1798109567,
      "node_id": "PRRC_kwDOAP4Jqs5rLPl_",
      "diff_hunk": "@@ -0,0 +1,406 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret using\n+ * Elliptic Curve Diffie-Hellman. Combined are either:\n+ *   - spender's private keys and recipient's public key (a * B, sender side)\n+ *   - spender's public keys and recipient's private key (A * b, recipient side)\n+ * With this result, the necessary key material for ultimately creating/scanning\n+ * or spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol. For\n+ * any wallet software already using libsecp256k1, this API should provide all\n+ * the functions needed for a Silent Payments implementation without requiring\n+ * any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 29,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n/* This struct serves as an input argument for passing the silent payment address\r\n```\r\n\r\nwould be more consistent with secp256k1.h",
      "created_at": "2024-10-13T07:03:58Z",
      "updated_at": "2024-10-13T07:04:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1798109567",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1798109567"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1798109851",
      "pull_request_review_id": 2364836373,
      "id": 1798109851,
      "node_id": "PRRC_kwDOAP4Jqs5rLPqb",
      "diff_hunk": "@@ -0,0 +1,406 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret using\n+ * Elliptic Curve Diffie-Hellman. Combined are either:\n+ *   - spender's private keys and recipient's public key (a * B, sender side)\n+ *   - spender's public keys and recipient's private key (A * b, recipient side)\n+ * With this result, the necessary key material for ultimately creating/scanning\n+ * or spending Silent Payment outputs can be determined.\n+ *\n+ * Note that this module is _not_ a full implementation of BIP352, as it\n+ * inherently doesn't deal with higher-level concepts like addresses, output\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol. For\n+ * any wallet software already using libsecp256k1, this API should provide all\n+ * the functions needed for a Silent Payments implementation without requiring\n+ * any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 37,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n * When more than one recipient is used, the recipient array will be sorted in\r\n * place as part of generating the outputs, but the generated outputs will be\r\n * returned in the original ordering specified by the index to ensure the\r\n * caller is able to match up the generated outputs to the correct silent\r\n * payment address (e.g., to be able to assign the correct amounts to the\r\n```",
      "created_at": "2024-10-13T07:04:28Z",
      "updated_at": "2024-10-13T07:04:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1798109851",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1798109851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 33,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1802743923",
      "pull_request_review_id": 2371830972,
      "id": 1802743923,
      "node_id": "PRRC_kwDOAP4Jqs5rc7Bz",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 232,
      "original_position": 206,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1750241217,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@josibake says to clear the `a_sum_scalar` in early returns. Probably `addend` too.\r\n\r\n`cmove` vs `memset`: the former is constant time, but that's not always necessary.\r\n\r\nIn general the library is not always consistent when it comes to early returns. Those are often not constant time (invalid secret behaves different from valid secret).\r\n\r\ncc @jonasnick please brainstorm a bit more about this code ",
      "created_at": "2024-10-16T09:35:02Z",
      "updated_at": "2024-10-16T09:35:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1802743923",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1802743923"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 232,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1802750816",
      "pull_request_review_id": 2371841901,
      "id": 1802750816,
      "node_id": "PRRC_kwDOAP4Jqs5rc8tg",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 199,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1750229213,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Offline discussion: key pair load should never fail, because key pair object has already been validated. So constant time is not an issue here.",
      "created_at": "2024-10-16T09:39:32Z",
      "updated_at": "2024-10-16T09:39:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1802750816",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1802750816"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1802751806",
      "pull_request_review_id": 2371843238,
      "id": 1802751806,
      "node_id": "PRRC_kwDOAP4Jqs5rc88-",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 149,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1751923521,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Offline discussion: just do a memset",
      "created_at": "2024-10-16T09:40:08Z",
      "updated_at": "2024-10-16T09:40:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1802751806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1802751806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 501,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1809225280",
      "pull_request_review_id": 2382842173,
      "id": 1809225280,
      "node_id": "PRRC_kwDOAP4Jqs5r1pZA",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 232,
      "original_position": 206,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1750241217,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fwiw, we have this:\r\n https://github.com/bitcoin-core/secp256k1/blob/f0868a9b3d809565d5a6784cd16fc22c76bba63c/src/util.h#L209-L210\r\n\r\nBut AFAIU, this is \"just\" about clearing secrets from memory, and then `memset` is the right answer. (The compiler will optimize those memsets, but this PR will address this: https://github.com/bitcoin-core/secp256k1/pull/1579) No need to be constant-time in an error branch.",
      "created_at": "2024-10-21T17:32:01Z",
      "updated_at": "2024-10-21T17:32:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1809225280",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1809225280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 232,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1817350437",
      "pull_request_review_id": 2396442471,
      "id": 1817350437,
      "node_id": "PRRC_kwDOAP4Jqs5sUpEl",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 264,
      "original_position": 227,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was a bit worried about that part, because it seems that if we have 3 recipients with 2 scan_pubkeys that are not contiguous, i.e. ABA instead of AAB, we would reset k to 0 when hitting A for the second time instead of correctly incrementing k to 1, resulting in generating the same pubkey twice (assuming identical spend_key of course). \r\nI must be missing something though because I can't make the tests fail with this pattern, it seems that the same (correct) outputs are being generated regardless of the order.",
      "created_at": "2024-10-25T20:58:27Z",
      "updated_at": "2024-10-25T20:58:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1817350437",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1817350437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 264,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1817385249",
      "pull_request_review_id": 2396541122,
      "id": 1817385249,
      "node_id": "PRRC_kwDOAP4Jqs5sUxkh",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 264,
      "original_position": 227,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1817350437,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Note that a few lines above before the loop, the recipients are sorted by scan pubkey (see `secp256k1_silentpayments_recipient_sort`) in order to avoid the problem you described. The outputs are still returned in the original order, by taking use of the `index` field of the recipient structure that a user has to set in ascending order (0, 1, 2, ...).",
      "created_at": "2024-10-25T21:22:58Z",
      "updated_at": "2024-10-25T21:28:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1817385249",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1817385249"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 264,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1817715358",
      "pull_request_review_id": 2397076513,
      "id": 1817715358,
      "node_id": "PRRC_kwDOAP4Jqs5sWCKe",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 264,
      "original_position": 227,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1817350437,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You're right, nothing to see here then",
      "created_at": "2024-10-26T08:28:08Z",
      "updated_at": "2024-10-26T08:28:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1817715358",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1817715358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 264,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1817732499",
      "pull_request_review_id": 2397094351,
      "id": 1817732499,
      "node_id": "PRRC_kwDOAP4Jqs5sWGWT",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning its easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objecs, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in vending this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx,\n+                    xonly_print,\n+                    &found_outputs[i].output\n+                );\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the\n+             * transaction outputs. This means she will need to first generate\n+             * an output, check if it exists in the UTXO set (e.g. BIP158 or\n+             * some other means of querying) and only proceed to check the next\n+             * output (by incrementing `k`) if the first output exists.",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 411,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": null,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It seems that this description of the light client workflow would only work for users that don't use labels at all. While we could assume that indeed most light client users wouldn't use labels, I think we'd rather make a slighter more general example here assuming that Carol also use labels, or if we don't want to make the example more complicated at the very least explain it here in comments. Here's a quick rewriting of this paragraph based on how we made it work for Dana:\r\n```\r\n/** Being a light client, Carol likely does not have access to the\r\n* transaction outputs. This means she will need to first generate\r\n* the first outputs she would get in a transaction, meaning the output \r\n* from her plain spend_pubkey + one for each label she monitors \r\n* with _k_ == 0 , and check if it exists in the UTXO set (e.g. BIP158 or \r\n* some other means of querying).\r\n*  \r\n* As soon as she finds an output she can request the whole transaction\r\n* (or rather the whole block to not reveal which transactions \r\n* she's interested in) and use the same function than Bob from there \r\n* to find any other output that belongs to her.\r\n*  \r\n* She would then repeat this operation for each `public_data` she received\r\n*/\r\n```\r\n\r\nAlternatively I guess she could also increment _k_ when she has a match and keep looking for outputs this way, but she needs to generate the _k_+1 output for each label also. Maybe that would indeed make more sense if we go for UTXO set scanning instead of scanning each block sequentially. ",
      "created_at": "2024-10-26T09:52:52Z",
      "updated_at": "2024-10-26T09:53:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1817732499",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1817732499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 407,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 411,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1825452316",
      "pull_request_review_id": 2409505924,
      "id": 1825452316,
      "node_id": "PRRC_kwDOAP4Jqs5szjEc",
      "diff_hunk": "@@ -25,6 +26,87 @@ extern \"C\" {\n  * any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 66,
      "original_position": 46,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f: typo nit: s/occured/occurred here and in few more places in the file",
      "created_at": "2024-11-01T05:51:37Z",
      "updated_at": "2024-12-12T07:21:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1825452316",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1825452316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832613948",
      "pull_request_review_id": 2420868390,
      "id": 1832613948,
      "node_id": "PRRC_kwDOAP4Jqs5tO3g8",
      "diff_hunk": "@@ -225,9 +225,36 @@ static void test_send_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 1, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n }\n \n+static void test_label_api(void) {\n+    secp256k1_pubkey l, s, ls, e; /* label pk, spend pk, labelled spend pk, expected labelled spend pk */\n+    unsigned char lt[32];         /* label tweak */\n+    const unsigned char expected[33] = {\n+        0x03,0xdc,0x7f,0x09,0x9a,0xbe,0x95,0x7a,\n+        0x58,0x43,0xd2,0xb6,0xbb,0x35,0x79,0x61,\n+        0x5c,0x60,0x36,0xa4,0x9b,0x86,0xf4,0xbe,\n+        0x46,0x38,0x60,0x28,0xa8,0x1a,0x77,0xd4,0x91\n+    };\n+\n+    /* Create a label and labelled spend public key, verify we get the expected result */\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &s, BOB_ADDRESS[1], 33));\n+    CHECK(secp256k1_silentpayments_recipient_create_label_tweak(CTX, &l, lt, ALICE_SECKEY, 1));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 16,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "7229d49d1bfa2367cee54b106fead4575edc5118",
      "in_reply_to_id": 1722461616,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yes, although the values are used in the next call, `_create_labelled_spend_pubkey` and then the final result of that is checked against an exact expected value, so the extra checks don't seem worth the added verbosity? ",
      "created_at": "2024-11-07T12:39:15Z",
      "updated_at": "2024-11-07T12:39:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832613948",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832613948"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 240,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832625378",
      "pull_request_review_id": 2420886587,
      "id": 1832625378,
      "node_id": "PRRC_kwDOAP4Jqs5tO6Ti",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            ret &= secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey);\n+            if (!ret) break;\n+            secp256k1_silentpayments_create_shared_secret(shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        ret &= secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k);\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 501,
      "original_position": 444,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1748098579,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What would be the reason for making the pointer to label context mutable here? Making it const is meant to clearly communicate to the caller that this is meant to be a reference to some external data store. For your second question, I don't think making the pointer const prevents the lookup function itself from mutating the context, but I don't think there is a way we can prevent that. ",
      "created_at": "2024-11-07T12:47:52Z",
      "updated_at": "2024-11-07T12:47:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832625378",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832625378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 501,
      "original_line": 501,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832632525",
      "pull_request_review_id": 2420899922,
      "id": 1832632525,
      "node_id": "PRRC_kwDOAP4Jqs5tO8DN",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            ret &= secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey);\n+            if (!ret) break;\n+            secp256k1_silentpayments_create_shared_secret(shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        ret &= secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k);\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 469,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1748595895,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since the label_lookup accepts a void* pointer for the context, I think it would be fine to make passing the context optional. Perhaps the better arg check would be to do this in reverse: complain if the caller passes a context and not a lookup function. Will update.",
      "created_at": "2024-11-07T12:53:26Z",
      "updated_at": "2024-11-07T12:53:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832632525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832632525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 465,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832642026",
      "pull_request_review_id": 2420915675,
      "id": 1832642026,
      "node_id": "PRRC_kwDOAP4Jqs5tO-Xq",
      "diff_hunk": "@@ -188,6 +188,10 @@ AC_ARG_ENABLE(module_ellswift,\n     AS_HELP_STRING([--enable-module-ellswift],[enable ElligatorSwift module [default=yes]]), [],\n     [SECP_SET_DEFAULT([enable_module_ellswift], [yes], [yes])])\n \n+AC_ARG_ENABLE(module_silentpayments,\n+    AS_HELP_STRING([--enable-module-silentpayments],[enable Silent Payments module [default=no]]), [],",
      "path": "configure.ac",
      "position": null,
      "original_position": 5,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "1c749416ccf4878fff5d103db81dadca367c10c0",
      "in_reply_to_id": 1749829684,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Haha no :) ",
      "created_at": "2024-11-07T13:00:23Z",
      "updated_at": "2024-11-07T13:00:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832642026",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832642026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832646528",
      "pull_request_review_id": 2420923205,
      "id": 1832646528,
      "node_id": "PRRC_kwDOAP4Jqs5tO_eA",
      "diff_hunk": "@@ -25,6 +26,87 @@ extern \"C\" {\n  * any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 69,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1749953465,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "There was a separate discussion on the Musig2 PR that I need to follow up on regarding this, where there might be a more clever way to enforce the array length without these suffix hints. For now, I think I will remove the 36 and add it to the docs, as you suggest.\r\n\r\nAgree that we can't enforce they are passing the correct outpoint out of a list of outpoints here, but I do think we can make it clear in the header file that this is not handled by libsecp and implementations MUST ensure they are following the test vectors from the BIP. I'll add something as such to the header documentation.",
      "created_at": "2024-11-07T13:03:29Z",
      "updated_at": "2024-11-07T13:03:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832646528",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832646528"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832656056",
      "pull_request_review_id": 2420939122,
      "id": 1832656056,
      "node_id": "PRRC_kwDOAP4Jqs5tPBy4",
      "diff_hunk": "@@ -25,6 +26,87 @@ extern \"C\" {\n  * any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": 76,
      "original_position": 56,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1750029044,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this is an implementation detail the caller does not need to be aware of, since we handle the grouping internally. From a callers perspective, all they need to do is pass an array of recipients, in any order.",
      "created_at": "2024-11-07T13:10:50Z",
      "updated_at": "2024-11-07T13:10:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832656056",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832656056"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 76,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832658176",
      "pull_request_review_id": 2420942695,
      "id": 1832658176,
      "node_id": "PRRC_kwDOAP4Jqs5tPCUA",
      "diff_hunk": "@@ -25,6 +26,87 @@ extern \"C\" {\n  * any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte",
      "path": "include/secp256k1_silentpayments.h",
      "position": 94,
      "original_position": 74,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1750039449,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch, this is outdated documentation. The function does expect taproot_seckeys to be secp256k1_keypairs.",
      "created_at": "2024-11-07T13:12:27Z",
      "updated_at": "2024-11-07T13:12:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832658176",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832658176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 94,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832671218",
      "pull_request_review_id": 2420963043,
      "id": 1832671218,
      "node_id": "PRRC_kwDOAP4Jqs5tPFfy",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 15,
      "original_position": 10,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1750148052,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "When we have multiple spend keys for the same scan key, the order of the spend keys doesn't matter. We purposely did not specify a sorting order for the spend keys in BIP352 in order to avoid making clients do more work than necessary.\r\n\r\nAs you mention, the algorithm for scanning ensures it does not rely on any order dependence of the outputs to be able to find all outputs.",
      "created_at": "2024-11-07T13:21:19Z",
      "updated_at": "2024-11-07T13:21:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832671218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832671218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 15,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832674482",
      "pull_request_review_id": 2420968534,
      "id": 1832674482,
      "node_id": "PRRC_kwDOAP4Jqs5tPGSy",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 200,
      "original_position": 182,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1750207837,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "To be clear: this is not the output index from the transaction. This is an index going from `0 - r-1` where `r` represents the total number of silent payment outputs in the final transaction. There may be other non silent payment outputs in the transaction, hence this has no relation to `vout` index.",
      "created_at": "2024-11-07T13:23:34Z",
      "updated_at": "2024-11-07T13:23:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832674482",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832674482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 200,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832839256",
      "pull_request_review_id": 2421247460,
      "id": 1832839256,
      "node_id": "PRRC_kwDOAP4Jqs5tPuhY",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            ret &= secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey);\n+            if (!ret) break;\n+            secp256k1_silentpayments_create_shared_secret(shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        ret &= secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k);\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 501,
      "original_position": 444,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1748098579,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If I understand correctly (after searching online about this), the C compiler will assume that no mutation happens to the pointed to data using the pointer `label_context`, because it is declared `const`.\r\nIn Rust however, you can't prevent users from mutating captured variables of a closure. (Rust's shared references can be mutated through, still they are called immutable references.)\r\n\r\nA fix on the Rust side would be to add a level of indirection, instead of passing a pointer to the context directly, a pointer to a pointer is passed. The pointed to data of the `const void *` is never mutated (that would of type `context_t *` then, in C terms, where `context_t` is a struct defined by the user).\r\nA fix on the C side would be to remove the `const` keyword.\r\n\r\nI am fine with both, but the extra level of indirection will be slightly less performant, but modern CPU caches can make this (almost) unobservable.",
      "created_at": "2024-11-07T15:03:50Z",
      "updated_at": "2024-11-07T15:03:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832839256",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832839256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 501,
      "original_line": 501,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832846664",
      "pull_request_review_id": 2421260830,
      "id": 1832846664,
      "node_id": "PRRC_kwDOAP4Jqs5tPwVI",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            ret &= secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey);\n+            if (!ret) break;\n+            secp256k1_silentpayments_create_shared_secret(shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        ret &= secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k);\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 501,
      "original_position": 444,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1748098579,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> the C compiler will assume that no mutation happens to the pointed to data using the pointer label_context, because it is declared const.\n\nThis is, as far as I understand, not correct. A `const` pointer does not imply that the data pointed to cannot be mutated. It only means it cannot be mutated *through that pointer*.\n\nWhat is true however, is that if *all* references to an object are `const`, and the compiler can prove this, then no mutation to the object can happen to it at all. This in practice only applies to objects that are themselves declared `const`.\n\nIf the object itself is non-`const`, but you hold a `const` pointer to it, then it is perfectly legal even to cast the `const`ness of the pointer away and mutate it through that casted pointer.",
      "created_at": "2024-11-07T15:08:21Z",
      "updated_at": "2024-11-07T15:08:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832846664",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832846664"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 501,
      "original_line": 501,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832877592",
      "pull_request_review_id": 2421321250,
      "id": 1832877592,
      "node_id": "PRRC_kwDOAP4Jqs5tP34Y",
      "diff_hunk": "@@ -0,0 +1,629 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely tha the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            ret &= secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey);\n+            if (!ret) break;\n+            secp256k1_silentpayments_create_shared_secret(shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        ret &= secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k);\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label_tweak(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 501,
      "original_position": 444,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1748098579,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for the clarification!\r\n\r\n> If the object itself is non-`const`, but you hold a `const` pointer to it, then it is perfectly legal even to cast the `const`ness of the pointer away and mutate it through that casted pointer.\r\n\r\nEspecially this, this is new for me, thanks! ",
      "created_at": "2024-11-07T15:26:08Z",
      "updated_at": "2024-11-07T15:26:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832877592",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1832877592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 501,
      "original_line": 501,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1838591835",
      "pull_request_review_id": 2430408482,
      "id": 1838591835,
      "node_id": "PRRC_kwDOAP4Jqs5tlq9b",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 118,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Note that this will probably be a noop. See \"notes\" here: https://en.cppreference.com/w/c/string/byte/memset\r\n\r\nsecp has `secure_erase` in examples. Maybe that could be brought out? Surely there are other places where a cleanse is necessary?",
      "created_at": "2024-11-12T18:36:51Z",
      "updated_at": "2024-11-12T18:36:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1838591835",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1838591835"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1838606183",
      "pull_request_review_id": 2430430470,
      "id": 1838606183,
      "node_id": "PRRC_kwDOAP4Jqs5tludn",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 118,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1838591835,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "A memory cleanse function `secp256k1_memclear` is available since the recently merged #1579 (using the same memory-barrier-approach as in Bitcoin Core) and should be used for that purpose.",
      "created_at": "2024-11-12T18:48:47Z",
      "updated_at": "2024-11-12T18:48:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1838606183",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1838606183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1838709428",
      "pull_request_review_id": 2430594340,
      "id": 1838709428,
      "node_id": "PRRC_kwDOAP4Jqs5tmHq0",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 118,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1838591835,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Aha, perfect, thanks! I was grepping on an old branch and missed this.",
      "created_at": "2024-11-12T20:09:21Z",
      "updated_at": "2024-11-12T20:09:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1838709428",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1838709428"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842166725",
      "pull_request_review_id": 2435995497,
      "id": 1842166725,
      "node_id": "PRRC_kwDOAP4Jqs5tzTvF",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 10,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1750358674,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I updated the name of the struct to be `silentpayments_recipient_public_data` and updated the documentation to have consistent naming.\r\n\r\nOn the doc rewrite, I'm not convinced this is better. It mentions `input_hash` explicitly, which is an implementation detail internal to the module, and also mentions some of the low-level operations going on inside the functions, which I don't think we should be exposing/explaining to the caller here. To me, it seems sufficient to tell the caller: \"hey, create a public data object using this function. If you're a light client and receive a previously created, serialised public data object, parse it with this function.\"\r\n\r\nGoing to leave the documentation as is for now, but would be interested to hear others thoughts on this.",
      "created_at": "2024-11-14T12:48:43Z",
      "updated_at": "2024-11-14T12:48:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1842166725",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842166725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842195445",
      "pull_request_review_id": 2436042595,
      "id": 1842195445,
      "node_id": "PRRC_kwDOAP4Jqs5tzav1",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 79,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1751768005,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I would argue it does serialise everything in the struct: it takes a public_data object and returns the serialised format, which is 33 bytes. Also, this function does not do a hash. The `input_hash` part of the object is created when the public data object is created.",
      "created_at": "2024-11-14T13:09:51Z",
      "updated_at": "2024-11-14T13:09:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1842195445",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842195445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 241,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842210867",
      "pull_request_review_id": 2436067568,
      "id": 1842210867,
      "node_id": "PRRC_kwDOAP4Jqs5tzegz",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 110,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1751783901,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I changed the language to \"label pubkey,\" as this is more consistent with where it is used elsewhere. Also added a reference to the `secp256k1_silentpayments_recipient_create_label_tweak` function per your suggestion.",
      "created_at": "2024-11-14T13:20:41Z",
      "updated_at": "2024-11-14T13:20:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1842210867",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842210867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842217471",
      "pull_request_review_id": 2436078486,
      "id": 1842217471,
      "node_id": "PRRC_kwDOAP4Jqs5tzgH_",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occured.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *           recipient_scan_key: pointer to the recipient's scan key\n+ *                  public_data: pointer to the input public key sum\n+ *                               (optionally, with the `input_hash` multiplied\n+ *                               in, see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a nullptr (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)\n+    SECP256K1_ARG_NONNULL(6) SECP256K1_ARG_NONNULL(7) SECP256K1_ARG_NONNULL(8);\n+\n+/** Create Silent Payment shared secret.\n+ *\n+ *  Given the public input data (secp256k1_silentpayments_public_data),\n+ *  calculate the shared secret.\n+ *\n+ *  The resulting shared secret is needed as input for creating silent payments\n+ *  outputs belonging to the same recipient scan public key. This function is\n+ *  intended for light clients, i.e., scenarios where the caller does not have\n+ *  access to the full transaction. If the caller does have access to the full\n+ *  transaction, `secp256k1_silentpayments_recipient_scan_outputs` should be\n+ *  used instead.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:       shared_secret33: pointer to the resulting 33-byte shared secret\n+ *  In:     recipient_scan_key: pointer to the recipient's scan key\n+ *                 public_data: pointer to the input public key sum, tweaked\n+ *                              with the input_hash (see\n+ *                              `_recipient_public_data_create`)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_shared_secret(",
      "path": "include/secp256k1_silentpayments.h",
      "position": 372,
      "original_position": 207,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1751821116,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Slightly prefer create, as I want to avoid any confusion with bip32 style derivation. From the recipients perspective, they are also creating a shared secret per the spec. Its only after scanning with the shared secret that they can confirm this transaction was indeed a silent payment (i.e., the sender created a shared secret and outputs from that shared secret).",
      "created_at": "2024-11-14T13:25:05Z",
      "updated_at": "2024-11-14T13:25:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1842217471",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842217471"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 372,
      "original_line": 372,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842219099",
      "pull_request_review_id": 2436081011,
      "id": 1842219099,
      "node_id": "PRRC_kwDOAP4Jqs5tzghb",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occured.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *           recipient_scan_key: pointer to the recipient's scan key\n+ *                  public_data: pointer to the input public key sum\n+ *                               (optionally, with the `input_hash` multiplied\n+ *                               in, see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a nullptr (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)\n+    SECP256K1_ARG_NONNULL(6) SECP256K1_ARG_NONNULL(7) SECP256K1_ARG_NONNULL(8);\n+\n+/** Create Silent Payment shared secret.\n+ *\n+ *  Given the public input data (secp256k1_silentpayments_public_data),\n+ *  calculate the shared secret.\n+ *\n+ *  The resulting shared secret is needed as input for creating silent payments",
      "path": "include/secp256k1_silentpayments.h",
      "position": 357,
      "original_position": 192,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1751827569,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Same comment as above, derived is heavily associated with BIP32 style public key/private key derivation, so I want to avoid using it here as much as possible.",
      "created_at": "2024-11-14T13:26:10Z",
      "updated_at": "2024-11-14T13:26:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1842219099",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842219099"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 357,
      "original_line": 357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842226727",
      "pull_request_review_id": 2436093139,
      "id": 1842226727,
      "node_id": "PRRC_kwDOAP4Jqs5tziYn",
      "diff_hunk": "@@ -158,6 +158,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 265,
      "original_position": 105,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1751890155,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think cache is appropriate here? As you mention, the wallet could derive this itself for each scan, but better to derive once and cache the results. \"Lookup table\" implies a specific data structure to me, which is something I'd like to avoid.",
      "created_at": "2024-11-14T13:31:16Z",
      "updated_at": "2024-11-14T13:31:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1842226727",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842226727"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 265,
      "original_line": 265,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842228257",
      "pull_request_review_id": 2436095718,
      "id": 1842228257,
      "node_id": "PRRC_kwDOAP4Jqs5tziwh",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 161,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1751965874,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It is opaque to users of the library :) Not sure I see the value of creating a separate function that is not exposed in the public API and only used internally?",
      "created_at": "2024-11-14T13:32:26Z",
      "updated_at": "2024-11-14T13:32:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1842228257",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842228257"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 522,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842229493",
      "pull_request_review_id": 2436097705,
      "id": 1842229493,
      "node_id": "PRRC_kwDOAP4Jqs5tzjD1",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+        ret &= !overflow;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k overflows the curver order, but this is statistically improbable\n+         */\n+        ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 564,
      "original_position": 188,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1752011795,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Had considered this! However, this is only relevant for large transactions with many outputs, where multiple outputs are created for the same recipient. For now, I think I'll leave this for a follow up.",
      "created_at": "2024-11-14T13:33:16Z",
      "updated_at": "2024-11-14T13:33:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1842229493",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1842229493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 564,
      "original_line": 564,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1845502698",
      "pull_request_review_id": 2441070156,
      "id": 1845502698,
      "node_id": "PRRC_kwDOAP4Jqs5uACLq",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 60,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1751661608,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good catch, because I am a dum dum! I think the first line is left over from when I added the ser_ret check.",
      "created_at": "2024-11-17T16:00:12Z",
      "updated_at": "2024-11-17T16:00:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1845502698",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1845502698"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 413,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1845537159",
      "pull_request_review_id": 2441102561,
      "id": 1845537159,
      "node_id": "PRRC_kwDOAP4Jqs5uAKmH",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 141,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1796977800,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good point, will simplify to use only `tx_outputs`.",
      "created_at": "2024-11-17T17:07:05Z",
      "updated_at": "2024-11-17T17:07:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1845537159",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1845537159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 140,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1845545917",
      "pull_request_review_id": 2441111295,
      "id": 1845545917,
      "node_id": "PRRC_kwDOAP4Jqs5uAMu9",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning its easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objecs, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in vending this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx,\n+                    xonly_print,\n+                    &found_outputs[i].output\n+                );\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the\n+             * transaction outputs. This means she will need to first generate\n+             * an output, check if it exists in the UTXO set (e.g. BIP158 or\n+             * some other means of querying) and only proceed to check the next\n+             * output (by incrementing `k`) if the first output exists.",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 411,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1817732499,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is a good call out. I added a sentence to indicate that, while its not recommended, Carol can still uses labels as a light client using the addition method.",
      "created_at": "2024-11-17T17:34:50Z",
      "updated_at": "2024-11-17T17:34:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1845545917",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1845545917"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 407,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 411,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1845546059",
      "pull_request_review_id": 2441111416,
      "id": 1845546059,
      "node_id": "PRRC_kwDOAP4Jqs5uAMxL",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning its easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objecs, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in vending this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx,\n+                    xonly_print,\n+                    &found_outputs[i].output\n+                );\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the\n+             * transaction outputs. This means she will need to first generate\n+             * an output, check if it exists in the UTXO set (e.g. BIP158 or\n+             * some other means of querying) and only proceed to check the next\n+             * output (by incrementing `k`) if the first output exists.",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 411,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1817732499,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think another reason I didn't include light client labels is because this would require a function for adding arbitrary public keys, which at this point we are trying to avoid.",
      "created_at": "2024-11-17T17:35:39Z",
      "updated_at": "2024-11-17T17:35:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1845546059",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1845546059"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 407,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 411,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1861675499",
      "pull_request_review_id": 2467004551,
      "id": 1861675499,
      "node_id": "PRRC_kwDOAP4Jqs5u9unr",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning its easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objecs, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in vending this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx,\n+                    xonly_print,\n+                    &found_outputs[i].output\n+                );\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the\n+             * transaction outputs. This means she will need to first generate\n+             * an output, check if it exists in the UTXO set (e.g. BIP158 or\n+             * some other means of querying) and only proceed to check the next\n+             * output (by incrementing `k`) if the first output exists.",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 411,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "f42e0dde59943ad0c9247c61f7af521b70838e8f",
      "in_reply_to_id": 1817732499,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes I agree it's kind of an edge case and we want to be careful not to compromise too much because of it, but on the other hand we should acknowledge it because it will definitely happen I think. I'll try to complete the tests on that part and see how bad it makes things",
      "created_at": "2024-11-28T08:02:06Z",
      "updated_at": "2024-11-28T08:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1861675499",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1861675499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 407,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 411,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1865802534",
      "pull_request_review_id": 2409505924,
      "id": 1865802534,
      "node_id": "PRRC_kwDOAP4Jqs5vNeMm",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 102,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f: micro nit: might make sense to add const qualifier to the int too. also for the int in other functions - `secp256k1_silentpayments_recipient_create_output_pubkey`, `secp256k1_silentpayments_recipient_create_label_tweak`, `secp256k1_silentpayments_create_output_pubkey`",
      "created_at": "2024-12-02T12:57:03Z",
      "updated_at": "2024-12-12T07:21:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1865802534",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1865802534"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1867298266",
      "pull_request_review_id": 2409505924,
      "id": 1867298266,
      "node_id": "PRRC_kwDOAP4Jqs5vTLXa",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 217,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f: BIP sounds like it ignores overflow in https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki#creating-outputs. though everywhere in the code `input_hash` overflow would lead to failure. It's a very unlikely scenario and not sure which option is preferable, but would be nice to keep BIP and code consistent.",
      "created_at": "2024-12-03T08:59:56Z",
      "updated_at": "2024-12-12T07:21:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1867298266",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1867298266"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1867298891",
      "pull_request_review_id": 2409505924,
      "id": 1867298891,
      "node_id": "PRRC_kwDOAP4Jqs5vTLhL",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 113,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f: BIP says to fail If t_k is not valid tweak - https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki#creating-outputs\r\nhere, we're ignoring the overflow. we could keep it consistent with the BIP?\r\n\r\n(have a [similar comment](https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1881383032) in call site of `secp256k1_silentpayments_create_t_k`)",
      "created_at": "2024-12-03T09:00:22Z",
      "updated_at": "2024-12-12T07:41:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1867298891",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1867298891"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1870929054",
      "pull_request_review_id": 2409505924,
      "id": 1870929054,
      "node_id": "PRRC_kwDOAP4Jqs5vhBye",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 462,
      "original_position": 87,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f: typo nit:\r\n```suggestion\r\n     * This helps protect against accidentally serializing just the summed public key A\r\n```",
      "created_at": "2024-12-05T08:52:14Z",
      "updated_at": "2024-12-12T07:21:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1870929054",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1870929054"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 462,
      "original_line": 462,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1870942231",
      "pull_request_review_id": 2409505924,
      "id": 1870942231,
      "node_id": "PRRC_kwDOAP4Jqs5vhFAX",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 93,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f: micro nit: could add `VERIFY_CHECK(pubkeylen == 33)`",
      "created_at": "2024-12-05T09:01:37Z",
      "updated_at": "2024-12-12T07:21:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1870942231",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1870942231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 446,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1871314017",
      "pull_request_review_id": 2409505924,
      "id": 1871314017,
      "node_id": "PRRC_kwDOAP4Jqs5vifxh",
      "diff_hunk": "@@ -251,10 +271,89 @@ static void test_label_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(CTX, &ls, &s, NULL));\n }\n \n+static void test_recipient_api(void) {\n+    secp256k1_silentpayments_public_data pd;      /* public data */\n+    secp256k1_silentpayments_found_output f;      /* a silent payment found output */\n+    secp256k1_silentpayments_found_output *fp[1]; /* array of pointers to found outputs */\n+    secp256k1_xonly_pubkey t;                     /* taproot x-only public key */\n+    secp256k1_xonly_pubkey const *tp[1];          /* array of pointers to xonly pks */\n+    secp256k1_pubkey p;                           /* plain public key */\n+    secp256k1_pubkey const *pp[1];                /* array of pointers to plain pks */\n+    unsigned char o[33];                          /* serialized public data, serialized shared secret */\n+    unsigned char malformed[33] = { 0x01 };       /* malformed public key serialization */\n+    size_t n_f;                                   /* number of found outputs */\n+\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &p, BOB_ADDRESS[0], 33));\n+    CHECK(secp256k1_xonly_pubkey_parse(CTX, &t, &BOB_ADDRESS[0][1]));\n+    tp[0] = &t;\n+    pp[0] = &p;\n+    fp[0] = &f;\n+    CHECK(secp256k1_silentpayments_recipient_public_data_create(CTX, &pd, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+\n+    /* Check null values are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_create(CTX, NULL, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_create(CTX, &pd, NULL, tp, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_create(CTX, &pd, SMALLEST_OUTPOINT, NULL, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_create(CTX, &pd, SMALLEST_OUTPOINT, tp, 1, NULL, 1));\n+\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_serialize(CTX, NULL, &pd));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_serialize(CTX, o, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_parse(CTX, NULL, o));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_public_data_parse(CTX, &pd, NULL));\n+\n+    /* Check that malformed serializations are rejected */\n+    CHECK(secp256k1_silentpayments_recipient_public_data_parse(CTX, &pd, malformed) == 0);\n+\n+    /* This public_data object was created with combined = 0, i.e., it has both the input hash and summed public keypair.\n+     * In instances where the caller has access the the full transaction, they should use `_scan_outputs` instead, so",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 337,
      "original_position": 65,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f:\r\n```suggestion\r\n     * In instances where the caller has access to the full transaction, they should use `_scan_outputs` instead, so\r\n```",
      "created_at": "2024-12-05T12:41:41Z",
      "updated_at": "2024-12-12T07:21:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1871314017",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1871314017"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 337,
      "original_line": 337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1874823508",
      "pull_request_review_id": 2409505924,
      "id": 1874823508,
      "node_id": "PRRC_kwDOAP4Jqs5vv4lU",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 537,
      "original_position": 162,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f: I think comments here would be useful! (thanks @theStack  for explaining the intuition behind this!)\r\n\r\nmaybe something like:\r\n```\r\n/**\r\n    * If combined is set, pubkey in `public_data` contains input_hash * pubkey. Save an extra point multiplication\r\n    * by only having to compute shared_secret = recipient_scan_key * (input_hash * pubkey).\r\n    * \r\n    * If combined is not set, update recipient_scan_key to contain recipient_scan_key * input_hash and then compute\r\n    * shared_secret = (recipient_scan_key * input_hash) * pubkey.\r\n*/\r\n```\r\nEDIT: part I got confused with was I thought everyone could do (recipient_scan_key * input_hash) but light clients wouldn't be able to since they don't have access to summed pubkey, input_hash(computed from summed pubkey). would have liked to see that part in the comments but also think it doesn't fit here since it's bitcoin specific. ",
      "created_at": "2024-12-08T13:47:46Z",
      "updated_at": "2024-12-20T05:18:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1874823508",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1874823508"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 537,
      "original_line": 537,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1875972514",
      "pull_request_review_id": 2409505924,
      "id": 1875972514,
      "node_id": "PRRC_kwDOAP4Jqs5v0RGi",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 265,
      "original_position": 224,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9d6769f:\r\n```suggestion\r\n            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\r\n```",
      "created_at": "2024-12-09T13:21:02Z",
      "updated_at": "2024-12-12T07:21:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1875972514",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1875972514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 265,
      "original_line": 265,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1881383032",
      "pull_request_review_id": 2409505924,
      "id": 1881383032,
      "node_id": "PRRC_kwDOAP4Jqs5wI6B4",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+        ret &= !overflow;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k overflows the curver order, but this is statistically improbable",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 183,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1722499156,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "94c6e1f: it don't think it can fail because of overflow at this point (the overflow is ignored and `t_k` has already been converted to a scalar in `secp256k1_silentpayments_create_t_k`). we could move this comment up into `secp256k1_silentpayments_create_t_k` and handle failure inside that function.",
      "created_at": "2024-12-12T04:57:53Z",
      "updated_at": "2024-12-12T07:21:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1881383032",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1881383032"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 504,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1886516945",
      "pull_request_review_id": 2505693682,
      "id": 1886516945,
      "node_id": "PRRC_kwDOAP4Jqs5wcfbR",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 207,
      "original_position": 189,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": null,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "How should we handle secret keys that add up to `SECP256k1_N`?\r\nI tested this locally with `ALICE_SECKKEY = 0xeadc78165ff1f8ea94ad7cfdc54990738a4c53f6e0507b42154201b8e5dff3b1` and another secret key I generated with `SECP256K1_N - ALICE_SECKEY = 0x152387e9a00e07156b5283023ab66f8b306288efcef824f9aa905cd3ea564d90`.  Passing these two plain secret keys causes `secp256k1_silentpayments_sender_create_outputs` to fail",
      "created_at": "2024-12-16T09:56:06Z",
      "updated_at": "2024-12-16T09:56:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1886516945",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1886516945"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 207,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1893470477",
      "pull_request_review_id": 2516775846,
      "id": 1893470477,
      "node_id": "PRRC_kwDOAP4Jqs5w3BEN",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 207,
      "original_position": 189,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1886516945,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I had an offline conversation with @josibake. The conclusion is that there is nothing to do. The sender has to try again with a different set of pubkeys",
      "created_at": "2024-12-20T04:48:38Z",
      "updated_at": "2024-12-20T04:48:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1893470477",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1893470477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 207,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1894144871",
      "pull_request_review_id": 2517913045,
      "id": 1894144871,
      "node_id": "PRRC_kwDOAP4Jqs5w5ltn",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 207,
      "original_position": 189,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1886516945,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@josibake Here's a diff with the test case for this edge case, \r\nhttps://github.com/josibake/secp256k1/compare/9d6769f4..144584b3",
      "created_at": "2024-12-20T16:31:45Z",
      "updated_at": "2024-12-21T13:11:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1894144871",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1894144871"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 207,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1894553082",
      "pull_request_review_id": 2518573756,
      "id": 1894553082,
      "node_id": "PRRC_kwDOAP4Jqs5w7JX6",
      "diff_hunk": "@@ -107,6 +107,57 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 25,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "7229d49d1bfa2367cee54b106fead4575edc5118",
      "in_reply_to_id": null,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`9d6769f4`: `m` could be `const`",
      "created_at": "2024-12-21T04:31:16Z",
      "updated_at": "2024-12-21T13:57:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1894553082",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1894553082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1894678158",
      "pull_request_review_id": 2518936514,
      "id": 1894678158,
      "node_id": "PRRC_kwDOAP4Jqs5w7n6O",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 537,
      "original_position": 162,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": null,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/1519/commits/94c6e1f54299dfc83aa34bc92f9f861808449a23: There's something I don't understand here. Why is `secp256k1_silentpayments_public_data` 98 bytes long? If we only kept the \"combined\" format `input_hash . A_sum` like we do in `secp256k1_silentpayments_recipient_public_data_serialize`, we would not need this `if  (!combined)` block. What are the merits of keeping `A_sum || input_hash` in public data instead of `input_hash . A_sum`?",
      "created_at": "2024-12-21T19:43:04Z",
      "updated_at": "2024-12-21T19:43:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1894678158",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1894678158"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 537,
      "original_line": 537,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1894765604",
      "pull_request_review_id": 2519545926,
      "id": 1894765604,
      "node_id": "PRRC_kwDOAP4Jqs5w79Qk",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 537,
      "original_position": 162,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1894678158,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@Eunovo this explanation might help - https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1874823508",
      "created_at": "2024-12-22T04:11:41Z",
      "updated_at": "2024-12-22T04:11:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1894765604",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1894765604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 537,
      "original_line": 537,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1894845152",
      "pull_request_review_id": 2519576543,
      "id": 1894845152,
      "node_id": "PRRC_kwDOAP4Jqs5w8Qrg",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 537,
      "original_position": 162,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1894678158,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks @stratospher. I understand that we have to check if combined is set so we know how to handle the public data and I get that light clients need `A_sum . Input_hash`, but what I'm confused about is why don't we do `A_sum . Input_hash` in `secp256k1_silentpayments_recipient_public_data_create` so we only need 32 bytes for public data and we don't need the `secp256k1_silentpayments_recipient_public_data_serialize` function because the data is already presentable to light clients? I'm guessing there's some reason to not combine the `A_sum` and `input_hash` at the beginning?",
      "created_at": "2024-12-22T08:45:47Z",
      "updated_at": "2024-12-22T08:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1894845152",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1894845152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 537,
      "original_line": 537,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1898785806",
      "pull_request_review_id": 2524471499,
      "id": 1898785806,
      "node_id": "PRRC_kwDOAP4Jqs5xLSwO",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];",
      "path": "examples/silentpayments.c",
      "position": 129,
      "original_position": 116,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "5c546e2874012dccc40a3e91ed2502c538a00356",
      "in_reply_to_id": null,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/1519/commits/5c546e2874012dccc40a3e91ed2502c538a00356: nit: Can we change `xonly_print` to `serialized_xonly_pk`? or maybe add a comment `/* Serialized xonly pk */`",
      "created_at": "2024-12-28T03:52:11Z",
      "updated_at": "2024-12-28T03:52:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1898785806",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1898785806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1898985674",
      "pull_request_review_id": 2524799476,
      "id": 1898985674,
      "node_id": "PRRC_kwDOAP4Jqs5xMDjK",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];",
      "path": "examples/silentpayments.c",
      "position": 129,
      "original_position": 116,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "5c546e2874012dccc40a3e91ed2502c538a00356",
      "in_reply_to_id": 1898785806,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I agree that `_print` is a bit redundant, but shouldn't `unsigned char ... [32]` make it clear that this is the serialization?",
      "created_at": "2024-12-28T20:25:41Z",
      "updated_at": "2024-12-28T20:25:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1898985674",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1898985674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1899083701",
      "pull_request_review_id": 2524899656,
      "id": 1899083701,
      "node_id": "PRRC_kwDOAP4Jqs5xMbe1",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];",
      "path": "examples/silentpayments.c",
      "position": 129,
      "original_position": 116,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "5c546e2874012dccc40a3e91ed2502c538a00356",
      "in_reply_to_id": 1898785806,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "To you and me, yes, but to the uninitiated, spelling it out in the variable name might help. This code is meant to be read by anyone trying to use the silent-payments API, so it helps to make things clearer for beginners. That said, I don't have any strong feelings about this; it's just a \"nit.\"",
      "created_at": "2024-12-29T08:14:27Z",
      "updated_at": "2024-12-29T08:14:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1899083701",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1899083701"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1954170319",
      "pull_request_review_id": 2614438905,
      "id": 1954170319,
      "node_id": "PRRC_kwDOAP4Jqs50ekXP",
      "diff_hunk": "@@ -25,6 +26,87 @@ extern \"C\" {\n  * any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  If necessary, the private keys are negated to enforce the right y-parity.\n+ *  For that reason, the private keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The order of outputs here matches the original\n+ *                            ordering of the recipients array.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *       outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                            from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to 32-byte\n+ *                            private keys of taproot inputs (can be NULL if no\n+ *                            private keys of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input private keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte",
      "path": "include/secp256k1_silentpayments.h",
      "position": 94,
      "original_position": 74,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1750039449,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> why can't this be secp256k1_keypair as well?\r\n\r\nSorry, misunderstood your original question. The rest of libsecp uses 32 byte arrays for legacy secret keys and keypairs for x-only secret keys, so I'd prefer to keep the same convention here.",
      "created_at": "2025-02-13T09:46:26Z",
      "updated_at": "2025-02-13T09:46:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1954170319",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1954170319"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 94,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1954281342",
      "pull_request_review_id": 2614622956,
      "id": 1954281342,
      "node_id": "PRRC_kwDOAP4Jqs50e_d-",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 113,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1867298891,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Initially, I believe the thinking was not having untestable branches (e.g., not able to find a preimage which causes an overflow), but I think the point you make regarding the BIP is a good one: better to stick to the specification to avoid a scenario where one implementation handles the overflow and another does not. Will update.",
      "created_at": "2025-02-13T10:56:31Z",
      "updated_at": "2025-02-13T10:56:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1954281342",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1954281342"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1954440707",
      "pull_request_review_id": 2614889404,
      "id": 1954440707,
      "node_id": "PRRC_kwDOAP4Jqs50fmYD",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 207,
      "original_position": 189,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1886516945,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for writing a test! However, I believe this case is already covered with the `ORDERC` malformed key test case. Instead of adding keys that sum, we just pass in a key that is already >= the curve order.",
      "created_at": "2025-02-13T12:51:40Z",
      "updated_at": "2025-02-13T12:51:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1954440707",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1954440707"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 207,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1954442595",
      "pull_request_review_id": 2614892762,
      "id": 1954442595,
      "node_id": "PRRC_kwDOAP4Jqs50fm1j",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 232,
      "original_position": 206,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1750241217,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I believe this is now addressed after adding the constant time tests (and relevant refactors).",
      "created_at": "2025-02-13T12:52:58Z",
      "updated_at": "2025-02-13T12:52:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1954442595",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1954442595"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 232,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1954454375",
      "pull_request_review_id": 2614912386,
      "id": 1954454375,
      "node_id": "PRRC_kwDOAP4Jqs50fptn",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 537,
      "original_position": 162,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1894678158,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I will add the comment as this is an area that reviewers have gotten tripped up on more than once (thanks for the comment suggestion, @stratospher , will use that!). \r\n\r\n@Eunovo the reason we don't immediately multiply `A_sum * input_hash` is because if the node has access to the full transaction, we can save an expensive EC mult later by doing a scalar multiplication `input_hash * bscan` before multiplying by `A_sum`. Otherwise, it we would need an EC mult for `input_hash * A_sum` and then another EC mult for `(input_hash * A_sum) * bscan`.",
      "created_at": "2025-02-13T13:01:08Z",
      "updated_at": "2025-02-13T13:01:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1954454375",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1954454375"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 537,
      "original_line": 537,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955191934",
      "pull_request_review_id": 2616184657,
      "id": 1955191934,
      "node_id": "PRRC_kwDOAP4Jqs50idx-",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set based on the original ordering of the addresses\n+ *  and used to return the generated outputs matching the original ordering.\n+ *  When more than one recipient is used, the recipient array will be sorted in\n+ *  place as part of generating the outputs, but the generated outputs will be\n+ *  returned in the original ordering specified by the index to ensure the\n+ *  caller is able to match up the generated outputs to the correct silent\n+ *  payment address (e.g., to be able to assign the correct amounts to the\n+ *  correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:   labelled_spend_pubkey: pointer to the resulting labelled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labelled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label_tweak` can be used.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 268,
      "original_position": 270,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  `secp256k1_silentpayments_recipient_create_label` can be used.\r\n```",
      "created_at": "2025-02-13T20:47:46Z",
      "updated_at": "2025-02-13T20:48:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1955191934",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955191934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 268,
      "original_line": 268,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955192749",
      "pull_request_review_id": 2616186013,
      "id": 1955192749,
      "node_id": "PRRC_kwDOAP4Jqs50id-t",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set based on the original ordering of the addresses\n+ *  and used to return the generated outputs matching the original ordering.\n+ *  When more than one recipient is used, the recipient array will be sorted in\n+ *  place as part of generating the outputs, but the generated outputs will be\n+ *  returned in the original ordering specified by the index to ensure the\n+ *  caller is able to match up the generated outputs to the correct silent\n+ *  payment address (e.g., to be able to assign the correct amounts to the\n+ *  correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:   labelled_spend_pubkey: pointer to the resulting labelled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labelled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label_tweak` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label_tweak`",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 310,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\r\n```",
      "created_at": "2025-02-13T20:48:29Z",
      "updated_at": "2025-02-13T20:48:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1955192749",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955192749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955265956",
      "pull_request_review_id": 2616306873,
      "id": 1955265956,
      "node_id": "PRRC_kwDOAP4Jqs50iv2k",
      "diff_hunk": "@@ -62,9 +62,21 @@ option(SECP256K1_ENABLE_MODULE_EXTRAKEYS \"Enable extrakeys module.\" ON)\n option(SECP256K1_ENABLE_MODULE_SCHNORRSIG \"Enable schnorrsig module.\" ON)\n option(SECP256K1_ENABLE_MODULE_MUSIG \"Enable musig module.\" ON)\n option(SECP256K1_ENABLE_MODULE_ELLSWIFT \"Enable ElligatorSwift module.\" ON)\n+option(SECP256K1_ENABLE_MODULE_SILENTPAYMENTS \"Enable Silent Payments module.\" ON)\n \n # Processing must be done in a topological sorting of the dependency graph\n # (dependent module first).\n+if(SECP256K1_ENABLE_MODULE_SILENTPAYMENTS)\n+  if(DEFINED SECP256K1_ENABLE_MODULE_SCHNORRSIG AND NOT SECP256K1_ENABLE_MODULE_SCHNORRSIG)\n+    message(FATAL_ERROR \"Module dependency error: You have disabled the schnorrsig module explicitly, but it is required by the silentpayments module.\")\n+  endif()\n+  if(DEFINED SECP256K1_ENABLE_MODULE_EXTRAKEYS AND NOT SECP256K1_ENABLE_MODULE_EXTRAKEYS)\n+    message(FATAL_ERROR \"Module dependency error: You have disabled the extrakeys module explicitly, but it is required by the silentpayments module.\")\n+  endif()\n+  set(SECP256K1_ENABLE_MODULE_EXTRAKEYS ON)",
      "path": "CMakeLists.txt",
      "position": 15,
      "original_position": 15,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "6c8eafb66b839cd5c19f91a991deb323445965fc",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "IIUC, we also want to enable the schorrsig module here\r\n```suggestion\r\n  set(SECP256K1_ENABLE_MODULE_SCHNORRSIG ON)\r\n  set(SECP256K1_ENABLE_MODULE_EXTRAKEYS ON)\r\n```\r\n(that also matches the autotools-equivalent part)",
      "created_at": "2025-02-13T21:55:23Z",
      "updated_at": "2025-02-13T23:20:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1955265956",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955265956"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 76,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955273887",
      "pull_request_review_id": 2616306873,
      "id": 1955273887,
      "node_id": "PRRC_kwDOAP4Jqs50ixyf",
      "diff_hunk": "@@ -7,10 +7,282 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 119,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "e35d18853de9e731ca4c0cd48388ce01f5176029",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should use the dedicated memory cleanse function and also clear out the hash object\r\n```suggestion\r\n    secp256k1_memclear(hash_ser, sizeof(hash_ser));\r\n    secp256k1_sha256_clear(&hash);\r\n```",
      "created_at": "2025-02-13T22:01:30Z",
      "updated_at": "2025-02-13T23:20:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1955273887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955273887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955280232",
      "pull_request_review_id": 2616306873,
      "id": 1955280232,
      "node_id": "PRRC_kwDOAP4Jqs50izVo",
      "diff_hunk": "@@ -7,10 +7,282 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        /* TODO: We can declassify return value, because scalar set only fails if the seckey is invalid */\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        /* TODO: we can declassify return value */\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    /* TODO: can we declassify this? */\n+    /* Yes: We assume the adversary has access to a_sum_scalar*G */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    /* TODO: consider VERIFY_CHECK ??? */\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* TODO: clean up */\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            /* TODO: clean up */\n+            return 0;\n+        }\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 280,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "e35d18853de9e731ca4c0cd48388ce01f5176029",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\r\n```",
      "created_at": "2025-02-13T22:07:54Z",
      "updated_at": "2025-02-13T23:20:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1955280232",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955280232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955303168",
      "pull_request_review_id": 2616306873,
      "id": 1955303168,
      "node_id": "PRRC_kwDOAP4Jqs50i48A",
      "diff_hunk": "@@ -285,4 +285,74 @@ int secp256k1_silentpayments_sender_create_outputs(\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 67,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "7cde4ac32eab6c34467dd1f44018db67f7a9aec8",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n```\r\nas the result is not serialized anymore (it was in an early version, IIRC)",
      "created_at": "2025-02-13T22:31:28Z",
      "updated_at": "2025-02-13T23:20:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1955303168",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955303168"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955323634",
      "pull_request_review_id": 2616306873,
      "id": 1955323634,
      "node_id": "PRRC_kwDOAP4Jqs50i97y",
      "diff_hunk": "@@ -163,6 +163,252 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 44,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ae316e2c20d7db7938e3365e53cf0da4a718edf0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  Returns: 1 if public data creation was successful. 0 if an error occured.\r\n```",
      "created_at": "2025-02-13T22:56:22Z",
      "updated_at": "2025-02-13T23:20:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1955323634",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955323634"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955334890",
      "pull_request_review_id": 2616306873,
      "id": 1955334890,
      "node_id": "PRRC_kwDOAP4Jqs50jArq",
      "diff_hunk": "@@ -355,4 +355,320 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    secp256k1_memclear(input_hash_local, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    secp256k1_memclear(&public_data->data[1 + pubkeylen], 32);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 110,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "ae316e2c20d7db7938e3365e53cf0da4a718edf0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: can just use the usual memset here, as this is no data on the stack and hence not at risk of optimized out (and it's not secret data anyway)",
      "created_at": "2025-02-13T23:11:32Z",
      "updated_at": "2025-02-13T23:20:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1955334890",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1955334890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 464,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1979987180",
      "pull_request_review_id": 2658562451,
      "id": 1979987180,
      "node_id": "PRRC_kwDOAP4Jqs52BDTs",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    ret = secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+    ret &= secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 207,
      "original_position": 189,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1886516945,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I believe this case is already covered with the ORDERC malformed key test case\r\n\r\nI checked this. IIUC, the function exits earlier when you use a malformed key.  Using keys that sum to `SECP256K1_N` uses a different code path. \r\nThere's a test for keys that sum to zero / point at infinity included in the test vectors so we still don't need to add one. I verified this by checking the coverage using\r\n```\r\ncmake -B build-cov -DCMAKE_BUILD_TYPE=Coverage\r\ncmake --build build-cov -j 6\r\nbuild-cov/bin/noverify_tests\r\nfind build-cov -name '*.gcda'|xargs gcov -t > output.gcov\r\n```\r\n",
      "created_at": "2025-03-04T18:22:14Z",
      "updated_at": "2025-03-04T18:22:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1979987180",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1979987180"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 207,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992222794",
      "pull_request_review_id": 2679751532,
      "id": 1992222794,
      "node_id": "PRRC_kwDOAP4Jqs52vuhK",
      "diff_hunk": "@@ -192,6 +192,10 @@ AC_ARG_ENABLE(module_ellswift,\n     AS_HELP_STRING([--enable-module-ellswift],[enable ElligatorSwift module [default=yes]]), [],\n     [SECP_SET_DEFAULT([enable_module_ellswift], [yes], [yes])])\n \n+AC_ARG_ENABLE(module_silentpayments,\n+    AS_HELP_STRING([--enable-module-silentpayments],[enable Silent Payments module [default=no]]), [],\n+    [SECP_SET_DEFAULT([enable_module_silentpayments], [no], [yes])])",
      "path": "configure.ac",
      "position": null,
      "original_position": 6,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n    [SECP_SET_DEFAULT([enable_module_silentpayments], [yes], [yes])])\r\n```\r\n\r\nCurrently, it's disabled by default, but we generally enable all modules by default (except the recovery module because we only have it for historical reasons). For Cmake it's already enabled by default.",
      "created_at": "2025-03-12T20:11:15Z",
      "updated_at": "2025-03-12T21:47:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1992222794",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992222794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992255919",
      "pull_request_review_id": 2679751532,
      "id": 1992255919,
      "node_id": "PRRC_kwDOAP4Jqs52v2mv",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set based on the original ordering of the addresses\n+ *  and used to return the generated outputs matching the original ordering.\n+ *  When more than one recipient is used, the recipient array will be sorted in\n+ *  place as part of generating the outputs, but the generated outputs will be\n+ *  returned in the original ordering specified by the index to ensure the\n+ *  caller is able to match up the generated outputs to the correct silent\n+ *  payment address (e.g., to be able to assign the correct amounts to the\n+ *  correct generated outputs in the final transaction).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 40,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n/** This struct serves as an input parameter for passing the silent payment\r\n *  address data to `silentpayments_sender_create_outputs`.\r\n *\r\n *  The index field is for when more than one address is being sent to in\r\n *  a transaction. Index is set to the position of this recipient in the `recipients` array passed to `silentpayments_sender_create_outputs`\r\n *  and used to return the generated outputs matching the original ordering.\r\n```\r\nnit: this is more clear about how to set the index and doesn't repeat what is stated in the `silentpayments_sender_create_outputs` API doc.",
      "created_at": "2025-03-12T20:38:17Z",
      "updated_at": "2025-03-12T21:47:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1992255919",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992255919"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992296737",
      "pull_request_review_id": 2679751532,
      "id": 1992296737,
      "node_id": "PRRC_kwDOAP4Jqs52wAkh",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 107,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The type of `k` is a bit strange. In `scan_outputs` it's a `size_t`. When it gets passed into this function it's a `unsigned int`, which is only guaranteed to be 16 bits. Then in `write_be32` it gets casted to a `uint32_t`. This means that when `size_t` is larger than `unsigned int` or `size_t` is larger than `uint32_t` the function will return wrong results.\r\n\r\nI suggest to change the type of `k` in this function from `unsigned int` to `uint32_t` and add a branch to  `scan_outputs` that returns 0 if `k` exceeds `UINT32_MAX`. Does the BIP 352 spec have a different approach to this?",
      "created_at": "2025-03-12T21:10:30Z",
      "updated_at": "2025-03-12T21:47:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1992296737",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992296737"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992309502",
      "pull_request_review_id": 2679751532,
      "id": 1992309502,
      "node_id": "PRRC_kwDOAP4Jqs52wDr-",
      "diff_hunk": "@@ -7,10 +7,249 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 113,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "9d6769f4aed4691463f9c591e147df6a0ccfbca3",
      "in_reply_to_id": 1867298891,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "How about\r\n\r\n```\r\nsecp256k1_scalar_set_b32(t_k_scalar, hash_ser, overflow);\r\nVERIFY_CHECK(!overflow);\r\nVERIFY_CHECK(!secp256k1_scalar_is_zero(&t_k_scalar));\r\n```\r\n\r\n",
      "created_at": "2025-03-12T21:17:37Z",
      "updated_at": "2025-03-12T21:47:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1992309502",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992309502"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992340666",
      "pull_request_review_id": 2679751532,
      "id": 1992340666,
      "node_id": "PRRC_kwDOAP4Jqs52wLS6",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        /* TODO: We can declassify return value, because scalar set only fails if the seckey is invalid */\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        /* TODO: we can declassify return value */\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    /* TODO: can we declassify this? */\n+    /* Yes: We assume the adversary has access to a_sum_scalar*G */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    /* TODO: consider VERIFY_CHECK ??? */\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* TODO: clean up */\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            /* TODO: clean up */\n+            return 0;\n+        }\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    secp256k1_memclear(input_hash_local, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    secp256k1_memclear(&public_data->data[1 + pubkeylen], 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, then return */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    /* TODO: only fails in case of invalid key */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* consider clearing */\n+        return 0;\n+    }\n+    if (!secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey)) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k overflows the curve order, but this is statistically improbable\n+         */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 547,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This comment doesn't seem to be true. This only fails if `t_k = -b_spend` where `b_spend*G = B_spend`.\r\n```suggestion\r\n        /* Calculate P_output = B_spend + t_k * G\r\n         * This can fail if t_k equals the negation of the DLog of P_output, but t_k\r\n         * is the output of a hash function.\r\n         */\r\n        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\r\n```\r\nAlso, aren't we calculating `B_spend` and not `P_output`?",
      "created_at": "2025-03-12T21:47:24Z",
      "updated_at": "2025-03-12T21:47:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1992340666",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992340666"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 545,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 547,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992409713",
      "pull_request_review_id": 2680053411,
      "id": 1992409713,
      "node_id": "PRRC_kwDOAP4Jqs52wcJx",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 74,
      "original_position": 74,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "LLFourn",
        "id": 3734083,
        "node_id": "MDQ6VXNlcjM3MzQwODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3734083?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LLFourn",
        "html_url": "https://github.com/LLFourn",
        "followers_url": "https://api.github.com/users/LLFourn/followers",
        "following_url": "https://api.github.com/users/LLFourn/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LLFourn/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LLFourn/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LLFourn/subscriptions",
        "organizations_url": "https://api.github.com/users/LLFourn/orgs",
        "repos_url": "https://api.github.com/users/LLFourn/repos",
        "events_url": "https://api.github.com/users/LLFourn/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LLFourn/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Has the topic of using x-only ECDH come up on silent payments before like is used in [BIP324](https://bips.xyz/324#cite-ref-xonly-ecdh-11-0)? This avoids a square root which I think a small but measurable speed up on an ecmult. Perhaps someone more familiar with the x-only impl in BIP324 can comment on what the exact speed up would be.\r\nNote that in terms of code all that has to change is to make the shared secret just the x coordinate (change it to `shared_secret32`) and the actual optimization could be implemented later. It seems like it could be worth changing the spec slightly even at this stage to at least leave the door open to taking advantage of this so I thought it'd be worth mentioning.\r\n\r\ncc @sipa @real-or-random @jonasnick ",
      "created_at": "2025-03-12T23:03:17Z",
      "updated_at": "2025-03-12T23:03:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1992409713",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1992409713"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993129528",
      "pull_request_review_id": 2681171430,
      "id": 1993129528,
      "node_id": "PRRC_kwDOAP4Jqs52zL44",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set based on the original ordering of the addresses\n+ *  and used to return the generated outputs matching the original ordering.\n+ *  When more than one recipient is used, the recipient array will be sorted in\n+ *  place as part of generating the outputs, but the generated outputs will be\n+ *  returned in the original ordering specified by the index to ensure the\n+ *  caller is able to match up the generated outputs to the correct silent\n+ *  payment address (e.g., to be able to assign the correct amounts to the\n+ *  correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:   labelled_spend_pubkey: pointer to the resulting labelled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labelled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 241,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/1659",
      "created_at": "2025-03-13T09:38:50Z",
      "updated_at": "2025-03-13T09:38:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1993129528",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993129528"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 241,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993310101",
      "pull_request_review_id": 2681506513,
      "id": 1993310101,
      "node_id": "PRRC_kwDOAP4Jqs52z3-V",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 93,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1870942231,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should also VERIFY_CHECK the return value of  `secp256k1_ec_pubkey_serialize` (or merge it into ret if it could really fail)",
      "created_at": "2025-03-13T11:19:46Z",
      "updated_at": "2025-03-13T11:19:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1993310101",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993310101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 446,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993311745",
      "pull_request_review_id": 2681509205,
      "id": 1993311745,
      "node_id": "PRRC_kwDOAP4Jqs52z4YB",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        /* TODO: We can declassify return value, because scalar set only fails if the seckey is invalid */\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        /* TODO: we can declassify return value */\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    /* TODO: can we declassify this? */\n+    /* Yes: We assume the adversary has access to a_sum_scalar*G */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    /* TODO: consider VERIFY_CHECK ??? */\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* TODO: clean up */\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            /* TODO: clean up */\n+            return 0;\n+        }\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    secp256k1_memclear(input_hash_local, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    secp256k1_memclear(&public_data->data[1 + pubkeylen], 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, then return */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    /* TODO: only fails in case of invalid key */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* consider clearing */\n+        return 0;\n+    }\n+    if (!secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey)) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k overflows the curve order, but this is statistically improbable\n+         */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if the labels cache is present) */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge P_output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&P_output_negated_ge, &P_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 * label1 = tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 574,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "VERIFY_CHECK/handle return value `secp256k1_ec_pubkey_serialize`",
      "created_at": "2025-03-13T11:20:53Z",
      "updated_at": "2025-03-13T11:21:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1993311745",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993311745"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 574,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993311957",
      "pull_request_review_id": 2681509205,
      "id": 1993311957,
      "node_id": "PRRC_kwDOAP4Jqs52z4bV",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        /* TODO: We can declassify return value, because scalar set only fails if the seckey is invalid */\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        /* TODO: we can declassify return value */\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    /* TODO: can we declassify this? */\n+    /* Yes: We assume the adversary has access to a_sum_scalar*G */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    /* TODO: consider VERIFY_CHECK ??? */\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* TODO: clean up */\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            /* TODO: clean up */\n+            return 0;\n+        }\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    secp256k1_memclear(input_hash_local, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    secp256k1_memclear(&public_data->data[1 + pubkeylen], 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, then return */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    /* TODO: only fails in case of invalid key */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* consider clearing */\n+        return 0;\n+    }\n+    if (!secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey)) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k overflows the curve order, but this is statistically improbable\n+         */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if the labels cache is present) */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge P_output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&P_output_negated_ge, &P_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 * label1 = tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 * label2 = -tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 587,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "VERIFY_CHECK/handle return value secp256k1_ec_pubkey_serialize\r\n",
      "created_at": "2025-03-13T11:21:03Z",
      "updated_at": "2025-03-13T11:21:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1993311957",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993311957"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 587,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993589323",
      "pull_request_review_id": 2682040199,
      "id": 1993589323,
      "node_id": "PRRC_kwDOAP4Jqs5208JL",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        /* TODO: We can declassify return value, because scalar set only fails if the seckey is invalid */\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        /* TODO: we can declassify return value */\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    /* TODO: can we declassify this? */\n+    /* Yes: We assume the adversary has access to a_sum_scalar*G */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    /* TODO: consider VERIFY_CHECK ??? */\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* TODO: clean up */\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            /* TODO: clean up */\n+            return 0;\n+        }\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    secp256k1_memclear(input_hash_local, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 422,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`ec_pubkey_parse` is for parsing arbitrary byte arrays and includes a relatively expensive check that the coordinates are valid. It would be better to use `ge_from_bytes` and `ge_to_bytes` similar to the `*_load` functions in the musig module. This would also reduce the size of the the public data by a byte.",
      "created_at": "2025-03-13T13:58:13Z",
      "updated_at": "2025-03-13T13:59:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1993589323",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993589323"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 422,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993710391",
      "pull_request_review_id": 2682270704,
      "id": 1993710391,
      "node_id": "PRRC_kwDOAP4Jqs521Zs3",
      "diff_hunk": "@@ -63,6 +63,10 @@ static void help(int default_iters) {\n     printf(\"    ellswift_ecdh     : ECDH on ElligatorSwift keys\\n\");\n #endif\n \n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    printf(\"    silentpayments    : Silent payments recipient scanning\\n\");",
      "path": "src/bench.c",
      "position": 16,
      "original_position": 5,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Misses silentpayments in the list of supported algorithms at the start of the help output.",
      "created_at": "2025-03-13T14:54:58Z",
      "updated_at": "2025-03-14T17:17:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1993710391",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993710391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": 75,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": 76,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993755203",
      "pull_request_review_id": 2682370373,
      "id": 1993755203,
      "node_id": "PRRC_kwDOAP4Jqs521kpD",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {",
      "path": "examples/silentpayments.c",
      "position": 119,
      "original_position": 104,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is the line where Valgrind on macOS complains in CI.\r\n\r\nBut I hacked together a CI jobs to see the code location already now:\r\n - https://github.com/real-or-random/secp256k1/actions/runs/13836954165/job/38714314881#step:5:398\r\n\r\nHere's a snippet of the stack trace:\r\n```\r\n==22464==    by 0x100000690: label_lookup (silentpayments.c:104)\r\n==22464==    by 0x1000217D8: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:575)\r\n==22464==    by 0x100000C4D: main (silentpayments.c:386)\r\n==22464==  Uninitialised value was created by a stack allocation\r\n==22464==    at 0x100020ACD: secp256k1_silentpayments_recipient_scan_outputs (main_impl.h:477)\r\n```\r\n\r\n@josibake As soon as you rebase on #1655, you should get the Valgrind error output also here on this PR.\r\n\r\nMy conclusion is that this is a false positive, caused by the use of `memcmp` in the example code.\r\n\r\n[The errors are gone](https://github.com/real-or-random/secp256k1/actions/runs/13836935297/job/38714251450) when I [replace `memcmp` by `secp256k1_memcmp_var`](https://github.com/real-or-random/secp256k1/commit/82de1c833ac7c661bf8833e82285f510ce69d1c1). \r\n\r\nSo this is harmless. But I'm not entirely sure yet what we should do about this. In general, it's desirable that Valgrind passes cleanly on the examples. But Valgrind on macOS is a somewhat special thing because you'll need the macos-valgrind fork anyway, which does the job, but is maintained by a single person on a best-effort basis and needs to be installed via special brew commands etc.  So it would be okay to write our own Valgrind error suppression file for these memcmp errors, enable it in our CI  and be happy. Anyone who runs Valgrind without the suppression file will still see the errors, but due to the special setup that is required, it's unlikely that many users will run into this, and if so, they probably won't panic but instead be prepared for any false positives. \r\n\r\nAlternatively, we could really switch to `secp256k1_memcmp_var` in the example, preferably renamed and with a brief comment that explains that we use this only due to a bug in Valgrind, and there's no (other) reason not to use the real `memcmp`.",
      "created_at": "2025-03-13T15:15:51Z",
      "updated_at": "2025-03-13T15:15:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1993755203",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993755203"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 119,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993978485",
      "pull_request_review_id": 2682802429,
      "id": 1993978485,
      "node_id": "PRRC_kwDOAP4Jqs522bJ1",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {",
      "path": "examples/silentpayments.c",
      "position": 119,
      "original_position": 104,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1993755203,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for helping this! Using `secp256k1_memcmp_var` in the example along with a detailed comment as to why seems like the cleanest approach to me?  We can also easily update the example in the future in the event the bug in Valgrind on macOS is fixed in the future.",
      "created_at": "2025-03-13T17:10:39Z",
      "updated_at": "2025-03-13T17:10:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1993978485",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1993978485"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 119,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995165702",
      "pull_request_review_id": 2684855799,
      "id": 1995165702,
      "node_id": "PRRC_kwDOAP4Jqs5269AG",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 74,
      "original_position": 74,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1992409713,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "(@sipa Replying here in the thread to keep things organized in this huge PR.)\r\n\r\n> @LLFourn I've included the possibility of x-only ECDH (and x-only B_scan) in my review document of the BIP: [gist.github.com/sipa/c9299811fb1f56abdcd2451a8a078d20](https://gist.github.com/sipa/c9299811fb1f56abdcd2451a8a078d20)\r\n\r\n> Note that in terms of code all that has to change is to make the shared secret just the x coordinate (change it to `shared_secret32`) and the actual optimization could be implemented later. It seems like it could be worth changing the spec slightly even at this stage\r\n\r\nYeah, I think x-only ECDH has fallen between the cracks. For all other protocols, there was not enough pressure to optimize our existing ECDH because it's fast enough (BIP324 is an exception in that we had to redo it anyway from scratch due to ellswift). \r\n\r\nBut I agree that the situation is different here. Scanning is the bottleneck, and it will be nice to save a few percent.\r\n\r\nWe even have draft implementations:\r\n - input=xonly, shared_secret=xonly: https://github.com/bitcoin-core/secp256k1/pull/1198 (this one is in a good shape)\r\n - input=compressed, shared_secret=xonly: https://github.com/bitcoin-core/secp256k1/pull/262\r\n\r\nThe big question is whether the spec can be changed at this point, and I'm afraid the answer is no. If I recall correctly, others have picked it up already? @josibake @rubensomsen  ",
      "created_at": "2025-03-14T09:06:41Z",
      "updated_at": "2025-03-14T09:06:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995165702",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995165702"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995679813",
      "pull_request_review_id": 2685742968,
      "id": 1995679813,
      "node_id": "PRRC_kwDOAP4Jqs5286hF",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 74,
      "original_position": 74,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1992409713,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@real-or-random No implementation work is really needed, since the `silentpayment` module does ECDH internally; it doesn't expect users to use the `ecdh` module interface, and the internal side of things, the `secp256k1_ecmult_const_xonly` function, already exists since #1118.\r\n\r\nThe big question is indeed whether breaking spec changes are still possible. Please have a look at my other questions/suggestions in the doc too, if it is.",
      "created_at": "2025-03-14T14:24:37Z",
      "updated_at": "2025-03-14T14:24:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995679813",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995679813"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995923884",
      "pull_request_review_id": 2682270704,
      "id": 1995923884,
      "node_id": "PRRC_kwDOAP4Jqs5292Gs",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 140,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think amounts in this example are more confusing than useful. This array is only used for printing.",
      "created_at": "2025-03-14T16:53:43Z",
      "updated_at": "2025-03-14T17:17:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995923884",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995923884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995928576",
      "pull_request_review_id": 2682270704,
      "id": 1995928576,
      "node_id": "PRRC_kwDOAP4Jqs5293QA",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 195,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "indentation",
      "created_at": "2025-03-14T16:55:00Z",
      "updated_at": "2025-03-14T17:17:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995928576",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995928576"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 194,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995935100",
      "pull_request_review_id": 2682270704,
      "id": 1995935100,
      "node_id": "PRRC_kwDOAP4Jqs529418",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 225,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This seems unsafe because we're casting const away for a function that is definitely violating the const. If we only want to use one array for creating and scanning, then we should just remove const from the declaration of tx_output_ptrs.",
      "created_at": "2025-03-14T16:57:14Z",
      "updated_at": "2025-03-14T17:17:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995935100",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995935100"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 219,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995942912",
      "pull_request_review_id": 2682270704,
      "id": 1995942912,
      "node_id": "PRRC_kwDOAP4Jqs5296wA",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+",
      "path": "examples/silentpayments.c",
      "position": 272,
      "original_position": 260,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "in_reply_to_id": 1678634760,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Stumbled again over this while reading the example. Alternatively, when doing the labels setup, can we check that the spend key in bob's address matches the labelled spend pubkey? This would demonstrate usage of `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey` with a minimal diff.",
      "created_at": "2025-03-14T17:00:13Z",
      "updated_at": "2025-03-14T17:17:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995942912",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995942912"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 272,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995945936",
      "pull_request_review_id": 2682270704,
      "id": 1995945936,
      "node_id": "PRRC_kwDOAP4Jqs5297fQ",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &tx_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret &= secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                ret &= secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);",
      "path": "examples/silentpayments.c",
      "position": 357,
      "original_position": 347,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "There should be an assert(ret) right after `recipient_create_label` because we're using its output as input to the next function.",
      "created_at": "2025-03-14T17:02:01Z",
      "updated_at": "2025-03-14T17:17:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995945936",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995945936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 357,
      "original_line": 357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995947744",
      "pull_request_review_id": 2682270704,
      "id": 1995947744,
      "node_id": "PRRC_kwDOAP4Jqs52977g",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &tx_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret &= secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                ret &= secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            ret &= secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 370,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We should check `ret` after `public_data_create` and before potentially using `data_serialize` with invalid values.",
      "created_at": "2025-03-14T17:03:09Z",
      "updated_at": "2025-03-14T17:17:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995947744",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995947744"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 362,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 379,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995948741",
      "pull_request_review_id": 2682270704,
      "id": 1995948741,
      "node_id": "PRRC_kwDOAP4Jqs5298LF",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &tx_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret &= secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                ret &= secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            ret &= secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            if (!ret) {\n+                /* We need to always check that the public data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that public_data_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return 0;\n+            }\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret &= secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the public data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return 0;\n+            }\n+            if (n_found_outputs > 0) {\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    secp256k1_xonly_pubkey_serialize(ctx,\n+                        xonly_print,\n+                        &found_outputs[i].output\n+                    );\n+                    print_hex(xonly_print, sizeof(xonly_print));\n+                }\n+            } else {\n+                printf(\"\\n\");\n+                printf(\"Bob did not find any outputs in this transaction.\");\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the\n+             * transaction outputs. This means she will need to first generate\n+             * an output, check if it exists in the UTXO set (e.g. BIP158 or\n+             * some other means of querying) and only proceed to check the next\n+             * output (by incrementing `k`) if the first output exists. It's\n+             * also difficult for Carol to efficiently scan for labels without\n+             * the transaction outputs, but Carol can still use labels as a\n+             * light client by pregenerating all possible labels and adding them\n+             * to the generated output (i.e., `k = 0`). Once at least one output\n+             * is found, she can request the full block and scan the the full\n+             * transaction. This assumes Carol will only use a small number of\n+             * of labels as a light client.\n+             *\n+             * Additionally, Carol likely does not have access to the\n+             * transaction inputs and prevout information, so she uses the\n+             * `public_data` object created by Bob's full node earlier. This\n+             * serialized `public_data` object contains everything she needs for\n+             * generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of\n+             * time but we are cheating here to keep the example simple.\n+             *\n+             */\n+            unsigned char ser_found_outputs[2][32];\n+            unsigned char shared_secret[33];\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_silentpayments_recipient_public_data public_data;\n+            size_t n_found_outputs;\n+\n+            /* Load Carol's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &spend_pubkey,\n+                carol_address[1],\n+                33\n+            );\n+            assert(ret);\n+\n+            /* Scan one output at a time, using the serialized `public_data`\n+             * created by Bob's full node\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_parse(ctx,\n+                &public_data,\n+                light_client_data33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return 0;\n+            }\n+            ret &= secp256k1_silentpayments_recipient_create_shared_secret(ctx,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 471,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n            ret = secp256k1_silentpayments_recipient_create_shared_secret(ctx,\r\n```",
      "created_at": "2025-03-14T17:03:48Z",
      "updated_at": "2025-03-14T17:17:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995948741",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995948741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 480,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995949674",
      "pull_request_review_id": 2682270704,
      "id": 1995949674,
      "node_id": "PRRC_kwDOAP4Jqs5298Zq",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &tx_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 261,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "A bit confusing because we don't create the global variables here, we just set them. Not sure if this comment is outdated.",
      "created_at": "2025-03-14T17:04:31Z",
      "updated_at": "2025-03-14T17:17:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995949674",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995949674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 258,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995957309",
      "pull_request_review_id": 2682270704,
      "id": 1995957309,
      "node_id": "PRRC_kwDOAP4Jqs529-Q9",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 206,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The sender shouldn't assert that the return values are correct. The addresses may well not encode valid public keys.",
      "created_at": "2025-03-14T17:10:17Z",
      "updated_at": "2025-03-14T17:17:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995957309",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995957309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 195,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995962243",
      "pull_request_review_id": 2682270704,
      "id": 1995962243,
      "node_id": "PRRC_kwDOAP4Jqs529_eD",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);",
      "path": "examples/silentpayments.c",
      "position": 249,
      "original_position": 231,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ideally, the documentation in the include file would indicate whether this can be asserted or not. In the case of `create_outputs` and potentially others, it's not.",
      "created_at": "2025-03-14T17:12:51Z",
      "updated_at": "2025-03-14T17:17:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995962243",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995962243"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 249,
      "original_line": 249,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995966699",
      "pull_request_review_id": 2682270704,
      "id": 1995966699,
      "node_id": "PRRC_kwDOAP4Jqs52-Ajr",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &tx_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret &= secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                ret &= secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            ret &= secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            if (!ret) {\n+                /* We need to always check that the public data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that public_data_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return 0;\n+            }\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret &= secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the public data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return 0;\n+            }\n+            if (n_found_outputs > 0) {\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    secp256k1_xonly_pubkey_serialize(ctx,\n+                        xonly_print,\n+                        &found_outputs[i].output\n+                    );\n+                    print_hex(xonly_print, sizeof(xonly_print));\n+                }\n+            } else {\n+                printf(\"\\n\");\n+                printf(\"Bob did not find any outputs in this transaction.\");\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the\n+             * transaction outputs. This means she will need to first generate\n+             * an output, check if it exists in the UTXO set (e.g. BIP158 or\n+             * some other means of querying) and only proceed to check the next\n+             * output (by incrementing `k`) if the first output exists. It's\n+             * also difficult for Carol to efficiently scan for labels without\n+             * the transaction outputs, but Carol can still use labels as a\n+             * light client by pregenerating all possible labels and adding them\n+             * to the generated output (i.e., `k = 0`). Once at least one output\n+             * is found, she can request the full block and scan the the full\n+             * transaction. This assumes Carol will only use a small number of\n+             * of labels as a light client.\n+             *\n+             * Additionally, Carol likely does not have access to the\n+             * transaction inputs and prevout information, so she uses the\n+             * `public_data` object created by Bob's full node earlier. This\n+             * serialized `public_data` object contains everything she needs for\n+             * generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of\n+             * time but we are cheating here to keep the example simple.\n+             *\n+             */\n+            unsigned char ser_found_outputs[2][32];\n+            unsigned char shared_secret[33];\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_silentpayments_recipient_public_data public_data;\n+            size_t n_found_outputs;\n+\n+            /* Load Carol's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &spend_pubkey,\n+                carol_address[1],\n+                33\n+            );\n+            assert(ret);\n+\n+            /* Scan one output at a time, using the serialized `public_data`\n+             * created by Bob's full node\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_parse(ctx,\n+                &public_data,\n+                light_client_data33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return 0;\n+            }\n+            ret &= secp256k1_silentpayments_recipient_create_shared_secret(ctx,\n+                shared_secret,\n+                carol_scan_key,\n+                &public_data\n+            );\n+            /* Since we've already validated the public data, the only reason this could fail\n+             * is if we input a bad scan key or bad spend public key, which should never happen\n+             * because this is data under our control.\n+             */\n+            assert(ret);\n+            n_found_outputs = 0;\n+            {\n+                int found = 0;\n+                size_t k = 0;\n+                secp256k1_xonly_pubkey potential_output;\n+\n+                while (1) {\n+                    ret = secp256k1_silentpayments_recipient_create_output_pubkey(ctx,\n+                        &potential_output,\n+                        shared_secret,\n+                        &spend_pubkey,\n+                        k\n+                    );\n+                    if (!ret) {\n+                        printf(\"\\n\");\n+                        printf(\"This transaction is not valid for silent payments, skipping.\");\n+                        return 0;\n+                    }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 498,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If we're consistent, then I think the return value can be asserted because it fails only if the API is used in a wrong way.",
      "created_at": "2025-03-14T17:15:38Z",
      "updated_at": "2025-03-14T17:17:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995966699",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995966699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 488,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995968812",
      "pull_request_review_id": 2682270704,
      "id": 1995968812,
      "node_id": "PRRC_kwDOAP4Jqs52-BEs",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &tx_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret &= secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                ret &= secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            ret &= secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            if (!ret) {\n+                /* We need to always check that the public data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that public_data_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return 0;\n+            }\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret &= secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the public data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return 0;\n+            }\n+            if (n_found_outputs > 0) {\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");",
      "path": "examples/silentpayments.c",
      "position": 442,
      "original_position": 405,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What appears to be missing here (and for Carol) is how to actually calculate the corresponding secret key. This should probably also be mentioned in the API documentation.",
      "created_at": "2025-03-14T17:17:12Z",
      "updated_at": "2025-03-14T17:17:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1995968812",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1995968812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 442,
      "original_line": 442,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1996130672",
      "pull_request_review_id": 2686566788,
      "id": 1996130672,
      "node_id": "PRRC_kwDOAP4Jqs52-olw",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 225,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1995935100,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> If we only want to use one array for creating and scanning, then we should just remove const from the declaration of tx_output_ptrs.\r\n\r\nStrongly agree with this.\r\n\r\nFor the sake of education, it is safe because the pointers in `tx_out_ptrs` point to the elements of `tx_outputs`, which is not declared `const`. So the \"object\" we're modifying is not declared `const`. And only this would be UB: \"If an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, the behavior is undefined.\"  (https://port70.net/~nsz/c/c99/n1256.html#6.7.3p5) \r\n\r\nBut yep, relying on this is probably not the kind of programming style we should encourage in an example. ^^",
      "created_at": "2025-03-14T19:03:22Z",
      "updated_at": "2025-03-14T19:03:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1996130672",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1996130672"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 219,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1996645943",
      "pull_request_review_id": 2687486162,
      "id": 1996645943,
      "node_id": "PRRC_kwDOAP4Jqs53AmY3",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        /* TODO: We can declassify return value, because scalar set only fails if the seckey is invalid */\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        /* TODO: we can declassify return value */\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    /* TODO: can we declassify this? */\n+    /* Yes: We assume the adversary has access to a_sum_scalar*G */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    /* TODO: consider VERIFY_CHECK ??? */\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 260,
      "original_position": 251,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Can you add a comment explaining why the recipients array is getting sorted? Maybe relate it to the \"Grouping\" operation specified in the BIP.",
      "created_at": "2025-03-15T08:13:39Z",
      "updated_at": "2025-03-17T10:57:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1996645943",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1996645943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 260,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998241384",
      "pull_request_review_id": 2687486162,
      "id": 1998241384,
      "node_id": "PRRC_kwDOAP4Jqs53Gr5o",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 107,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1992296737,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> add a branch to scan_outputs that returns 0 if k exceeds UINT32_MAX.\r\n\r\nAlternatively, we can change the type of `k` in the API to `uint32_t` (and perhaps do the same to `m` in `secp256k1_silentpayments_recipient_create_label`.",
      "created_at": "2025-03-17T08:55:13Z",
      "updated_at": "2025-03-17T10:57:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998241384",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998241384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998263939",
      "pull_request_review_id": 2687486162,
      "id": 1998263939,
      "node_id": "PRRC_kwDOAP4Jqs53GxaD",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set based on the original ordering of the addresses\n+ *  and used to return the generated outputs matching the original ordering.\n+ *  When more than one recipient is used, the recipient array will be sorted in\n+ *  place as part of generating the outputs, but the generated outputs will be\n+ *  returned in the original ordering specified by the index to ensure the\n+ *  caller is able to match up the generated outputs to the correct silent\n+ *  payment address (e.g., to be able to assign the correct amounts to the\n+ *  correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 42,
      "original_position": 44,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: The terminology could be more clear. The naming in this struct appears to suggest that a `spend_pubkey` can either be the \"actual\" spend pubkey or a labelled spend pubkey. However, everywhere else in the API `spend_pubkey` is the actual spend pubkey and not the labelled spend pubkey. ",
      "created_at": "2025-03-17T09:03:38Z",
      "updated_at": "2025-03-17T10:57:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998263939",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998263939"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 42,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998277913",
      "pull_request_review_id": 2687486162,
      "id": 1998277913,
      "node_id": "PRRC_kwDOAP4Jqs53G00Z",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set based on the original ordering of the addresses\n+ *  and used to return the generated outputs matching the original ordering.\n+ *  When more than one recipient is used, the recipient array will be sorted in\n+ *  place as part of generating the outputs, but the generated outputs will be\n+ *  returned in the original ordering specified by the index to ensure the\n+ *  caller is able to match up the generated outputs to the correct silent\n+ *  payment address (e.g., to be able to assign the correct amounts to the\n+ *  correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key",
      "path": "include/secp256k1_silentpayments.h",
      "position": 126,
      "original_position": 128,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *  In:   recipient_scan_key: pointer to the recipient's 32 byte scan key\r\n```\r\nMaybe also consider calling this argument `recipient_scan_key32`. Same in `scan_outputs` and `create_shared_secrets`.",
      "created_at": "2025-03-17T09:09:34Z",
      "updated_at": "2025-03-17T10:57:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998277913",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998277913"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 126,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998345961",
      "pull_request_review_id": 2687486162,
      "id": 1998345961,
      "node_id": "PRRC_kwDOAP4Jqs53HFbp",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 537,
      "original_position": 162,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1874823508,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe best to explain the rationale of the combined flag (and tradeoffs) when the public data data structure is defined because it affects multiple functions.",
      "created_at": "2025-03-17T09:47:32Z",
      "updated_at": "2025-03-17T10:57:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998345961",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998345961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 537,
      "original_line": 537,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998357902",
      "pull_request_review_id": 2687486162,
      "id": 1998357902,
      "node_id": "PRRC_kwDOAP4Jqs53HIWO",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        /* TODO: We can declassify return value, because scalar set only fails if the seckey is invalid */\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        /* TODO: we can declassify return value */\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    /* TODO: can we declassify this? */\n+    /* Yes: We assume the adversary has access to a_sum_scalar*G */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    /* TODO: consider VERIFY_CHECK ??? */\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* TODO: clean up */\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            /* TODO: clean up */\n+            return 0;\n+        }\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    secp256k1_memclear(input_hash_local, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    secp256k1_memclear(&public_data->data[1 + pubkeylen], 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, then return */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    /* TODO: only fails in case of invalid key */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* consider clearing */\n+        return 0;\n+    }\n+    if (!secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey)) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        if (overflow) {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 532,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think it would be best if a properly created `public_data` object would only contain valid data. Then, the overflow check here would be unnecessary.\r\n\r\nTo detect uninitialized data structure from being passed to functions, we started using a 4 byte magic sequence in the musig module. See for example here, https://github.com/bitcoin-core/secp256k1/blob/70f149b9a1bf4ed3266f97774d0ae9577534bf40/src/modules/musig/session_impl.h#L55. As a result, the `_load` functions `ARG_CHECK` for the correct magic.",
      "created_at": "2025-03-17T09:53:39Z",
      "updated_at": "2025-03-17T10:57:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998357902",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998357902"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 529,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 532,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998365996",
      "pull_request_review_id": 2687486162,
      "id": 1998365996,
      "node_id": "PRRC_kwDOAP4Jqs53HKUs",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        /* TODO: We can declassify return value, because scalar set only fails if the seckey is invalid */\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        /* TODO: we can declassify return value */\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    /* TODO: can we declassify this? */\n+    /* Yes: We assume the adversary has access to a_sum_scalar*G */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    /* TODO: consider VERIFY_CHECK ??? */\n+    if (overflow) {\n+        return 0;\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 249,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The BIP does not specify the conversion from the input hash byte array to a scalar. In particular, it doesn't specify whether to fail on overflow or not.",
      "created_at": "2025-03-17T09:57:31Z",
      "updated_at": "2025-03-17T10:57:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998365996",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998365996"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 245,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 249,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998373467",
      "pull_request_review_id": 2687486162,
      "id": 1998373467,
      "node_id": "PRRC_kwDOAP4Jqs53HMJb",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+    secp256k1_xonly_pubkey tx_outputs[4];\n+    secp256k1_silentpayments_found_output found_outputs[4];\n+    unsigned char scalar[32];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[4][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+        {0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac},\n+        {0xe9,0x76,0xa5,0x8f,0xbd,0x38,0xae,0xb4,0xe6,0x09,0x3d,0x4d,0xf0,0x2e,0x9c,0x1d,0xe0,0xc4,0x51,0x3a,0xe0,0xc5,0x88,0xce,0xf6,0x8c,0xda,0x5b,0x2f,0x88,0x34,0xca}\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    unsigned char input_pubkey33[33];\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 4; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &data->public_data, input_pubkey33));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &data->public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 92,
      "original_position": 92,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Wouldn't the benchmarks be more helpful if the full tx scan also included public data creation because this is effectively what wallets do when encountering a transaction?",
      "created_at": "2025-03-17T10:01:07Z",
      "updated_at": "2025-03-17T10:57:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998373467",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998373467"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 92,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998496225",
      "pull_request_review_id": 2690052332,
      "id": 1998496225,
      "node_id": "PRRC_kwDOAP4Jqs53HqHh",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 107,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1992296737,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch - `k` is underspecified in the BIP. IIRC, we did have it specified as a uint32 in an earlier version of the BIP. I'll update it here to be `uint32` and make a note to update the BIP, as well.",
      "created_at": "2025-03-17T11:03:19Z",
      "updated_at": "2025-03-17T11:03:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998496225",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998496225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998525612",
      "pull_request_review_id": 2690101671,
      "id": 1998525612,
      "node_id": "PRRC_kwDOAP4Jqs53HxSs",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);\n+#ifndef VERIFY\n+    (void) ret;\n+#endif\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        /* TODO: We can declassify return value, because scalar set only fails if the seckey is invalid */\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        /* TODO: we can declassify return value */\n+        if (!ret) {\n+            /* TODO: clear a_sum_scalar */\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    /* TODO: can we declassify this? */\n+    /* Yes: We assume the adversary has access to a_sum_scalar*G */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    /* TODO: consider VERIFY_CHECK ??? */\n+    if (overflow) {\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* TODO: clean up */\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            /* TODO: clean up */\n+            return 0;\n+        }\n+        k++;\n+        last_recipient = *recipients[i];\n+    }\n+    /* Explicitly clear variables containing secret data */\n+    secp256k1_scalar_clear(&addend);\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+\n+    /* While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+     * could result in a third party being able to identify the transaction as a silent payments transaction\n+     * and potentially link the transaction back to a silent payment address\n+     */\n+    memset(&shared_secret, 0, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key, unsigned int m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labelled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labelled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    /* Serialize B_m */\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labelled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    secp256k1_memclear(input_hash_local, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    secp256k1_memclear(&public_data->data[1 + pubkeylen], 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, then return */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    /* TODO: only fails in case of invalid key */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        /* consider clearing */\n+        return 0;\n+    }\n+    if (!secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey)) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        if (overflow) {\n+            return 0;\n+        }\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k overflows the curve order, but this is statistically improbable\n+         */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 547,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1992340666,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The comment is indeed incorrect, since we aren't ever checking if the output of the hash function (`t_k`) overflows the curve order.\r\n\r\nI can have `_create_t_k` fail if `t_k_scalar` overflows, although this introduces a branch that we are unable to test (and is statistically improbable). This would, however, make the function more strictly adhere to the [specification](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki#creating-outputs)",
      "created_at": "2025-03-17T11:22:03Z",
      "updated_at": "2025-03-17T11:22:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998525612",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998525612"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 545,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 547,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998553073",
      "pull_request_review_id": 2690147582,
      "id": 1998553073,
      "node_id": "PRRC_kwDOAP4Jqs53H3_x",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set based on the original ordering of the addresses\n+ *  and used to return the generated outputs matching the original ordering.\n+ *  When more than one recipient is used, the recipient array will be sorted in\n+ *  place as part of generating the outputs, but the generated outputs will be\n+ *  returned in the original ordering specified by the index to ensure the\n+ *  caller is able to match up the generated outputs to the correct silent\n+ *  payment address (e.g., to be able to assign the correct amounts to the\n+ *  correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:   labelled_spend_pubkey: pointer to the resulting labelled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labelled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 241,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1993129528,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Not sure I follow. The linked PR implies I should remove the `SECP256K1_WARN_UNUSED_RESULT` if the function always returns 1, but in this case `_public_data_serialize` does not always return 1? ",
      "created_at": "2025-03-17T11:41:39Z",
      "updated_at": "2025-03-17T11:41:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998553073",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998553073"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 241,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998639584",
      "pull_request_review_id": 2690321765,
      "id": 1998639584,
      "node_id": "PRRC_kwDOAP4Jqs53INHg",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set based on the original ordering of the addresses\n+ *  and used to return the generated outputs matching the original ordering.\n+ *  When more than one recipient is used, the recipient array will be sorted in\n+ *  place as part of generating the outputs, but the generated outputs will be\n+ *  returned in the original ordering specified by the index to ensure the\n+ *  caller is able to match up the generated outputs to the correct silent\n+ *  payment address (e.g., to be able to assign the correct amounts to the\n+ *  correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:   recipient_scan_key: pointer to the recipient's scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful.\n+ *           0 if an error occured.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:   labelled_spend_pubkey: pointer to the resulting labelled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labelled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 241,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1993129528,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The PR removes `SECP256K1_WARN_UNUSED_RESULT` for functions that always return 1. The doc of `_public_data_serialize` indicates that this is such a function.\r\n\r\nLooking into `_public_data_serialize`, it seems like it cannot fail unless the API is used incorrectly or if input_hash is out of range. I think that public data create should only succeed when`input_hash` is in range.",
      "created_at": "2025-03-17T12:36:49Z",
      "updated_at": "2025-03-17T12:36:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998639584",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998639584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 241,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998806015",
      "pull_request_review_id": 2690639872,
      "id": 1998806015,
      "node_id": "PRRC_kwDOAP4Jqs53I1v_",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 225,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1995935100,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good point re: this being an example. I changed this to remove const from the declaration of `tx_output_ptrs`. This required adding a cast later on when `tx_output_ptrs` is used as the input to `scan_outputs`, but since this cast is _adding_ the const declaration, I think this is fine? ",
      "created_at": "2025-03-17T14:03:09Z",
      "updated_at": "2025-03-17T14:03:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1998806015",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1998806015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 219,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001570793",
      "pull_request_review_id": 2695519211,
      "id": 2001570793,
      "node_id": "PRRC_kwDOAP4Jqs53TYvp",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);",
      "path": "examples/silentpayments.c",
      "position": 249,
      "original_position": 231,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1995962243,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Doing a pass on the full header to make sure the documentation is consistent and up-to-date for all of the functions, will leave this comment open for now.",
      "created_at": "2025-03-18T17:21:10Z",
      "updated_at": "2025-03-18T17:21:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r2001570793",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001570793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 249,
      "original_line": 249,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001572540",
      "pull_request_review_id": 2695522004,
      "id": 2001572540,
      "node_id": "PRRC_kwDOAP4Jqs53TZK8",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+",
      "path": "examples/silentpayments.c",
      "position": 272,
      "original_position": 260,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "in_reply_to_id": 1678634760,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a verification step which demonstrates the usage of `create_labelled_spend_pubkey` and (hopefully) improved the variable naming a bit.",
      "created_at": "2025-03-18T17:22:05Z",
      "updated_at": "2025-03-18T17:22:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r2001572540",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001572540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 272,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001576328",
      "pull_request_review_id": 2695527576,
      "id": 2001576328,
      "node_id": "PRRC_kwDOAP4Jqs53TaGI",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &tx_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction\n+         * data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and\n+         * scanning as a light client.\n+         */\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+                 * and is using the resulting labelled spend pubkey to encode a\n+                 * labelled silent payments address.\n+                 */\n+                ret &= secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                ret &= secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            ret &= secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            if (!ret) {\n+                /* We need to always check that the public data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that public_data_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return 0;\n+            }\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret &= secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the public data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return 0;\n+            }\n+            if (n_found_outputs > 0) {\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");",
      "path": "examples/silentpayments.c",
      "position": 442,
      "original_position": 405,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1995968812,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a verification step which demonstrates calculating the full key. I'll also add a note to the API docs.",
      "created_at": "2025-03-18T17:23:27Z",
      "updated_at": "2025-03-18T17:23:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r2001576328",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001576328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 442,
      "original_line": 442,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001588012",
      "pull_request_review_id": 2695545764,
      "id": 2001588012,
      "node_id": "PRRC_kwDOAP4Jqs53Tc8s",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set based on the original ordering of the addresses\n+ *  and used to return the generated outputs matching the original ordering.\n+ *  When more than one recipient is used, the recipient array will be sorted in\n+ *  place as part of generating the outputs, but the generated outputs will be\n+ *  returned in the original ordering specified by the index to ensure the\n+ *  caller is able to match up the generated outputs to the correct silent\n+ *  payment address (e.g., to be able to assign the correct amounts to the\n+ *  correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 42,
      "original_position": 44,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1998263939,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree, this is pretty confusing. Perhaps `spend_pubkey` can be renamed to `labelled_spend_pubkey`, with a comment mentioning that the label is optional? Something like:\r\n\r\n```\r\n/**\r\n * ...\r\n * `lablled_spend_pubkey` is the spend public key with an (optional) label tweak applied. \r\n * If no label tweak is applied, `labelled_spend_pubkey` is the recipients spend public key.\r\n * ...\r\n */\r\ntypedef struct {\r\n    secp256k1_pubkey scan_pubkey;\r\n    secp256k1_pubkey labelled_spend_pubkey;\r\n...\r\n```",
      "created_at": "2025-03-18T17:27:51Z",
      "updated_at": "2025-03-18T17:27:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r2001588012",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001588012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 42,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001600548",
      "pull_request_review_id": 2695562630,
      "id": 2001600548,
      "node_id": "PRRC_kwDOAP4Jqs53TgAk",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+    secp256k1_xonly_pubkey tx_outputs[4];\n+    secp256k1_silentpayments_found_output found_outputs[4];\n+    unsigned char scalar[32];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[4][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+        {0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac},\n+        {0xe9,0x76,0xa5,0x8f,0xbd,0x38,0xae,0xb4,0xe6,0x09,0x3d,0x4d,0xf0,0x2e,0x9c,0x1d,0xe0,0xc4,0x51,0x3a,0xe0,0xc5,0x88,0xce,0xf6,0x8c,0xda,0x5b,0x2f,0x88,0x34,0xca}\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    unsigned char input_pubkey33[33];\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 4; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &data->public_data, input_pubkey33));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &data->public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": 92,
      "original_position": 92,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1998373467,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good point, will update.",
      "created_at": "2025-03-18T17:32:11Z",
      "updated_at": "2025-03-18T17:32:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r2001600548",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001600548"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 92,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001606682",
      "pull_request_review_id": 2695574531,
      "id": 2001606682,
      "node_id": "PRRC_kwDOAP4Jqs53Thga",
      "diff_hunk": "@@ -322,4 +322,308 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+    int ser_ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\n+    VERIFY_CHECK(ser_ret && pubkeylen == 65);\n+    (void)ser_ret;\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    ret &= secp256k1_pubkey_load(ctx, &A_sum_ge, &A_sum);\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    /* If there is something wrong with the recipient scan key, recipient spend pubkey, or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 537,
      "original_position": 162,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "94c6e1f54299dfc83aa34bc92f9f861808449a23",
      "in_reply_to_id": 1874823508,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agreed - will update with a detailed comment.",
      "created_at": "2025-03-18T17:35:14Z",
      "updated_at": "2025-03-18T17:35:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r2001606682",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2001606682"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 537,
      "original_line": 537,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2004105742",
      "pull_request_review_id": 2699837625,
      "id": 2004105742,
      "node_id": "PRRC_kwDOAP4Jqs53dDoO",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 225,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1995935100,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I haven't checked the code, but is the new cast really necessary? An explicit cast shouldn't be necessary if you're casting to a more \"restricted\" type.",
      "created_at": "2025-03-19T19:11:46Z",
      "updated_at": "2025-03-19T19:11:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r2004105742",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2004105742"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 219,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2005257053",
      "pull_request_review_id": 2702033928,
      "id": 2005257053,
      "node_id": "PRRC_kwDOAP4Jqs53hctd",
      "diff_hunk": "@@ -0,0 +1,543 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (memcmp(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    const secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        char* address_amounts[N_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            (secp256k1_xonly_pubkey **)tx_output_ptrs,",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 225,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1995935100,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I had thought the same, but this is the warning I get when I remove the cast:\r\n\r\n```\r\n/root/secp256k1/examples/silentpayments.c: In function ‘main’:\r\n/root/secp256k1/examples/silentpayments.c:421:17: warning: passing argument 4 of ‘secp256k1_silentpayments_recipient_scan_outputs’ from incompatible pointer type [-Wincompatible-pointer-types]\r\n  421 |                 tx_output_ptrs, N_OUTPUTS,\r\n      |                 ^~~~~~~~~~~~~~\r\n      |                 |\r\n      |                 secp256k1_xonly_pubkey **\r\nIn file included from /root/secp256k1/examples/silentpayments.c:14:\r\n/root/secp256k1/include/secp256k1_silentpayments.h:342:43: note: expected ‘const secp256k1_xonly_pubkey * const*’ but argument is of type ‘secp256k1_xonly_pubkey **’\r\n  342 |     const secp256k1_xonly_pubkey * const *tx_outputs,\r\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\r\n[100%] Linking C executable ../bin/silentpayments_example\r\n[100%] Built target silentpayments_example\r\n```",
      "created_at": "2025-03-20T10:18:35Z",
      "updated_at": "2025-03-20T10:18:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r2005257053",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2005257053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 219,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2006144436",
      "pull_request_review_id": 2703591241,
      "id": 2006144436,
      "node_id": "PRRC_kwDOAP4Jqs53k1W0",
      "diff_hunk": "@@ -0,0 +1,674 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 74,
      "original_position": 74,
      "commit_id": "592f2517c44c25009e3021d06ff4ed9c8eee9069",
      "original_commit_id": "71df073ade5bf54d593ce95a2fdaefe3552318d0",
      "in_reply_to_id": 1992409713,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Out of curiosity, I tried implementing x-only ecdh using `secp256k1_ecmult_const_xonly` here: https://github.com/josibake/secp256k1/commit/e7ec39eac44fdf704d24c931f3725d9b90edb02b\r\n\r\nWhen I ran the benchmarks between the old and the new, I didn't see any speedup. This means:\r\n\r\n1. I didn't implement the x-only ECDH correctly\r\n2. The benchmark is not accurate\r\n3. The speedup doesn't make a noticeable difference in the context of scanning\r\n\r\n@real-or-random @sipa others have indeed picked it up, but it's a small enough group that I think we could sneak in a breaking change and coordinate an update if there is a compelling enough reason to do so. Assuming 3) is correct, this doesn't seem like a compelling enough speedup to warrant a breaking change. However, it would be great if someone could double check my work as I'm a bit skeptical of my results.\r\n\r\nMy results:\r\n\r\n```\r\n❯ ./new/bin/bench silentpayments\r\nBenchmark                     ,    Min(us)    ,    Avg(us)    ,    Max(us)\r\n\r\nsilentpayments_full_tx_scan   ,    98.1       ,    98.2       ,    98.7\r\nsilentpayments_output_scan    ,    74.5       ,    74.6       ,    74.8\r\n\r\n❯ ./old/bin/bench silentpayments\r\nBenchmark                     ,    Min(us)    ,    Avg(us)    ,    Max(us)\r\n\r\nsilentpayments_full_tx_scan   ,    98.3       ,    98.3       ,    98.3\r\nsilentpayments_output_scan    ,    74.5       ,    74.5       ,    74.6\r\n```",
      "created_at": "2025-03-20T17:36:01Z",
      "updated_at": "2025-03-20T17:36:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r2006144436",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2006144436"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    }
  ]
}