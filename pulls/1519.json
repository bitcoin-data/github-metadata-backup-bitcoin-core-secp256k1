{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519",
    "id": 1831748262,
    "node_id": "PR_kwDOAP4Jqs5tLkKm",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1519.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1519.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/00b0cb19a97718dfaab70aa7505ff157f22a31bd",
    "number": 1519,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add BIP352 `silentpayments` module",
    "user": {
      "login": "josibake",
      "id": 7444140,
      "node_id": "MDQ6VXNlcjc0NDQxNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/josibake",
      "html_url": "https://github.com/josibake",
      "followers_url": "https://api.github.com/users/josibake/followers",
      "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
      "organizations_url": "https://api.github.com/users/josibake/orgs",
      "repos_url": "https://api.github.com/users/josibake/repos",
      "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/josibake/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This PR adds a new Silent Payments ([BIP352](https://github.com/bitcoin/bips/pull/1458)) module to secp256k1. It is a continuation of the work started in https://github.com/bitcoin-core/secp256k1/pull/1471.\r\n\r\nThe module implements the full protocol, except for transaction input filtering and silent payment address encoding / decoding as those will be the responsibility of the wallet software. It is organized with functions for sending (prefixed with `_sender`) and receiving (prefixed by `_recipient`).\r\n\r\n#### For sending\r\n\r\n1. Collect private keys into two lists: `taproot_seckeys` and `plain_seckeys`\r\n    Two lists are used since the `taproot_seckeys` may need negation. `taproot_seckeys` are passed as keypairs to avoid the function needing to compute the public key to determine parity. `plain_seckeys` are passed as just secret keys\r\n2. Create the `_silentpayment_recipient` objects\r\n    These structs hold the scan and spend public key and an index for remembering the original ordering. It is expected that a caller will start with a list of silent payment addresses (with the desired amounts), convert these into an array of `recipients` and then match the generated outputs back to the original silent payment addresses. The index is used to return the generated outputs in the original order\r\n3. Call `silentpayments_sender_create_outputs` to generate the xonly public keys for the recipients\r\n    This function can be called with one or more recipients. The same recipient may be repeated to generate multiple outputs for the same recipient\r\n    \r\n#### For scanning\r\n\r\n1. Collect the public keys into two lists `taproot_pubkeys` and `plain_pubeys`\r\n    This avoids the caller needing to convert taproot public keys into compressed public keys (and vice versa)\r\n2. Compute the input data needed, i.e. sum the public keys and compute the `input_hash`\r\n    This is done as a separate step to allow the caller to reuse this output if scanning for multiple scan keys. It also allows a caller to use this function for aggregating the transaction inputs and storing them in an index to vend to light clients later (or for faster rescans when recovering a wallet)\r\n4. Call `silentpayments_recipient_scan_outputs` to scan the transaction outputs and return the tweak data (and optionally label information) needed for spending later\r\n\r\nIn addition, a few utility functions for labels are provided for the recipient for creating a label tweak and tweaked spend public key for their address. Finally, two functions are exposed in the API for supporting light clients, `_recipient_created_shared_secret` and `_recipient_create_output_pubkey`. These functions enable incremental scanning for scenarios where the caller does not have access to the transaction outputs:\r\n\r\n1. Calculating a shared secret\r\n    This is done as a separate step to allow the caller to reuse the shared secret result when creating outputs and avoid needing to do a costly ECDH every time they need to check for an additional output\r\n3. Generate an output (with `k = 0`)\r\n5. Check if the output exists in the UTXO set (using their preferred light client protocol)\r\n6. If the output exists, proceed by generating a new output from the shared secret with `k++`\r\n\r\nSee `examples/silentpayments.c` for a demonstration of how the API is expected to be used.\r\n\r\n### Note for reviewers\r\n\r\nMy immediate goal is to get feedback on the API so that I can pull this module into https://github.com/bitcoin/bitcoin/pull/28122 (silent payments in the bitcoin core wallet). That unblocks from finishing the bitcoin core PRs while work continues on this module.\r\n\r\n#### Notable differences between this PR and the previous version\r\n\r\nSee https://github.com/bitcoin-core/secp256k1/issues/1427 and https://github.com/bitcoin-core/secp256k1/pull/1471 for discussions on the API design. This iteration of the module attempts to be much more high level and incorporate the feedback from #1471. I also added a `secp256k1_silentpayments_public_data` opaque data type, which contains the summed public key and the input_hash. My motivation here was:\r\n\r\n1. I caught myself mixing up the order of arguments between `A_sum` and `recipient_spend_key`, which was impossible to catch with `ARG_CHECKS` and would result in the scanning process finishing without errors, but not finding any outputs\r\n2. Combining public key and input_hash into the same data type allows for completely hiding `input_hash` from the caller, which makes for an overall simpler API IMO\r\n\r\nI also removed the need for the recipient to generate a shared secret before using the `secp256k1_silentpayments_recipient_scan_outputs` function and instead create the shared secret inside the function.\r\n\r\n### Outstanding work\r\n\r\n- [ ] clean up the testing code\r\n- [ ] improve test coverage (currently only using the BIP352 test vectors)\r\n- [ ] optimize the implementation, where possible",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "created_at": "2024-04-19T14:21:15Z",
    "updated_at": "2024-07-31T15:28:59Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "merge_commit_sha": "ad6735619b55f5c5c1eb79564da97af2226b941a",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "josibake:bip352-silentpayments-module",
      "ref": "bip352-silentpayments-module",
      "sha": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 751433786,
        "node_id": "R_kgDOLMn4Og",
        "name": "secp256k1",
        "full_name": "josibake/secp256k1",
        "owner": {
          "login": "josibake",
          "id": 7444140,
          "node_id": "MDQ6VXNlcjc0NDQxNDA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/josibake",
          "html_url": "https://github.com/josibake",
          "followers_url": "https://api.github.com/users/josibake/followers",
          "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
          "organizations_url": "https://api.github.com/users/josibake/orgs",
          "repos_url": "https://api.github.com/users/josibake/repos",
          "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/josibake/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/josibake/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/josibake/secp256k1",
        "archive_url": "https://api.github.com/repos/josibake/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/josibake/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/josibake/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/josibake/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/josibake/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/josibake/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/josibake/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/josibake/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/josibake/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/josibake/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/josibake/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/josibake/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/josibake/secp256k1/events",
        "forks_url": "https://api.github.com/repos/josibake/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/josibake/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/josibake/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/josibake/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/josibake/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/josibake/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/josibake/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/josibake/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/josibake/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/josibake/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/josibake/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/josibake/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/josibake/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/josibake/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/josibake/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/josibake/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:josibake/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/josibake/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/josibake/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/josibake/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/josibake/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/josibake/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/josibake/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/josibake/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/josibake/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/josibake/secp256k1/hooks",
        "svn_url": "https://github.com/josibake/secp256k1",
        "language": "C",
        "forks_count": 1,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 12452,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-28T14:23:56Z",
        "created_at": "2024-02-01T15:52:50Z",
        "updated_at": "2024-07-11T13:28:09Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "0055b86780f2aa7272a1c307f6b9cd298584340f",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 978,
        "stargazers_count": 2021,
        "watchers_count": 2021,
        "size": 11949,
        "default_branch": "master",
        "open_issues_count": 138,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-29T19:30:32Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2024-07-29T22:01:34Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 9541,
    "deletions": 12,
    "changed_files": 22,
    "commits": 9,
    "review_comments": 171,
    "comments": 27
  },
  "events": [
    {
      "event": "labeled",
      "id": 12541859026,
      "node_id": "LE_lADOAP4Jqs6GTERUzwAAAALrjZTS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12541859026",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-19T16:18:02Z",
      "label": {
        "name": "feature",
        "color": "731E95"
      }
    },
    {
      "event": "reviewed",
      "id": 2015096769,
      "node_id": "PRR_kwDOAP4Jqs54G-_B",
      "url": null,
      "actor": null,
      "commit_id": "3d080277895655e8274ee73aacd154c4ead143e3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nLeft some initial feedback, especially around the scanning routine, will do an in-depth review round soon. Didn't look closer at the `public_data` type routines and the examples yet.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2015096769",
      "submitted_at": "2024-04-22T16:26:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12588114369,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAALuT2HB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12588114369",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T08:38:21Z"
    },
    {
      "event": "commented",
      "id": 2074419309,
      "node_id": "IC_kwDOAP4Jqs57pSBt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2074419309",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T08:45:36Z",
      "updated_at": "2024-04-24T08:45:36Z",
      "author_association": "MEMBER",
      "body": "Rebased on #1518 (https://github.com/bitcoin-core/secp256k1/commit/3d080277895655e8274ee73aacd154c4ead143e3 -> https://github.com/bitcoin-core/secp256k1/commit/8b48bf19c3c020e653734f6c9d9364e6a47a30d1, [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-01..josibake:secp256k1:bip352-silentpayments-module-rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2074419309",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12588974018,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAALuXH_C",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12588974018",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T09:38:43Z"
    },
    {
      "event": "commented",
      "id": 2074531708,
      "node_id": "IC_kwDOAP4Jqs57ptd8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2074531708",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T09:39:20Z",
      "updated_at": "2024-04-24T09:39:20Z",
      "author_association": "MEMBER",
      "body": "Updated https://github.com/bitcoin-core/secp256k1/commit/8b48bf19c3c020e653734f6c9d9364e6a47a30d1 -> https://github.com/bitcoin-core/secp256k1/commit/f5585d4b93606144e76e45ad3d43a797a9afefcf ([bip352-silentpayments-module-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-rebase) -> [bip352-silentpayments-module-02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-02), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-rebase..josibake:secp256k1:bip352-silentpayments-module-02)):\r\n\r\n* Fix function documentation for `_recipient_scan_outputs`\r\n* Replace `VERIFY_CHECK` with `return 0;` in `_sender_create_outputs`\r\n* Remove unneeded `declassify` code from `_sender_create_outputs`\r\n* Change `_gej_add_ge` to `_gej_add_var` in `_recipient_public_data_create`\r\n* Fix label scanning in `_recipient_scan_outputs`\r\n* Remove unneeded prints from the tests\r\n\r\nFor the label scanning, I looked for an example of using an invalid public key but didn't see anything except for the `invalid_pubkey_bytes` in the tests. For now, if the output is found without a label, I'm setting `found_with_label = 0` and saving the found output in both the `output` and `label` field. Happy to change this if there is a better suggestion for communicating an invalid public key.\r\n\r\nI also used `secp256k1_pubkey_save` instead of `output = *tx_outputs`, as I think this makes the code more clear.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2074531708",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "reviewed",
      "id": 2026864465,
      "node_id": "PRR_kwDOAP4Jqs54z39R",
      "url": null,
      "actor": null,
      "commit_id": "f5585d4b93606144e76e45ad3d43a797a9afefcf",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Second review round through, looks good so far! Left a bunch of nits, mostly about naming and missing ARG_CHECKS etc.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2026864465",
      "submitted_at": "2024-04-28T01:45:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12693217589,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAL0kyE1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693217589",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:03:39Z"
    },
    {
      "event": "mentioned",
      "id": 12693287039,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAL0lDB_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693287039",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:10:24Z"
    },
    {
      "event": "subscribed",
      "id": 12693287051,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAL0lDCL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693287051",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:10:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12693404541,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAL0lft9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693404541",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:21:32Z"
    },
    {
      "event": "commented",
      "id": 2092544520,
      "node_id": "IC_kwDOAP4Jqs58ubII",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2092544520",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:25:39Z",
      "updated_at": "2024-05-03T08:25:39Z",
      "author_association": "MEMBER",
      "body": "Thanks for the thorough review, @theStack ! I've addressed your feedback, along with some other changes.\r\n\r\n---\r\nUpdate https://github.com/bitcoin-core/secp256k1/commit/f5585d4b93606144e76e45ad3d43a797a9afefcf -> https://github.com/bitcoin-core/secp256k1/commit/1a3a00bd0999a89e30d5dc9f927592ead72ab7a3 ([bip352-silentpayments-module-02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-02) -> [bip352-silentpayments-module-03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-03), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-02..josibake:secp256k1:bip352-silentpayments-module-03))\r\n\r\n* Spelling and wording cleanups, notably:\r\n  *  `s/receiver/recipient/`, `s/labeled/labelled/`\r\n  * `s/scan_seckey/scan_key/`\r\n* Reduce duplicate code in `scan_outputs`\r\n* Add `ARG_CHECK`s\r\n* Update tests\r\n* Add benchmark for `scan_outputs`\r\n\r\nThe sending tests now check that the generated outputs match exactly one of the possible expected output sets. Previously, the sending tests were checking that the generated outputs exist in the array of all possible outputs, but this wouldn't catch a bug where `k` is not being set correctly e.g.  *[A<sub>k=0</sub>, B<sub>k=0</sub>]* would (incorrectly) pass *[A<sub>k=0</sub>, B<sub>k=1</sub>, A<sub>k=1</sub>, B<sub>k=0</sub>]* but will now (correctly) fail *[[A<sub>k=0</sub>, B<sub>k=1</sub>], [A<sub>k=1</sub>, B<sub>k=0</sub>]]*",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2092544520",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 12693448859,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAL0lqib",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693448859",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:25:40Z"
    },
    {
      "event": "subscribed",
      "id": 12693448875,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAL0lqir",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12693448875",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T08:25:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12695113793,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAL0sBBB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12695113793",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T11:11:55Z"
    },
    {
      "event": "commented",
      "id": 2092802286,
      "node_id": "IC_kwDOAP4Jqs58vaDu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2092802286",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-03T11:17:30Z",
      "updated_at": "2024-05-03T11:17:30Z",
      "author_association": "MEMBER",
      "body": "Rebased on #1518 https://github.com/bitcoin-core/secp256k1/commit/1a3a00bd0999a89e30d5dc9f927592ead72ab7a3 -> https://github.com/bitcoin-core/secp256k1/commit/92f592023f3f4d6a66724772349fbdc4967ab50f ([bip352-silentpayments-module-03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-03) -> [bip352-silentpayments-module-03-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-03-rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-03..josibake:secp256k1:bip352-silentpayments-module-03-rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2092802286",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12743423674,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAL3kTa6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12743423674",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-08T12:48:24Z"
    },
    {
      "event": "commented",
      "id": 2100507478,
      "node_id": "IC_kwDOAP4Jqs59MzNW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2100507478",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-08T12:50:33Z",
      "updated_at": "2024-05-08T12:50:33Z",
      "author_association": "MEMBER",
      "body": "Rebased on master (following #1518 merge) https://github.com/bitcoin-core/secp256k1/commit/92f592023f3f4d6a66724772349fbdc4967ab50f -> https://github.com/bitcoin-core/secp256k1/commit/56ed901b6a2239e8b44a1a3f084bd38b9e86d769 ([bip352-silentpayments-module-03-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-03-rebase) -> [bip352-silentpayments-module-04-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-04-rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-03-rebase..josibake:secp256k1:bip352-silentpayments-module-04-rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2100507478",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "reviewed",
      "id": 2082332210,
      "node_id": "PRR_kwDOAP4Jqs58Hd4y",
      "url": null,
      "actor": null,
      "commit_id": "56ed901b6a2239e8b44a1a3f084bd38b9e86d769",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Went through another round. To the best of my knowledge, this PR matches the BIP352 specification and I'm close to non-cryptographer-light-ACKing it :-)\r\n\r\nFound some nits an one open TODO that should probably be discussed though.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2082332210",
      "submitted_at": "2024-05-28T18:19:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12999995271,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMG3C-H",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/12999995271",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T12:34:48Z"
    },
    {
      "event": "commented",
      "id": 2142009213,
      "node_id": "IC_kwDOAP4Jqs5_rHd9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142009213",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T12:36:59Z",
      "updated_at": "2024-05-31T12:36:59Z",
      "author_association": "MEMBER",
      "body": "Rebased on master to fix merge conflict https://github.com/bitcoin-core/secp256k1/commit/56ed901b6a2239e8b44a1a3f084bd38b9e86d769 ->  https://github.com/bitcoin-core/secp256k1/commit/bd66eaa22acf434f0134d7f93c4fb694303708c3 ([bip352-silentpayments-module-04-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-04-rebase) -> [bip352-silentpayments-module-05-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-05-rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-04-rebase..josibake:secp256k1:bip352-silentpayments-module-05-rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142009213",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2142037343,
      "node_id": "IC_kwDOAP4Jqs5_rOVf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142037343",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T12:45:21Z",
      "updated_at": "2024-05-31T12:45:21Z",
      "author_association": "MEMBER",
      "body": "CI failure seems related to not being able to install valgrind via homebrew and unrelated to my change so ignoring for now (cc @real-or-random for confirmation?). ",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142037343",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13000125756,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMG3i08",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13000125756",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T12:45:22Z"
    },
    {
      "event": "subscribed",
      "id": 13000125772,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMG3i1M",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13000125772",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T12:45:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13000777915,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMG6CC7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13000777915",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T13:37:03Z"
    },
    {
      "event": "commented",
      "id": 2142198112,
      "node_id": "IC_kwDOAP4Jqs5_r1lg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142198112",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T13:45:02Z",
      "updated_at": "2024-05-31T13:45:02Z",
      "author_association": "MEMBER",
      "body": "Thanks for the review @theStack ! Sorry for the slow response, I somehow missed the notification for your review :sweat_smile: \r\n\r\n---\r\n\r\nUpdate https://github.com/bitcoin-core/secp256k1/commit/bd66eaa22acf434f0134d7f93c4fb694303708c3 -> https://github.com/bitcoin-core/secp256k1/commit/2dde8f1fa13687d2bd8328f85ac412a4052b040c ([bip352-silentpayments-module-05-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-05-rebase) -> [bip352-silentpayments-module-06](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-06), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-05-rebase..josibake:secp256k1:bip352-silentpayments-module-06))\r\n\r\n* spelling, grammar, and fixups per @theStack 's review\r\n* Added `ARG_CHECK`s to check for the sum of the private keys / public keys being zero\r\n\r\nPer https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617720108, I agree returning 0 is not the right thing to do, but having multiple error codes also seemed gross. I think an `ARG_CHECK` makes sense here because if the caller passed all valid seckeys / pubkeys and then they sum to zero, in principle its the caller passing incorrect arguments. The only thing the caller can do at this point is try again with different arguments. For the sender, this would mean repeating coin selection to get a different input set, and for the recipient this would mean skipping the transaction and moving on to the next one. Also happy to change if there is a better suggestion!",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142198112",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13000887002,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMG6cra",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13000887002",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T13:45:03Z"
    },
    {
      "event": "subscribed",
      "id": 13000887022,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMG6cru",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13000887022",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T13:45:03Z"
    },
    {
      "event": "commented",
      "id": 2142338498,
      "node_id": "IC_kwDOAP4Jqs5_sX3C",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142338498",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T14:22:24Z",
      "updated_at": "2024-05-31T14:22:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "> CI failure seems related to not being able to install valgrind via homebrew and unrelated to my change so ignoring for now (cc @real-or-random for confirmation?). \r\n\r\nIndeed, see https://github.com/bitcoin-core/secp256k1/issues/1536\r\n\r\n",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142338498",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13001464326,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMG8poG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13001464326",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T14:22:25Z"
    },
    {
      "event": "subscribed",
      "id": 13001464349,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMG8pod",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13001464349",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T14:22:25Z"
    },
    {
      "event": "commented",
      "id": 2142599641,
      "node_id": "IC_kwDOAP4Jqs5_tXnZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142599641",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T16:23:47Z",
      "updated_at": "2024-05-31T16:24:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "\r\n## Some general notes\r\n### On error handling in general\r\nError handling is hard, and the caller usually can't really recover from an error anyway. This is in particular true on malicious inputs:  there's no reason to try to continue dealing with the attacker, and you simply want to abort. That's why, as a general rule, we try to avoid error paths as much as possible. This usually boils down to merging all errors into a single one, i.e., *a)* have just a single error \"code\" for all possible errors, *b)* and in the case of a multi-stage thing involving multiple function calls, have just a single place where errors are returned. \r\n\r\nSignature verification is a good example. A (signature, message, pubkey) triple is either valid or not. The caller *should not* care why exactly a signature fails to verify, so we don't even want to expose this to the caller.\r\n\r\n However, signature verification this is also a nice example of a case in which we stretch the rules a bit. Signature verification is implemented as two-stage process: 1. Parse the public key (which can fail). 2. Check the signature (which can fail). Purely from a \"safe\" API point of view, this is not great because we give the user two functions and two error paths instead of one. Ideally, there could just be one verification function which also takes care of parsing (this is how it's defined BIP340). The primary reason why we want to have a separate parsing function in this case is performance: if you check several signatures under the same key, you don't want to parse, which involves computing the y-coordinate, every time.\r\n\r\n### ARG_CHECK\r\n`ARG_CHECK` will call the \"illegal (argument) callback\", which, by default, crashes. See the docs here: https://github.com/bitcoin-core/secp256k1/blob/1791f6fce4d4856a4ce2b1982768a4ffa23fcc0a/include/secp256k1.h#L324 The callback/crash indicates to the caller that there's a bug in the caller's code.\r\n\r\n## What does this mean for this discussion?\r\n> * Added `ARG_CHECK`s to check for the sum of the private keys / public keys being zero\r\n> \r\n> \r\n> Per [#1519 (comment)](https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617720108), I agree returning 0 is not the right thing to do, but having multiple error codes also seemed gross. I think an `ARG_CHECK` makes sense here because if the caller passed all valid seckeys / pubkeys and then they sum to zero, in principle its the caller passing incorrect arguments. The only thing the caller can do at this point is try again with different arguments. For the sender, this would mean repeating coin selection to get a different input set, and for the recipient this would mean skipping the transaction and moving on to the next one. Also happy to change if there is a better suggestion!\r\n\r\nSo let's take a look at the two sides:\r\n\r\n### On the sender side: The secret keys sum up to zero (`sum_i a_i = 0`)\r\nThis will happen only with negligible probability for honestly generated (=random) secret keys. That is, this will in practice only happen if the caller has a bug, or the caller has been tricked into using these secret keys, e.g., if someone else has crafted malicious secret keys for the caller. Since the latter is not a crazy scenario, we should not use `ARG_CHECK` here. \r\n\r\nWe can just return 0 here to indicate to the caller that we can't continue with these function inputs. And even if there are other error cases, I don't see a reason why the caller code should care much about why the function fails. As long as you call the function with honestly generated inputs, everything will work out. (Devs will be interested in the exact failure case when debugging the caller's code, but I think they can figure out during debugging then. \"Normal\" caller code should get just a single error code.)\r\n\r\n### On the recipient side: The public keys sum up to infinity (`sum_i A_i = 0`) [1]\r\nAgain, this can only happen if the sender is malicious. But since we're not the sender, it's entirely possible that the sender is malicious. And then these inputs are certainly legal, they're just not valid. (In the same sense as it's perfectly legal to use the signature verification algorithm on an invalid signature.) So an `ARG_CHECK` will not be appropriate at all: a malicious sender could trigger it and crash the scanning process. \r\n\r\nWe should also simply return 0 to indicate that this transaction is not well-formed/not eligible for SP. And again, even if there are other error cases, I don't see a reason why the caller should care why this transaction is not eligible.\r\n\r\nAlternatively, we could even return 1, store infinity in the `public_data`, and simply make sure that scanning won't find any payments in that case.  This would avoid the error path for this function entirely. But if the caller then calls `secp256k1_silentpayments_recipient_create_shared_secret`, I think we'd just postpone the error to this function, and for this function, I don't see another way than returning an error. So I'm not convinced that this is better. \r\n\r\n\r\n[1] We should perhaps rename \"infinity\" to \"zero\"... ;)\r\n",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142599641",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2142745728,
      "node_id": "IC_kwDOAP4Jqs5_t7SA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2142745728",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T18:06:38Z",
      "updated_at": "2024-06-01T12:08:10Z",
      "author_association": "MEMBER",
      "body": "@real-or-random thanks for the response, this is super helpful.\r\n\r\n> Devs will be interested in the exact failure case when debugging the caller's code, but I think they can figure out during debugging then\r\n\r\nIn hindsight, I think my preference for `ARG_CHECK` was \"better error messages as to what went wrong,\" but I now realize it was because I was thinking as a dev ;). Also an oversight on my part: I didn't realize/forgot that `ARG_CHECK` is actually crashing the program by default. I certainly agree that we don't want this in either failure case.\r\n\r\n> Alternatively, we could even return 1, store infinity in the public_data, and simply make sure that scanning won't find any payments in that case. This would avoid the error path for this function entirely. But if the caller then calls secp256k1_silentpayments_recipient_create_shared_secret, I think we'd just postpone the error to this function, and for this function, I don't see another way than returning an error. So I'm not convinced that this is better.\r\n\r\nIf we imagine an index + light client scenario, the `public_data` would be created by the index and then sent to the light client, where the light client would call `secp256k1_silentpayments_recipient_create_shared_secret` (and then get the error). Given this, I think it would be better to have the error path so that the index ends up not storing any data at all for the malicious crafted transaction, which saves space for the index and bandwidth for the light client.\r\n\r\n---\r\n\r\nThinking about this a bit more:\r\n\r\n> That's why, as a general rule, we try to avoid error paths as much as possible. This usually boils down to merging all errors into a single one, i.e., a) have just a single error \"code\" for all possible errors, b) and in the case of a multi-stage thing involving multiple function calls, have just a single place where errors are returned.\r\n\r\nMost of the high-level functions in our API are calling multiple lower-level functions and so far the approach has been something like:\r\n\r\n```\r\nif (!secp256k1_func_that_returns_0_on_error(args)) {\r\n    return 0;\r\n}\r\n...\r\nif (!secp256k1_another_func_that_returns_0_on_error(args)) {\r\n    return 0;\r\n}\r\n```\r\n\r\n~~Perhaps its worth looking to consolidate and try and only return an error at the end of a multi-stage process? This would mean ignoring the return values for a lot of the lower level function calls, which initially made me feel a bit weird. But in light of your recent comment, feels like this might be the preferred approach?~~\r\n\r\nEDIT: reading your comment again, I realize \"error paths\" is not really talking about branches in the code and more error paths for the user.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142745728",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13004201610,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMHHF6K",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13004201610",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T18:06:39Z"
    },
    {
      "event": "subscribed",
      "id": 13004201641,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMHHF6p",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13004201641",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T18:06:39Z"
    },
    {
      "event": "commented",
      "id": 2143167510,
      "node_id": "IC_kwDOAP4Jqs5_viQW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2143167510",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-01T00:23:18Z",
      "updated_at": "2024-06-01T00:23:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "> We should also simply return 0 to indicate that this transaction is not well-formed/not eligible for SP. And again, even if there are other error cases, I don't see a reason why the caller should care why this transaction is not eligible.\r\n\r\nMakes sense. My worry was that without an explicit error-code for this corner case, some users wouldn't even be aware of an indirect \"not eligible\" case and more likely interpret a return value of 0 as \"only possible if there's a logic error on our side, so let's assert for success\" (given the passed in data is public and already verified for consensus-validity). But in the end that's more a matter of good API documentation I guess.\r\n\r\nAn example for the \"input public keys sum up to point of infinity\" case ($\\sum_i A_i = 0$) is now available on the Signet chain via tx [d73f4a19f3973e90af6df62e735bb7b31f3d5ab8e7e26e7950651b436d093313](https://mempool.space/signet/tx/d73f4a19f3973e90af6df62e735bb7b31f3d5ab8e7e26e7950651b436d093313) [1], mined in block 198023. It consists of two inputs spending P2WPKH prevouts with negated pubkeys $(x,y)$ and $(x,-y)$ (easy to verify by looking at the second item of the witness stack each, where only the first byte for encoding the sign bit differs), and one dummy P2TR output. It hopefully helps SP implementations to identify potential problems with this corner case early. As first example and proof that it triggers the discussed code path, it makes the Silent Payment Index PR [#28241](https://github.com/bitcoin/bitcoin/pull/28241) crash, which asserts on a return value of 1 for `_recipient_public_data_create`.\r\n\r\nI think it would be also a good idea to add this scenario to the BIP352 test vectors, or at least a unit test in this PR?\r\n\r\n[1] created with the following Python script: https://github.com/theStack/bitcoin/blob/202405-contrib-bip352_input_pubkeys_cancelled/contrib/silentpayments/submit_input_pubkeys_infinity_tx.py",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2143167510",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2144837459,
      "node_id": "IC_kwDOAP4Jqs5_159T",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2144837459",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-03T10:24:32Z",
      "updated_at": "2024-06-03T10:24:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "> \r\n> ~Perhaps its worth looking to consolidate and try and only return an error at the end of a multi-stage process? This would mean ignoring the return values for a lot of the lower level function calls, which initially made me feel a bit weird. But in light of your recent comment, feels like this might be the preferred approach?~\r\n> \r\n> EDIT: reading your comment again, I realize \"error paths\" is not really talking about branches in the code and more error paths for the user.\r\n\r\nRight, it's about avoiding errors that the user would need to deal with, e.g., by more branches on the user side. So the idea is that to try to avoid complexity in the user code, perhaps at the cost of adding complexity to our code. But let me also add that this and most all of what I above is more a rule of thumb than a strict policy.\r\n\r\n> > We should also simply return 0 to indicate that this transaction is not well-formed/not eligible for SP. And again, even if there are other error cases, I don't see a reason why the caller should care why this transaction is not eligible.\r\n> \r\n> Makes sense. My worry was that without an explicit error-code for this corner case, some users wouldn't even be aware of an indirect \"not eligible\" case and more likely interpret a return value of 0 as \"only possible if there's a logic error on our side, so let's assert for success\" (given the passed in data is public and already verified for consensus-validity). But in the end that's more a matter of good API documentation I guess.\r\n\r\nOkay, I see the concern. And I agree, this should probably be a matter of documentation. I think, assuming our code is correct, there won't be a reason to return 0 unless there's something wrong with the transaction (invalid public key, keys sum up to 0), and we should just list these reasons in the docs.\r\n\r\n> I think it would be also a good idea to add this scenario to the BIP352 test vectors, or at least a unit test in this PR?\r\n\r\nIndeed, this should be in the BIP, ideally even in the pseudocode. If our code starts to reject \"payments\", then better be authorized by the standard. And I believe it's the right approach: There's no need to add complexity to implementations to deal with these malicious cases.[^1]\r\n\r\n\r\n[^1]: One thing to keep in mind are multi-sender scenarios where blaming the malicious participant could be hard. Say honest A and B have pkA and pkB, and malicious C then claims to have pkC = -(pkA + pkC) s.t. pkA + pkB + pkC = 0. And then A and B can't conclude that C is malicious. We run into such a thing in the MuSig BIP, see the first paragraph of https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki#dealing-with-infinity-in-nonce-aggregation. But IIUC this cannot happen here since C needs to show a signature under pkC.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2144837459",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "subscribed",
      "id": 13034935158,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMI8VN2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13034935158",
      "actor": {
        "login": "sethforprivacy",
        "id": 40500387,
        "node_id": "MDQ6VXNlcjQwNTAwMzg3",
        "avatar_url": "https://avatars.githubusercontent.com/u/40500387?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sethforprivacy",
        "html_url": "https://github.com/sethforprivacy",
        "followers_url": "https://api.github.com/users/sethforprivacy/followers",
        "following_url": "https://api.github.com/users/sethforprivacy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sethforprivacy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sethforprivacy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sethforprivacy/subscriptions",
        "organizations_url": "https://api.github.com/users/sethforprivacy/orgs",
        "repos_url": "https://api.github.com/users/sethforprivacy/repos",
        "events_url": "https://api.github.com/users/sethforprivacy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sethforprivacy/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T11:37:20Z"
    },
    {
      "event": "referenced",
      "id": 13207691565,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMTPWEt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13207691565",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "1ceb0b6986563854e0ffad280b4362821307ba50",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/1ceb0b6986563854e0ffad280b4362821307ba50",
      "created_at": "2024-06-18T22:47:19Z"
    },
    {
      "event": "referenced",
      "id": 13221274861,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMUDKTt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13221274861",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "bbc706cf4f336c74b831966f61fa334d257a5288",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/bbc706cf4f336c74b831966f61fa334d257a5288",
      "created_at": "2024-06-19T22:11:18Z"
    },
    {
      "event": "referenced",
      "id": 13221312587,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMUDThL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13221312587",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a96df5abcbecb669427dd041a6d8c25e106536c2",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/a96df5abcbecb669427dd041a6d8c25e106536c2",
      "created_at": "2024-06-19T22:19:55Z"
    },
    {
      "event": "referenced",
      "id": 13221333509,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMUDYoF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13221333509",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "3623b60784398b08abc6f9e74a9f74d51f4f2dea",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/3623b60784398b08abc6f9e74a9f74d51f4f2dea",
      "created_at": "2024-06-19T22:24:38Z"
    },
    {
      "event": "referenced",
      "id": 13221373766,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMUDidG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13221373766",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "fe0f83531e35f76d3582813da4cbb518d9bb1d12",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/fe0f83531e35f76d3582813da4cbb518d9bb1d12",
      "created_at": "2024-06-19T22:33:46Z"
    },
    {
      "event": "referenced",
      "id": 13221425667,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMUDvID",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13221425667",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "630466657557b073549f02c130de7bf5799b1cfa",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/630466657557b073549f02c130de7bf5799b1cfa",
      "created_at": "2024-06-19T22:44:51Z"
    },
    {
      "event": "referenced",
      "id": 13247893873,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMVotFx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13247893873",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "59cc43d727000794f18dac0a502cd87c0daec22a",
      "commit_url": "https://api.github.com/repos/theStack/bips/commits/59cc43d727000794f18dac0a502cd87c0daec22a",
      "created_at": "2024-06-21T23:58:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13339201347,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMbFA9D",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13339201347",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-29T11:58:30Z"
    },
    {
      "event": "commented",
      "id": 2198126844,
      "node_id": "IC_kwDOAP4Jqs6DBMD8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2198126844",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-29T12:01:18Z",
      "updated_at": "2024-06-29T12:01:18Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/2dde8f1fa13687d2bd8328f85ac412a4052b040c -> https://github.com/bitcoin-core/secp256k1/commit/ac591050262d9d00b629943d598f62b47e1ca7ae ([bip352-silentpayments-module-06](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-06) -> [bip352-silentpayments-module-07](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-07), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-06..josibake:secp256k1:bip352-silentpayments-module-07))\r\n\r\n* Removes `ARG_CHECKS` for the sum to zero / infinity case\r\n* Adds the new test vector for sum to zero / infinity\r\n* Minor fix ups, e.g., `s/receiver/recipient`",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2198126844",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13377472438,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMdXAe2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13377472438",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-03T09:22:36Z"
    },
    {
      "event": "commented",
      "id": 2205622493,
      "node_id": "IC_kwDOAP4Jqs6DdyDd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2205622493",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-03T09:57:36Z",
      "updated_at": "2024-07-03T10:04:14Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/ac591050262d9d00b629943d598f62b47e1ca7ae -> https://github.com/bitcoin-core/secp256k1/commit/5dd552ccbb5243047e0ad967561796f15a42bfbb ([bip352-silentpayments-module-07](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-07) -> [bip352-silentpayments-module-08](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-08), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-07..josibake:secp256k1:bip352-silentpayments-module-08))\r\n\r\n(note: I also included a rebase inadvertently, so I rebased the `-07-rebase` branch as well to make comparing the diff easier with this [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-07-rebase..josibake:secp256k1:bip352-silentpayments-module-08) link)\r\n\r\nThe main change in this push is adding full test coverage for the module API. To make this easier, I ended up re-organizing the commits so that everything for sending is one commit, everything for labelled address is one commit, and everything for receiving is one commit. While this does make each commit larger, I think overall this makes things easier to review. I find it especially helpful to have the API tests in the same commit as it makes it easier to reason on how the functions will be used and makes it easy to modify the tests during testing to exercise the API.\r\n\r\nWhile adding the tests, I made the following implementation changes:\r\n\r\n* Only have `ARG_CHECKS` in functions exposed in the API. This meant removing `ARG_CHECKS` from some functions and adding them to others\r\n* Accumulate errors in a return value (i.e., use `ret &= func` instead of `if (!func) { return 0 }`\r\n  * In many cases where we were returning early, I couldn't think of a way to trigger an error in the function since the error would have already been caught with an `ARG_CHECK` or when initializing a struct. In these cases, it seemed better to remove the if branch and instead accumulate the error so that the function will still fail if an error is ever encountered\r\n* Some stylistic changes, e.g., comments and rewriting `ARG_CHECK` parsing for clarity\r\n\r\nRunning `gcov` after these changes shows that the test coverage for the module is ~100% :smile: \r\n![image](https://github.com/bitcoin-core/secp256k1/assets/7444140/fc3d8b26-5110-49ae-97db-447ea439092e)\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2205622493",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2205624871,
      "node_id": "IC_kwDOAP4Jqs6Ddyon",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2205624871",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-03T09:58:21Z",
      "updated_at": "2024-07-03T09:58:21Z",
      "author_association": "MEMBER",
      "body": "Not quite sure what is happening with the CI failures, since it looks like the all of the tests and examples are passing. Will investigate more and push a fix.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2205624871",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13380049035,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMdg1iL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13380049035",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-03T12:40:51Z"
    },
    {
      "event": "commented",
      "id": 2205997958,
      "node_id": "IC_kwDOAP4Jqs6DfNuG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2205997958",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-03T12:47:27Z",
      "updated_at": "2024-07-03T12:47:27Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/5dd552ccbb5243047e0ad967561796f15a42bfbb -> https://github.com/bitcoin-core/secp256k1/commit/1136e0c6aa6884d67d984d62f480986b9824db99\r\n\r\nCI was failing due to the benchmark executable. In the previous push, I added an `ARG_CHECK` that if a `label_lookup` callback is passed, `label_cache` cannot be NULL. However, I didn't run the benchmarks locally and missed that the benchmark was calling `_scan_outputs` with a label lookup callback but NULL labels cache. Fixed by passing a noop labels cache pointer. This is fine since the purpose of using the `label_lookup` in the benchmark isn't to actually scan for labels but to make sure that the label lookup branch of the code gets triggered during the benchmark.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2205997958",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "reviewed",
      "id": 2161055368,
      "node_id": "PRR_kwDOAP4Jqs6AzxaI",
      "url": null,
      "actor": null,
      "commit_id": "1136e0c6aa6884d67d984d62f480986b9824db99",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Looks generally good to me, I think the new structuring of the commits makes sense and reviewing is easier. One thing that should be taken care of (which I also only became fully aware of recently while reviewing the MuSig2 PR) is cleaning out secrets, as stated in CONTRIBUTING.md:\r\n\r\nhttps://github.com/bitcoin-core/secp256k1/blob/ca06e58b2ce18d170546ad13429fb9319451f48a/CONTRIBUTING.md?plain=1#L50\r\n\r\nI believe this should be applied at least to the following local variables (probably also to the shared secret ones):\r\n\r\n- `tweaked_secret_component` in `_create_shared_secret`\r\n- `a_sum_scalar`, `addend`, `a_sum` in `_sender_create_outputs`",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2161055368",
      "submitted_at": "2024-07-05T17:19:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2211644697,
      "node_id": "IC_kwDOAP4Jqs6D0wUZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2211644697",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-06T05:07:25Z",
      "updated_at": "2024-07-06T05:07:25Z",
      "author_association": "NONE",
      "body": "Looks good to me overall.\r\n\r\nWhy does `secp256k1_silentpayments_sender_create_outputs` have `const secp256k1_silentpayments_recipient **recipients` as parameter instead of `const secp256k1_silentpayments_recipient *recipients` ?\r\nIs there a specific reason for this ?\r\n `const secp256k1_silentpayments_recipient **recipients` can be somewhat confusing. Why not have a pointer to the first element of an array of `secp256k1_silentpayments_recipient` structures ?",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2211644697",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13436446210,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMg3-YC",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13436446210",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:06:52Z"
    },
    {
      "event": "commented",
      "id": 2217167478,
      "node_id": "IC_kwDOAP4Jqs6EJ0p2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2217167478",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:36:58Z",
      "updated_at": "2024-07-09T09:36:58Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/1136e0c6aa6884d67d984d62f480986b9824db99 -> https://github.com/bitcoin-core/secp256k1/commit/8ce68efb9511124877d50e40bcea1563e1384ef8 ([bip352-silentpayments-module-08](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-08) -> [bip352-silentpayments-module-09](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-09), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-08..josibake:secp256k1:bip352-silentpayments-module-09))\r\n\r\nPrimarily:\r\n\r\n* Replace `secp256k1_ecdh` with `ecmult_const`\r\n* Refactor `create_shared_secret`\r\n* Clear secrets at each stage\r\n\r\nI noticed while clearing the secrets that we were creating the shared secrets in a really inefficient way:\r\n\r\n* deserialize `unsigned char` seckeys into `secp256k1_scalars` and add them\r\n* serialize the summed scalar back to unsigned char so it can be passed to `secp256k1_ecdh`\r\n* deserialize inside `secp256k1_ecdh` back to a scalar :man_facepalming:, call `ecmult_const`\r\n* serialize the resulting point coordinates to unsigned char and pass them to the noop hash function\r\n* deserialize the unsigned char x,y pair back into a point :man_facepalming:\r\n* serialize the point into a compressed public key\r\n\r\nInstead, I opted to remove `secp256k1_ecdh` and just calculate the the shared secret directly with `ecmult_const`. This avoids a lot of back and forth with serializing and deserializing and allowed me to remove the rather complicated noop hash function. Since `secp256k1_ecdh` is calling `ecmult_const` under the hood, this should be the same. However, I did notice that `_cmov` is being called inside `secp256k1_ecdh`, which led me down a bit of a rabbit hole. I left some `TODO` comments in places where we deserialize the secret keys into scalars for future reviewers, because I'm not quite sure what the right approach here is (cc the friendly neighborhood cryptographers @real-or-random , @jonasnick ).\r\n\r\nI also refactored the `create_shared_secret` function to avoid needing to create an intermediate tweaked scalar, which also improves the readability of the code imo.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2217167478",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13436902021,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMg5tqF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13436902021",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:36:59Z"
    },
    {
      "event": "subscribed",
      "id": 13436902042,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMg5tqa",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13436902042",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:36:59Z"
    },
    {
      "event": "mentioned",
      "id": 13436902067,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMg5tqz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13436902067",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:37:00Z"
    },
    {
      "event": "subscribed",
      "id": 13436902089,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMg5trJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13436902089",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:37:00Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13437109160,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMg6gOo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13437109160",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:50:53Z"
    },
    {
      "event": "commented",
      "id": 2217198944,
      "node_id": "IC_kwDOAP4Jqs6EJ8Vg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2217198944",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:52:42Z",
      "updated_at": "2024-07-09T09:52:42Z",
      "author_association": "MEMBER",
      "body": "Update https://github.com/bitcoin-core/secp256k1/commit/8ce68efb9511124877d50e40bcea1563e1384ef8 -> https://github.com/bitcoin-core/secp256k1/commit/a31a105e6dd9446be7694226fac0e8e7bfafe300 ([bip352-silentpayments-module-09](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-09) -> [bip352-silentpayments-module-10](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-10), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-09..josibake:secp256k1:bip352-silentpayments-module-10))\r\n\r\n* Also clear `recipient_scan_key` whenever it is loaded as a scalar (missed in the last push)",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2217198944",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "commented",
      "id": 2217225367,
      "node_id": "IC_kwDOAP4Jqs6EKCyX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2217225367",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T10:04:58Z",
      "updated_at": "2024-07-09T10:04:58Z",
      "author_association": "MEMBER",
      "body": "> Why does `secp256k1_silentpayments_sender_create_outputs` have `const secp256k1_silentpayments_recipient **recipients` as parameter instead of `const secp256k1_silentpayments_recipient *recipients` ?\r\n> Is there a specific reason for this ?\r\n\r\nThanks for the review, @jlest01 ! For the `_recipient` structs specifically, a pointer to an array of pointers is preferable for sorting the recipients in place. With an array of pointers each entry is 8 bytes vs with recipient structs each entry is ~136 bytes, making it more efficient to move the pointers around.\r\n\r\nIn general, pointers to an array of pointers is preferred as it provides more flexibility for the caller. For example, if the caller is using `n` inputs that all have the same public key, they can initialize the `secp256k1_pubkey` object once and then create a pointer to it `n` times. This is more efficient than requiring them to initialize `n` structs for the same public key.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2217225367",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13437325206,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMg7U-W",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13437325206",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T10:04:59Z"
    },
    {
      "event": "subscribed",
      "id": 13437325233,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMg7U-x",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13437325233",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T10:04:59Z"
    },
    {
      "event": "commented",
      "id": 2217447402,
      "node_id": "IC_kwDOAP4Jqs6EK4_q",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2217447402",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T11:54:35Z",
      "updated_at": "2024-07-09T11:54:35Z",
      "author_association": "NONE",
      "body": "Thanks for the clarification @josibake . Just out of curiosity. Is there a PR in bitcoin core that uses the interface being implemented here ?\r\nI would like to better understand how this interface is intended to interact with Bitcoin Core classes.",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2217447402",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13438810706,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMhA_pS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13438810706",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T11:54:37Z"
    },
    {
      "event": "subscribed",
      "id": 13438810721,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMhA_ph",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13438810721",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T11:54:37Z"
    },
    {
      "event": "reviewed",
      "id": 2166196376,
      "node_id": "PRR_kwDOAP4Jqs6BHYiY",
      "url": null,
      "actor": null,
      "commit_id": "a31a105e6dd9446be7694226fac0e8e7bfafe300",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Tested that `tests_silentpayments_generate.py` indeed produces `silentpayments/vectors.h` with the latest vectors. \r\n\r\n```\r\n6618bd9d3361f68ed0cdc139ec7c66365d81b6ce87c2119905225fab8ab833c9  send_and_receive_test_vectors.json\r\n```\r\n\r\nMaybe move the changes in `src/modules/silentpayments/tests_impl.h` to their own commit? It would make it slightly easier to review changes (before merge) in the test vectors vs. changes to their usage.\r\n\r\nI'm having a hard time modifying any of the test vectors in a way that makes the test fail. See one suggestion inline for a sanity check you could add. See also #1568.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2166196376",
      "submitted_at": "2024-07-09T12:38:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2166304629,
      "node_id": "PRR_kwDOAP4Jqs6BHy91",
      "url": null,
      "actor": null,
      "commit_id": "a31a105e6dd9446be7694226fac0e8e7bfafe300",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I find the send and receive example easy to follow (despite some feedback - and minus the label stuff), which suggests that this is a good interface.\r\n",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2166304629",
      "submitted_at": "2024-07-09T14:30:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "commented",
      "id": 2218081934,
      "node_id": "IC_kwDOAP4Jqs6ENT6O",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2218081934",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T15:58:23Z",
      "updated_at": "2024-07-09T15:58:23Z",
      "author_association": "MEMBER",
      "body": "Thanks for the review, @Sjors !\r\n\r\n> Maybe move the changes in `src/modules/silentpayments/tests_impl.h` to their own commit?\r\n\r\nThis is how it was structured before, but I found it much easier to work with having the tests in the same commit where functions are added to the API. This allows you to easily make changes to the API and the relevant tests in the same commit and also lets reviews step through each commit and verify that the commit compiles and passes the tests.\r\n\r\nWill digest your feedback on the `examples/silentpayments.c` and update!\r\n\r\n---\r\n\r\n> Just out of curiosity. Is there a PR in bitcoin core that uses the interface being implemented here ?\r\n\r\n@jlest01 all of the Bitcoin Core PRs can be found here: https://github.com/bitcoin/bitcoin/issues/28536\r\n\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2218081934",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13442724276,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMhP7G0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13442724276",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T15:58:25Z"
    },
    {
      "event": "subscribed",
      "id": 13442724295,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMhP7HH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13442724295",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T15:58:25Z"
    },
    {
      "event": "mentioned",
      "id": 13442724307,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMhP7HT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13442724307",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T15:58:25Z"
    },
    {
      "event": "subscribed",
      "id": 13442724315,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMhP7Hb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13442724315",
      "actor": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T15:58:25Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDM1ZjkxMzU5YjgwYmZlYzAzYmJiY2YzODdmNTVmODRiNTNiMzJjZWE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/35f91359b80bfec03bbbcf387f55f84b53b32cea",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/35f91359b80bfec03bbbcf387f55f84b53b32cea",
      "tree": {
        "sha": "d7cd96185024d43ac7b44e74f3615197ba298481",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/d7cd96185024d43ac7b44e74f3615197ba298481"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree d7cd96185024d43ac7b44e74f3615197ba298481\nparent 0055b86780f2aa7272a1c307f6b9cd298584340f\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1695828134 +0200\ncommitter josibake <josibake@protonmail.com> 1720704877 +0200\n\nbuild: add skeleton for new silentpayments (BIP352) module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmaP320ACgkQity1WMTz\nPWVOJA/9F/nigtobMZ3vQEn/LxB9xabKw2/ALi0pDeCYVU/Srgf7y97GjyZvZL3c\nGU7JTWwZtQHiooC9l7gXMNgZTgpOEZ5Tjr17Hnq9D2Ky58un/KinUjPlPW5k3PBb\nw2IgLeW4ClZmv0d4rqvIOYBNolylO2ZIPnLPG4r5prhHqrKRSGHCjqx7LE2RmUhK\nsCBMFrTaWLDHOTyCe1afqFNyxPVCYdTgSakIDr1630TgfwYJqh2ihzIWf2NCKdVU\nJnDiJ4QidROAyVLezp5xtRRSYd+LSLli31cNlNst8zplaaapfiU6esU8gi1gOQng\nDqgDrMI3CXwGheG0qmSalB3ZZFA1sgsID1Ce3+4BhXSf1xRSccYTr6XtiNbUznKj\navE+fn+kG3w5zpddNgcatAUtl1aa1EfahMBJWp0jVaK+x0bdMOYK5PB/0KTT/qlO\nz7FsLugg49CzbJCwNEyfh9rIFRXz4ARZJE5IbWGav6z6xvs46ZSxLhKdhaJgMz12\nDCkAZqjWoMZzQHpIVaOmT+fWBeVMThbrhOVJaGNpyIvZ7Ea6YmMHe6PraxU9a6Rp\nIR49++zqhI0zqZ0BTr2CnKUG0BxHPUjtKbSuXpnqoQe7d3yeCYSjfn2k1lil/e/C\nbL3mqNE/ILpgOuEgkM8JhFr7syKpW5I3q/UXhJbSzirfHPd3plk=\n=wE3Z\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0055b86780f2aa7272a1c307f6b9cd298584340f",
          "sha": "0055b86780f2aa7272a1c307f6b9cd298584340f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0055b86780f2aa7272a1c307f6b9cd298584340f"
        }
      ],
      "message": "build: add skeleton for new silentpayments (BIP352) module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-11T13:34:37Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2023-09-27T15:22:14Z"
      },
      "sha": "35f91359b80bfec03bbbcf387f55f84b53b32cea"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13472398761,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMjBH2p",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472398761",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:03:37Z"
    },
    {
      "event": "commented",
      "id": 2223031089,
      "node_id": "IC_kwDOAP4Jqs6EgMMx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2223031089",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:05:29Z",
      "updated_at": "2024-07-11T14:05:29Z",
      "author_association": "MEMBER",
      "body": "Rebased to fix merge conflict",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2223031089",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13472559797,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMjBvK1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472559797",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:14:50Z"
    },
    {
      "event": "commented",
      "id": 2223072145,
      "node_id": "IC_kwDOAP4Jqs6EgWOR",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2223072145",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:21:54Z",
      "updated_at": "2024-07-11T14:21:54Z",
      "author_association": "MEMBER",
      "body": "Updated https://github.com/bitcoin-core/secp256k1/commit/4a8b707fa84819dda7a663a92c0e32f519f9bacf -> https://github.com/bitcoin-core/secp256k1/commit/0c63b8b1911ef1183f411a5e232165b543c668ea ([bip352-silentpayments-module-10-rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-10-rebase) -> [bip352-silentpayments-module-11](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-11), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-10-rebase..josibake:secp256k1:bip352-silentpayments-module-11))\r\n\r\n* Add the json test vectors from the BIP and ensure the Makefile is aware of changes to the test vectors\r\n* Update the example based on feedback from @Sjors \r\n* Update the API documentation\r\n* No API/implementation changes\r\n\r\nPer @real-or-random 's comment https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673641829, I removed details about the protocol internals from a few spots in the API documentation. The caller already needs to be familiar with BIP352 before using this library considering this library does not do things like get the smallest outpoint, filter the transaction inputs, or extract the public keys from the inputs. Given that, I agree its better to keep the documentation here focused on API usage and not on explaining how BIP352 works under the hood.\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2223072145",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13472662045,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMjCIId",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472662045",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:21:56Z"
    },
    {
      "event": "subscribed",
      "id": 13472662072,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMjCII4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472662072",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:21:56Z"
    },
    {
      "event": "mentioned",
      "id": 13472662102,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMjCIJW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472662102",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:21:56Z"
    },
    {
      "event": "subscribed",
      "id": 13472662125,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMjCIJt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13472662125",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:21:56Z"
    },
    {
      "event": "reviewed",
      "id": 2173313611,
      "node_id": "PRR_kwDOAP4Jqs6BiiJL",
      "url": null,
      "actor": null,
      "commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2173313611",
      "submitted_at": "2024-07-12T00:24:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2174199522,
      "node_id": "PRR_kwDOAP4Jqs6Bl6bi",
      "url": null,
      "actor": null,
      "commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I think the example is really helpful, and I don't really have ideas to improve conceptually. (That's why I have mostly just nits.)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2174199522",
      "submitted_at": "2024-07-12T09:25:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "reviewed",
      "id": 2174287912,
      "node_id": "PRR_kwDOAP4Jqs6BmQAo",
      "url": null,
      "actor": null,
      "commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "The module should also be mentioned in the README",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2174287912",
      "submitted_at": "2024-07-12T09:26:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13487799340,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMj73ws",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487799340",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T13:58:55Z"
    },
    {
      "event": "commented",
      "id": 2225664151,
      "node_id": "IC_kwDOAP4Jqs6EqPCX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2225664151",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:20Z",
      "updated_at": "2024-07-12T14:07:20Z",
      "author_association": "MEMBER",
      "body": "Updated https://github.com/bitcoin-core/secp256k1/commit/0c63b8b1911ef1183f411a5e232165b543c668ea -> https://github.com/bitcoin-core/secp256k1/commit/602e11d910083582b139f2c45045c27e26805b92 ([bip352-silentpayments-module-11](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-11) -> [bip352-silentpayments-module-12](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-12), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-11..josibake:secp256k1:bip352-silentpayments-module-12))\r\n\r\n* Updated the `label_lookup` function to take a 33-byte pubkey serialization (as opposed to a `secp256k1_pubkey`) (h/t @real-or-random)\r\n* Made `_sort` and `_create_shared_secret` void functions and added a few tests to verify all cases are covered (h/t @theStack)\r\n* Updated comments in the example to make it more clear that labels is an optional feature (h/t @Sjors)\r\n* General spelling and formatting fix ups\r\n* Added a commit for the `README`\r\n\r\nThe diff looks rather large, but its mostly formatting and spelling fixes. Thanks @Sjors , @real-or-random , @theStack for the thorough review!\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2225664151",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13487919691,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMj8VJL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919691",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "subscribed",
      "id": 13487919713,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMj8VJh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919713",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "mentioned",
      "id": 13487919732,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMj8VJ0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919732",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "subscribed",
      "id": 13487919742,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMj8VJ-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919742",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "mentioned",
      "id": 13487919759,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMj8VKP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919759",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "subscribed",
      "id": 13487919769,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMj8VKZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13487919769",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-12T14:07:22Z"
    },
    {
      "event": "reviewed",
      "id": 2175311571,
      "node_id": "PRR_kwDOAP4Jqs6BqJ7T",
      "url": null,
      "actor": null,
      "commit_id": "602e11d910083582b139f2c45045c27e26805b92",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2175311571",
      "submitted_at": "2024-07-12T17:14:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDc5NTYyZDBjZDExNmNhYWExNjAwOTRlNzcyNDVlMDc4MWI0MzQyZDc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/79562d0cd116caaa160094e77245e0781b4342d7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/79562d0cd116caaa160094e77245e0781b4342d7",
      "tree": {
        "sha": "1cdb22a7332278a9e69ff4d1507f3e36f3cba9ce",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/1cdb22a7332278a9e69ff4d1507f3e36f3cba9ce"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 1cdb22a7332278a9e69ff4d1507f3e36f3cba9ce\nparent 35f91359b80bfec03bbbcf387f55f84b53b32cea\nauthor josibake <josibake@protonmail.com> 1711383817 +0100\ncommitter josibake <josibake@protonmail.com> 1720954165 +0200\n\nsilentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key\n\nFinally, add tests for the sender API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmaTrTwACgkQity1WMTz\nPWWxNA//czSt0MaG4A/cj5JNEcLZd0Z+wV9+ALCvKuxeTpvQkA11nBt/cCawIkwe\nKaBqDncgLRsag6PiSRc7npeFa0cN8lETBZhW8zRC0P5z0LvqS0CFCSkQEmVjOISS\nU+/S8eVa3htIp8Tn/ot3/HxiyAECZhg1JEOccjN+D8a0jvdolVR5QlG24X852TnH\nIquNHs0QXxqPchqpVHSCtErc5fY9aF53sayLN3l07NA3SG/kdFWI8gOv3mMU/Zvn\nk6LTT/9pchxIeEeMRUmZuip/tvSjT4NXd1C2b0PrgNE7dDZjqjSgapkE55ZXE5fK\nal6jk3B3hiNnvoZtHX1HVXM/u0/dZq985iBhZr6oOH7X4ODcmqYIQCxowHNrUDjM\nojdLsYGcAY/daadTuAgH5Mzc29Bt+oFCCxqE/wCyPZwGDw+02PQZVcBLzbt7Bfoo\nKxLohHmD/G1Ct7U33NLqkZUwZX8FMUtpyqeG+Wl1q5AvubVYVaDRXArPg5Q8+YJe\n3kxgDeZ3rPRatixM38jLm4wBxVSbgbmfvwKD6sH0tibmMimMCtl32j5Bvx0WXJB9\ntRFlgDkRGq7q0RW+nDsXxmqsYtc38LV5cdCrPCJgNW9oWUqL0hmmjmGO1ejAbZLA\nz3Y6gWLN6Qnc72hE4idFxpMqfXbbDQGV/FsPNT/v41eiqA3NmoE=\n=BHfV\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/35f91359b80bfec03bbbcf387f55f84b53b32cea",
          "sha": "35f91359b80bfec03bbbcf387f55f84b53b32cea",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/35f91359b80bfec03bbbcf387f55f84b53b32cea"
        }
      ],
      "message": "silentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key\n\nFinally, add tests for the sender API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-14T10:49:25Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-03-25T16:23:37Z"
      },
      "sha": "79562d0cd116caaa160094e77245e0781b4342d7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDIzYzdhZWFkNjM3NGFmOWU2YWU5MTI4MjA5ZTc3MzA0YWNjODMzZDQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/23c7aead6374af9e6ae9128209e77304acc833d4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/23c7aead6374af9e6ae9128209e77304acc833d4",
      "tree": {
        "sha": "ba1b7aef1b7d327e882da1a2ff347182d57708b7",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ba1b7aef1b7d327e882da1a2ff347182d57708b7"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ba1b7aef1b7d327e882da1a2ff347182d57708b7\nparent 79562d0cd116caaa160094e77245e0781b4342d7\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1705946165 +0100\ncommitter josibake <josibake@protonmail.com> 1720954180 +0200\n\nsilentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labelled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labelled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labelled\nsilent payment address.\n\nAdd tests for the label API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmaTrUQACgkQity1WMTz\nPWVjCBAAqQDHnGahdgcCJyisfXtJe7MaXZvIZbAmdyxB3h3XAMzbGZ56C533rll1\npHjr290X+MGDzIRuPt97ZlLNka+rxunicI0w16lFMI7ZnyNCG3sa7IWF5eKDvPFl\nzzaBNZPbR5jOdGX1C63/saD3BVZVZeEDtr9ty+a7ipyZI+65CCS1J2qZQUFfHFbR\nquxJWpwFZDDPWeNUQyDwfYZo3YwBrzAUQ5DKm90rlxCLfE3VoEwF0U+NHruud7aO\nwYkpQoJKS/oA2SsQHAL4hkl1RrazzDGTKHI+4D/8gkDaSVdv8QDlYlHgsSghb1x6\nbgG0HawvHxpYDGhQHaEB4r1oiMflEZMi4VeqO1A93gTKABBe4SqBru+m91ds0+nu\nloz0Df+OhRULvfFF1gCz+7qQoSZ6VZqD4rOxWLJfTwchJnSwtuonLyqyii+2L0nD\nEEJbXx4Vu30A0RqicTbhoH6/fcgE+mBRImixXVAnL0DwUXo3lZ3Cw6ENMvfOaim1\ntjmyuLv7f3lHaJdJ42S07SONMwrBjc5+bFQ/DWVUcwFo1J7MwI1EB/ZldZNbOHEJ\n09A4hITA8RFdE+3PNaijki0aEveHy5fDGTkiZWIISVdLzOqTQCUA3miX3Xcdv6Ac\nre6S8M2hgxcMqt/A9vBBIUZoRQhIgYNZsJ2jBsyxt6G8mjgdIuA=\n=3lGk\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/79562d0cd116caaa160094e77245e0781b4342d7",
          "sha": "79562d0cd116caaa160094e77245e0781b4342d7",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/79562d0cd116caaa160094e77245e0781b4342d7"
        }
      ],
      "message": "silentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labelled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labelled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labelled\nsilent payment address.\n\nAdd tests for the label API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-14T10:49:40Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-01-22T17:56:05Z"
      },
      "sha": "23c7aead6374af9e6ae9128209e77304acc833d4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGI0NDc1ZWE4MGMxZDFmZjA1MWNjOGRlMTg1NmQ0YTZiYTZkODdkZWY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b4475ea80c1d1ff051cc8de1856d4a6ba6d87def",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b4475ea80c1d1ff051cc8de1856d4a6ba6d87def",
      "tree": {
        "sha": "36f608dd5f645d237e0e0950d7015e5e2ca92565",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/36f608dd5f645d237e0e0950d7015e5e2ca92565"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 36f608dd5f645d237e0e0950d7015e5e2ca92565\nparent 23c7aead6374af9e6ae9128209e77304acc833d4\nauthor josibake <josibake@protonmail.com> 1719660810 +0200\ncommitter josibake <josibake@protonmail.com> 1720955824 +0200\n\nsilentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the summed input public key (A_sum)\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply b_scan * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a public_data object to\nand from a public key. When serializing a public_data object, the\ninput_hash is multplied into A_sum. This is so the object can be stored\nas public key for wallet rescanning later, or to vend to light clients.\nFor the light client, a `_parse` function is added which parses the\ncompressed public key serialization into a `public_data` object.\n\nFinally, add test coverage for the recieiving API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmaTs7cACgkQity1WMTz\nPWWt2Q/+LhtlPZLNtuRbCf6tstMpR4+ggLNyBBQpPuxr+FPHncCETAFgX/VQKLWI\nlIe2V2EyO1tNs8IAFsEmmqQ42X2vRSWaOgVq8uWxPw9j4RKjZnAj83tGdEh68NeG\n88beWBvtHkhFEKqrrluddDw/dOFnATH0OrH4AdSzLPScjkKF7gwi7LIku1IfmyD6\nLKcoYTQTSHB7JVfAt+giqqahee6gh98u+QZZH0qkzupvL0+wdsvflEhbbHnO1fTc\nwxU7sSnv5TBP/jgRwD+rS5LfLoLx2vZaNHfdJVYRJ31cRtiBlXqDP57RpAb9zZcD\n+rO6YADjl0gL9oMw8WDylnWlQEKJeGTColJ+DVGGNl5a7qzHqNyitQJfWwgCN9b5\ngDYh7m7YFKBhM6MLAdYn7frDfLrb+mkgFr8zsXQ8znQ3LtLw4ru8M3/Tj9/DdWnJ\n65m85De6i9fSXUdaaDR+NzvabkwjgRr779P1HUrsk6OX3JFzWPo8/zxu3VboviqE\nnF1JycG3CFsXHOm/7TU3pEQaRGDV1Y+wr/Ojk9eHC5UHEA2+siXv1bTTPfm6/EbN\nAmOrLuJ9kkHtzK1XiWKCeu2C8N/fXBwp59RCfF8Wu0A69H/Tt/7mdqXuHSJlSZJY\nnfzA8Sb0J8J+LHNS/yC9CMJAK8tcp1jhyPUZX7ajbWh8gqQ+Bxc=\n=qqbg\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/23c7aead6374af9e6ae9128209e77304acc833d4",
          "sha": "23c7aead6374af9e6ae9128209e77304acc833d4",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/23c7aead6374af9e6ae9128209e77304acc833d4"
        }
      ],
      "message": "silentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the summed input public key (A_sum)\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply b_scan * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a public_data object to\nand from a public key. When serializing a public_data object, the\ninput_hash is multplied into A_sum. This is so the object can be stored\nas public key for wallet rescanning later, or to vend to light clients.\nFor the light client, a `_parse` function is added which parses the\ncompressed public key serialization into a `public_data` object.\n\nFinally, add test coverage for the recieiving API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-14T11:17:04Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-06-29T11:33:30Z"
      },
      "sha": "b4475ea80c1d1ff051cc8de1856d4a6ba6d87def"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDkxYjFiMzM2NWJkNWRkYmJkODQzOTAwMGYxODg5M2MwZjBlNmE5YjU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/91b1b3365bd5ddbbd8439000f18893c0f0e6a9b5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/91b1b3365bd5ddbbd8439000f18893c0f0e6a9b5",
      "tree": {
        "sha": "03d43ff59ffe13f2cddaeba5a6842db63930e7a0",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/03d43ff59ffe13f2cddaeba5a6842db63930e7a0"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 03d43ff59ffe13f2cddaeba5a6842db63930e7a0\nparent b4475ea80c1d1ff051cc8de1856d4a6ba6d87def\nauthor josibake <josibake@protonmail.com> 1713202589 +0200\ncommitter josibake <josibake@protonmail.com> 1720955832 +0200\n\nsilentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmaTs7wACgkQity1WMTz\nPWU4tA//ZFLn/BW4FDaeG/SZRmt1G5ZfIYY6I4F9VSp5pxnS/kjvgn7ub85s34vk\n0TRHqdiTQ4H68qrcOMA/qnqKX+P8lbdQZm7do9MUpiGIDdm6C8K9V8HaL4dqFSls\nd2xbPggTxXCzbos8yGN4QgsVzgPd/qjXIl6VTUX+a+evkznwVZxj4gUcNf3i8iVf\n7ESFmEh3XWgIkUJd3MWRD5c+CL82plGmqgjnBJOJ8yrTyf8BGB5w4E3UgDw93kTN\nSuIKqPH5PID/eTNcNKeiiID1uA7EIchACcXt0JziGWYo5wnfgHPRTBjYwtetXuci\n5cvzM+Ij1KhXoiQ0eK8uIjfjZG3nU31dahinjF5qZLC67ifIFQt2moEr7cKWv+wv\nHeI+f4b1fGQYRBKdlP89ApcMSaanrLMNir/R3yVcXGdMTOK9/iSzRd+Os4yb+Wz6\noTeKTbd6n/4r0l+kIQ5KzEv6c+afoUFe8IB0i4WWFz0RmVEMt6MyvbRtCXMyUR/Q\nQhtve5W2P062BdNdKGASftXWQ+kAor+mgmOG5GZJadkXcodZU+JhrHZF46Ls19j3\n9c1xaKp8YNzGHEhgHKflUyniQiuLQGnp8RJcQpZIQEeutRuUWkaADucpejONsytj\nLH1Sq0OQqYjX5sI+JFMF4QUDB9lkRH7+wC5KJQvwovsmLHLIu9A=\n=WU68\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b4475ea80c1d1ff051cc8de1856d4a6ba6d87def",
          "sha": "b4475ea80c1d1ff051cc8de1856d4a6ba6d87def",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b4475ea80c1d1ff051cc8de1856d4a6ba6d87def"
        }
      ],
      "message": "silentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-14T11:17:12Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-15T17:36:29Z"
      },
      "sha": "91b1b3365bd5ddbbd8439000f18893c0f0e6a9b5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGMzMGJjMDEzZmVhNjA2N2U4ODY5MjYzYjgxZTk4NzI1OTg5NTIzZjg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c30bc013fea6067e8869263b81e98725989523f8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c30bc013fea6067e8869263b81e98725989523f8",
      "tree": {
        "sha": "f460f83af2fe67e404a801cc7383b673efe4fa55",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/f460f83af2fe67e404a801cc7383b673efe4fa55"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree f460f83af2fe67e404a801cc7383b673efe4fa55\nparent 91b1b3365bd5ddbbd8439000f18893c0f0e6a9b5\nauthor josibake <josibake@protonmail.com> 1714066415 +0200\ncommitter josibake <josibake@protonmail.com> 1720955836 +0200\n\nsilentpayments: add benchmark for `scan_outputs`\n\nAdd a benchmark for `scan_outputs` as this is the most performance\ncritical part of silent payments.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmaTs7wACgkQity1WMTz\nPWUnfxAAxuUMHKo047/YnVYHFpIlSXwvCml2vd3A+DcPMu6nkxUXFKI33O96mw0T\nwSeYJzzbizxNu2FBugJj62EiFicE6DzQQkvuD8yubPg3f9cMdL2CLv1XmnL0cYMJ\nQJbZWbbCiqJjbmwGlzeDNCihF7gI0jOiVuEAuq/Ovt5VKOhkelGjgnt5VKvIol8h\n3iy6G2lNPtlhHBk/BD/wVtSm/TlQsLbJHWReg48jXf2GFlwJ25b33IIQWtTajCcl\nZYM1VMDMWgF1oxihT7dNh/XJCcUMVGMeJO3gMI5yH22iqlFVygpoWJSgOZf+bI+8\ndLaqXNm+Uy2J4feiuvMigFpsNzDEvbWCLWMsuq2f3nPxGOE0t+I9xuhxZnXEFkJD\nKZ4rRnRGzdy3BapAePsTmiOovv7GZ9pnoTYnDBJ1I398vcHVpJqP68mOTlt9Yjec\nmgExkfXdJ3yaReXM7a/QaBubxezViuNil0mCakpxDiaWuxtSKUnU1/uDrsgpJBZa\nm/QNDxUex0GC2AExYK+ki3ClxZz9yU/KwmgpvqarOJtVpIKNWVQxZoVkb4OsdQKd\nPXa+aFuDC8KSpQNiut3UtSyzQozFd2xd9d98GLzDZIbwsccVVSlNTd5xqTySiGwN\nGmFoHDLix1jz5lgY3tYdflyTJp6EXM3cTxAA/YYyXYYCcqsj2ZE=\n=K46w\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/91b1b3365bd5ddbbd8439000f18893c0f0e6a9b5",
          "sha": "91b1b3365bd5ddbbd8439000f18893c0f0e6a9b5",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/91b1b3365bd5ddbbd8439000f18893c0f0e6a9b5"
        }
      ],
      "message": "silentpayments: add benchmark for `scan_outputs`\n\nAdd a benchmark for `scan_outputs` as this is the most performance\ncritical part of silent payments.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-14T11:17:16Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-25T17:33:35Z"
      },
      "sha": "c30bc013fea6067e8869263b81e98725989523f8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDk2YmQ3MWZiOGE5Y2IyOTUwYmI2ZjMwMzM4MDViYTk4OTFjZTA0ODE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/96bd71fb8a9cb2950bb6f3033805ba9891ce0481",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/96bd71fb8a9cb2950bb6f3033805ba9891ce0481",
      "tree": {
        "sha": "4a69b9150abfc8a709b4c0052c6c9d6d3c5e9748",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/4a69b9150abfc8a709b4c0052c6c9d6d3c5e9748"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4a69b9150abfc8a709b4c0052c6c9d6d3c5e9748\nparent c30bc013fea6067e8869263b81e98725989523f8\nauthor josibake <josibake@protonmail.com> 1719942343 +0200\ncommitter josibake <josibake@protonmail.com> 1720955837 +0200\n\ntests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmaTs70ACgkQity1WMTz\nPWVXog//XbimhXrKiV98fYIVAI//hp88Kz/9mkdXwx9nUjIZWpQe7epx/sjybhif\nzfMVw3qECmaJ+ys6krIOElzadfm3LtqK3EIlHJa6uxqYpFQG+eCEygQBlyS+mMwr\ns6QfByst9C9X57l2i5q6wJDSHa3/WIpPFS8SRSdfoBV+eUQWPxbAKxPazf8pPPJY\nHTsKPS0g41HC23cuP1CkuBOaCOytqT1Jsb5F+Im6HzQdKtsVc1VLxvrnm/MSXMIU\nWzYq4WifrwQTiZb/DHShngfk2V2B7LfcOYso7igd3HcasI0aPsClGXVmADUtXH39\nGudETMRh9ZY6id3zWSAP0fYbrvlDWT9WgjUyEtYGfxmNedyMZ04GxEoGeTx1tmsv\nFctAs+Qo8eKCEqq2iqqYVewU3N+Y2scPpcv3/JHLmbSVDF2CkRZSvfmF7XN6AbiQ\nBSrwQ7uCLauMr7ZpqkU3mLp0+io2ZawrJKTbbWCZvCoF1EbAkPULw+yYJgtdbl6b\naq8kEBO0u+9RUQ3Jd/tQmJOoAb8xH21/YXgGioHkfmnJNkOj4a9KDWN7NrUY8d1z\n4WeK+drVyw21iCAy1+vx+Z2kpZv8SDavrNTTYHJswMqGfJK8PhrcZQbyGg7ed70M\nFRO3zGgxG+4Dsa2idLW+3mW/sIjflbGNxgv9ySsW6K2AZLyIPNo=\n=8UZ5\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c30bc013fea6067e8869263b81e98725989523f8",
          "sha": "c30bc013fea6067e8869263b81e98725989523f8",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c30bc013fea6067e8869263b81e98725989523f8"
        }
      ],
      "message": "tests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-14T11:17:17Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-02T17:45:43Z"
      },
      "sha": "96bd71fb8a9cb2950bb6f3033805ba9891ce0481"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDU0YjhiYzhlYzZjMThmMWNiNDExNmY2NzFjMTM1Njk2NzgxYjlkMjA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/54b8bc8ec6c18f1cb4116f671c135696781b9d20",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/54b8bc8ec6c18f1cb4116f671c135696781b9d20",
      "tree": {
        "sha": "470b854819370e0dd856db98e8b362ad01849213",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/470b854819370e0dd856db98e8b362ad01849213"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 470b854819370e0dd856db98e8b362ad01849213\nparent 96bd71fb8a9cb2950bb6f3033805ba9891ce0481\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1708644341 +0100\ncommitter josibake <josibake@protonmail.com> 1720955837 +0200\n\nci: enable silentpayments module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmaTs70ACgkQity1WMTz\nPWXjMBAAsqPCskMhUaGkwWKGK3LbPzVDMrIZfWEN3/khvZ57onQsNq/H7ZgJvZpr\nTSeq5dH8KF7EaZCLx2/Ah0rzww4H6nSC5Flrt0Jh5QjcdnnP5yVDejkoEFONffKB\npxsT8SGgqMmAByVijMYTjs34QWDRSt4kmYT942s6XAfDbK5aTJOfsDmcFGaTvNRK\nvI91qa96JJvun1ngolkew9BxqDrknGlIRU+7aFF4JDWyF2GFugcK5iwsQPgH6J8U\nnUq393HYAuvK3W6nTqFCS7kYi0vXpY7aySgJq9NKV4BeEzZs7szwTxAvybYeDk4Y\n5fT5WNOGnvRsi5xA3lsX/EWgPv3FfJ9mxWpqX62SxMY8sPuq5zrTneM5ts5ATidp\nnKzMfcv8ddKtkIVU4NyCBX48km8gb2z0dhA4i8fJMV0kHyMUusJMglQ2MZxkqEd2\nSU0GODUTydhHZsAxlkrX2xzxxLJS7aXv7hwWth/HaFNxrqFE8MoUWQ2Cfvh3Efu6\noTwasE/8ffNVR9QmDo5jaCS2+1dJ5pLUmsroEM6mhHF4mySEaphwPZjcIpACFSFD\nNoGEYkoJX7/MYLFCzG4naG8cjd6JV50S3baVR7haTL09vWVVBjsy7eCnNbu++8xb\nbDjxAxOjDtTyJYp1pdu3+xf3vGQFaUPoKxeee+n5hl1tb7zeME0=\n=70Lu\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/96bd71fb8a9cb2950bb6f3033805ba9891ce0481",
          "sha": "96bd71fb8a9cb2950bb6f3033805ba9891ce0481",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/96bd71fb8a9cb2950bb6f3033805ba9891ce0481"
        }
      ],
      "message": "ci: enable silentpayments module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-14T11:17:17Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-02-22T23:25:41Z"
      },
      "sha": "54b8bc8ec6c18f1cb4116f671c135696781b9d20"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDAwYjBjYjE5YTk3NzE4ZGZhYWI3MGFhNzUwNWZmMTU3ZjIyYTMxYmQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "tree": {
        "sha": "3f885da658853ba95504dc2fc8e5f242ab38817d",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/3f885da658853ba95504dc2fc8e5f242ab38817d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 3f885da658853ba95504dc2fc8e5f242ab38817d\nparent 54b8bc8ec6c18f1cb4116f671c135696781b9d20\nauthor josibake <josibake@protonmail.com> 1720789074 +0200\ncommitter josibake <josibake@protonmail.com> 1720955837 +0200\n\ndocs: update README\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmaTs70ACgkQity1WMTz\nPWUZQRAA1S3JzCn7zFK1PZj76L/0WtcyInczLZieMdgr2PPj75e8d451VXMmgv6W\nUYPqiqBOasALbxjNYZ0wer/i+OAXUuNJ7pAgu4kgq3ReQ6ObtXHQn7qhDfKN+LV7\nzvW1VRn6ew2a12cu9HXKaAm0nKxd156A/hRkgp5jiRU796OJBi+I38V8slvBdKBb\nQ/XIod3Pt2XTTg0I3NC7VHOB5amLUhHxZcXe6aNM85PA96CB339Ia3PR9jq3pAYd\nvCJ7SQx0vU5hO2fznEHclpKLM6bs+DrUtI9NqVge9XbhGNsSRV9tDpeuP/rPlH9Q\nifoimu4ysqWOBS5JHAt0WEc9EK8KWDu4BlKKiJf4DYrJ+056agh0f53798EDfQeP\nm8rsA16a14OLGau1d9qzbc9QI4/nrCYsM5tOyMpukMGWZgaqDCNI3v4iUK/Wnm4/\nL7HfA5M2zi26/lNGME4FubfaonHyktYDaCYRFeenQLxfAqUAzmnCnIhVsCo4SXuV\nIT2OrN0ebs37NPi4Z8F0RR96Oaiz9ufq29dmtSLzLut14v/SuXhMsk1JxmDKPH5l\nqBUEbTiJcjqynw6vVXG12ts0HlZKERK1bLR53hhhbiXH/fe+SAT1VW9S9bukBP9T\nQfnYZNhPkKeLgt06yih9i/3iuVMugCTRIPf0HrhT6yiYltzuuUQ=\n=w+lW\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/54b8bc8ec6c18f1cb4116f671c135696781b9d20",
          "sha": "54b8bc8ec6c18f1cb4116f671c135696781b9d20",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/54b8bc8ec6c18f1cb4116f671c135696781b9d20"
        }
      ],
      "message": "docs: update README",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-14T11:17:17Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-12T12:57:54Z"
      },
      "sha": "00b0cb19a97718dfaab70aa7505ff157f22a31bd"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13497713166,
      "node_id": "HRFPE_lADOAP4Jqs6GTERUzwAAAAMkhsIO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13497713166",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:24:03Z"
    },
    {
      "event": "commented",
      "id": 2227312600,
      "node_id": "IC_kwDOAP4Jqs6EwhfY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/2227312600",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:33:29Z",
      "updated_at": "2024-07-14T11:33:29Z",
      "author_association": "MEMBER",
      "body": "Updated https://github.com/bitcoin-core/secp256k1/commit/602e11d910083582b139f2c45045c27e26805b92 -> https://github.com/bitcoin-core/secp256k1/commit/00b0cb19a97718dfaab70aa7505ff157f22a31bd ([bip352-silentpayments-module-12](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-12) -> [bip352-silentpayments-module-13](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-13), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-12..josibake:secp256k1:bip352-silentpayments-module-13))\r\n\r\n* Formatting fix ups for `examples/silentpayments.c` (introduced in the previous commit :doh:)\r\n* Use `eckey_pubkey_serialize` (h/t @theStack)\r\n* Spelling fixups in `include/secp256k1_silentpayments.h` (h/t @theStack)\r\n* Allow trailing comma in test vectors (h/t @real-or-random)\r\n* Fix up `memset` when clear unsigned char arrays\r\n* Fix CI by replacing `memcmp` with `secp256k1_memcmp_var`\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2227312600",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1519"
    },
    {
      "event": "mentioned",
      "id": 13497730767,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMkhwbP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13497730767",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:33:30Z"
    },
    {
      "event": "subscribed",
      "id": 13497730770,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMkhwbS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13497730770",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:33:30Z"
    },
    {
      "event": "mentioned",
      "id": 13497730773,
      "node_id": "MEE_lADOAP4Jqs6GTERUzwAAAAMkhwbV",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13497730773",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:33:30Z"
    },
    {
      "event": "subscribed",
      "id": 13497730774,
      "node_id": "SE_lADOAP4Jqs6GTERUzwAAAAMkhwbW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13497730774",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T11:33:30Z"
    },
    {
      "event": "reviewed",
      "id": 2179013693,
      "node_id": "PRR_kwDOAP4Jqs6B4Rw9",
      "url": null,
      "actor": null,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "nit: a suggestion to make the example file cover all functions.",
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2179013693",
      "submitted_at": "2024-07-16T01:26:02Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    },
    {
      "event": "referenced",
      "id": 13606918389,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMrCRj1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13606918389",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "1d49769ad4c2a7f52294f84b40524361314f8425",
      "commit_url": "https://api.github.com/repos/BitBoxSwiss/secp256k1-zkp/commits/1d49769ad4c2a7f52294f84b40524361314f8425",
      "created_at": "2024-07-22T21:12:01Z"
    },
    {
      "event": "referenced",
      "id": 13607207369,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMrDYHJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13607207369",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "ad4bd73d4f404b68ce15f308d3935cfe3d440143",
      "commit_url": "https://api.github.com/repos/BitBoxSwiss/secp256k1-zkp/commits/ad4bd73d4f404b68ce15f308d3935cfe3d440143",
      "created_at": "2024-07-22T21:48:33Z"
    },
    {
      "event": "referenced",
      "id": 13613805074,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMrci4S",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13613805074",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "e8810288935ac12cc2ce7858f058258fe48520c4",
      "commit_url": "https://api.github.com/repos/BitBoxSwiss/secp256k1-zkp/commits/e8810288935ac12cc2ce7858f058258fe48520c4",
      "created_at": "2024-07-23T10:45:25Z"
    },
    {
      "event": "referenced",
      "id": 13613853868,
      "node_id": "REFE_lADOAP4Jqs6GTERUzwAAAAMrcuys",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/13613853868",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a361bdc22dec88840375039cdad35bc21395f5cd",
      "commit_url": "https://api.github.com/repos/BitBoxSwiss/secp256k1-zkp/commits/a361bdc22dec88840375039cdad35bc21395f5cd",
      "created_at": "2024-07-23T10:49:17Z"
    },
    {
      "event": "reviewed",
      "id": 2210420185,
      "node_id": "PRR_kwDOAP4Jqs6DwFXZ",
      "url": null,
      "actor": null,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#pullrequestreview-2210420185",
      "submitted_at": "2024-07-31T15:28:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574947042",
      "pull_request_review_id": 2015096769,
      "id": 1574947042,
      "node_id": "PRRC_kwDOAP4Jqs5d38ji",
      "diff_hunk": "@@ -433,4 +433,137 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    combined = (int)public_data->data[0];\n+    {\n+        unsigned char input_hash[32];\n+        unsigned char *input_hash_ptr;\n+        if (combined) {\n+            input_hash_ptr = NULL;\n+        } else {\n+            memset(input_hash, 0, 32);\n+            input_hash_ptr = input_hash;\n+        }\n+        if (!secp256k1_silentpayments_recipient_public_data_load(ctx, &A_sum, input_hash_ptr, public_data)) {\n+            return 0;\n+        }\n+        secp256k1_pubkey_load(ctx, &receiver_spend_pubkey_ge, receiver_spend_pubkey);\n+        if (!secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, scan_key, &A_sum, input_hash_ptr)) {\n+            return 0;\n+        }\n+    }\n+\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = receiver_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+            return 0;\n+        }\n+\n+        /* If the calculated output matches the one from the tx, we have a direct match and can\n+         * return without labels calculation (one of the two would result in point of infinity) */\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        found = 0;\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                found_outputs[n_found]->output = *tx_outputs[i];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 65,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The `found_with_label` boolean needs to be set here, to not leave it uninitialized (I guess we don't want to rely on the user zeroing the `_found_output` struct instances before scanning):\r\n```suggestion\r\n                found_outputs[n_found]->output = *tx_outputs[i];\r\n                found_outputs[n_found]->found_with_label = 0;\r\n```\r\nShould we also set `label` here to something invalid for consistency, e.g. all-zero-bytes, even though the user wouldn't evaluate it anyways? Not sure what the best practices are in cases like this and if returning uninitialized data is acceptable.\r\n\r\nMight be nice to update the tests to also check for the `found_with_label` flag. ",
      "created_at": "2024-04-22T15:21:20Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1574947042",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574947042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 497,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574962225",
      "pull_request_review_id": 2015096769,
      "id": 1574962225,
      "node_id": "PRRC_kwDOAP4Jqs5d4AQx",
      "diff_hunk": "@@ -222,6 +222,57 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *           public_tweak_data: pointer to the input public key sum (optionaly, with the `input_hash`",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 22,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *                 public_data: pointer to the input public key sum (optionaly, with the `input_hash`\r\n```",
      "created_at": "2024-04-22T15:30:04Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1574962225",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574962225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574963125",
      "pull_request_review_id": 2015096769,
      "id": 1574963125,
      "node_id": "PRRC_kwDOAP4Jqs5d4Ae1",
      "diff_hunk": "@@ -222,6 +222,57 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *           public_tweak_data: pointer to the input public key sum (optionaly, with the `input_hash`\n+ *                              multiplied in, see `_recipient_compute_public_data`).\n+ *      recipient_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                  input_hash: pointer to the input_hash. MUST be NULL if the input_hash is already\n+ *                              multipled into the input public key sum (see `_recipient_compute_public_data`)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 26,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n```\r\n(parameter doesn't exist anymore)",
      "created_at": "2024-04-22T15:30:22Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1574963125",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574963125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 246,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574976504",
      "pull_request_review_id": 2015096769,
      "id": 1574976504,
      "node_id": "PRRC_kwDOAP4Jqs5d4Dv4",
      "diff_hunk": "@@ -328,4 +328,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 34,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "4fb8716f4f1f6b10757f53024eb22263829fe888",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure why I chose the constant-time point addition routines back then in #1471 (probably was inspired by `_ec_pubkey_combine`), but I strongly suspect that they are not needed for summing up public data:\r\n```suggestion\r\n        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\r\n```\r\n(also for second summing loop a few lines below)",
      "created_at": "2024-04-22T15:39:48Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1574976504",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574976504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574990516",
      "pull_request_review_id": 2015096769,
      "id": 1574990516,
      "node_id": "PRRC_kwDOAP4Jqs5d4HK0",
      "diff_hunk": "@@ -0,0 +1,264 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../../src/modules/silentpayments/vectors.h\"\n+#include \"../../../examples/examples_util.h\"\n+#include \"assert.h\"\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[10];\n+};\n+struct labels_cache labels_cache;\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j;\n+    int match;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        int ret = secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]);\n+        assert(ret);\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    ));\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[i]));\n+        match = 0;\n+        /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+        for (j = 0; j < test->num_recipient_outputs; j++) {\n+            if (secp256k1_memcmp_var(created_output, test->recipient_outputs[j], 32) == 0) {\n+                match = 1;\n+                break;\n+            }\n+        }\n+        CHECK(match);\n+    }\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey receiver_scan_pubkey;\n+    secp256k1_pubkey receiver_spend_pubkey;\n+    size_t i,j;\n+    int match;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));\n+            plain_pubkeys[i] = &plain_pubkeys_objs[i];\n+        }\n+        for (i = 0; i < test->num_taproot_inputs; i++) {\n+            CHECK(secp256k1_xonly_pubkey_parse(CTX, &xonly_pubkeys_objs[i], test->xonly_pubkeys[i]));\n+            xonly_pubkeys[i] = &xonly_pubkeys_objs[i];\n+        }\n+        CHECK(secp256k1_silentpayments_recipient_public_data_create(CTX, &public_data,\n+            test->outpoint_smallest,\n+            test->num_taproot_inputs > 0 ? xonly_pubkeys : NULL, test->num_taproot_inputs,\n+            test->num_plain_inputs > 0 ? plain_pubkeys : NULL, test->num_plain_inputs\n+        ));\n+    }\n+    /* prepare the outputs */\n+    {\n+        for (i = 0; i < test->num_to_scan_outputs; i++) {\n+            CHECK(secp256k1_xonly_pubkey_parse(CTX, &tx_output_objs[i], test->to_scan_outputs[i]));\n+            tx_outputs[i] = &tx_output_objs[i];\n+        }\n+        for (i = 0; i < test->num_found_output_pubkeys; i++) {\n+            found_outputs[i] = &found_output_objs[i];\n+        }\n+    }\n+\n+    /* scan / spend pubkeys are not in the given data of the receiver part, so let's compute them */\n+    CHECK(secp256k1_ec_pubkey_create(CTX, &receiver_scan_pubkey, test->scan_seckey));\n+    CHECK(secp256k1_ec_pubkey_create(CTX, &receiver_spend_pubkey, test->spend_seckey));\n+\n+    /* create labels cache */\n+    labels_cache.ctx = CTX;\n+    labels_cache.entries_used = 0;\n+    for (i = 0; i < test->num_labels; i++) {\n+        unsigned int m = test->label_integers[i];\n+        struct label_cache_entry *cache_entry = &labels_cache.entries[labels_cache.entries_used];\n+        CHECK(secp256k1_silentpayments_recipient_create_label_tweak(CTX, &cache_entry->label, cache_entry->label_tweak, test->scan_seckey, m));\n+        labels_cache.entries_used++;\n+    }\n+    CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX,\n+        found_outputs, &n_found,\n+        tx_outputs, test->num_to_scan_outputs,\n+        test->scan_seckey,\n+        &public_data,\n+        &receiver_spend_pubkey,\n+        label_lookup, &labels_cache)\n+    );\n+    for (i = 0; i < n_found; i++) {\n+        unsigned char full_seckey[32];\n+        secp256k1_keypair keypair;\n+        unsigned char signature[64];\n+        const unsigned char msg32[32] = /* sha256(\"message\") */\n+            {0xab,0x53,0x0a,0x13,0xe4,0x59,0x14,0x98,0x2b,0x79,0xf9,0xb7,0xe3,0xfb,0xa9,0x94,\n+             0xcf,0xd1,0xf3,0xfb,0x22,0xf7,0x1c,0xea,0x1a,0xfb,0xf0,0x2b,0x46,0x0c,0x6d,0x1d};\n+        const unsigned char aux32[32] = /* sha256(\"random auxiliary data\") */\n+            {0x0b,0x3f,0xdd,0xfd,0x67,0xbf,0x76,0xae,0x76,0x39,0xee,0x73,0x5b,0x70,0xff,0x15,\n+             0x83,0xfd,0x92,0x48,0xc0,0x57,0xd2,0x86,0x07,0xa2,0x15,0xf4,0x0b,0x0a,0x3e,0xcc};\n+        memcpy(&full_seckey, test->spend_seckey, 32);\n+        CHECK(secp256k1_ec_seckey_tweak_add(CTX, full_seckey, found_outputs[i]->tweak));\n+        CHECK(secp256k1_keypair_create(CTX, &keypair, full_seckey));\n+        CHECK(secp256k1_schnorrsig_sign32(CTX, signature, msg32, &keypair, aux32));\n+        memcpy(found_signatures[i], signature, 64);\n+    }\n+\n+    /* compare expected and scanned outputs (including calculated seckey tweaks and signatures) */\n+    for (i = 0; i < n_found; i++) {\n+        CHECK(secp256k1_xonly_pubkey_serialize(CTX, found_output, &found_outputs[i]->output));\n+        match = 0;\n+        for (j = 0; j < test->num_found_output_pubkeys; j++) {\n+            if (secp256k1_memcmp_var(&found_output, test->found_output_pubkeys[j], 32) == 0) {\n+                match = 1;\n+                CHECK(secp256k1_memcmp_var(found_outputs[i]->tweak, test->found_seckey_tweaks[j], 32) == 0);\n+                CHECK(secp256k1_memcmp_var(found_signatures[i], test->found_signatures[j], 64) == 0);\n+                break;\n+            }\n+        }\n+        CHECK(match);\n+    }\n+    CHECK(n_found == test->num_found_output_pubkeys);\n+    /* Scan as a light client\n+     * it is not recommended to use labels as a light client so here we are only\n+     * running this on tests that do not involve labels. Primarily, this test is to\n+     * ensure that _recipient_created_shared_secret and _create_shared_secret are the same\n+     */\n+    if (test->num_labels == 0) {\n+        CHECK(secp256k1_silentpayments_recipient_public_data_serialize(CTX, light_client_data, &public_data));\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(CTX, &public_data_index, light_client_data));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(CTX, shared_secret_lightclient, test->scan_seckey, &public_data_index));\n+        n_found = 0;\n+        {\n+            int found = 0;\n+            size_t k = 0;\n+            secp256k1_xonly_pubkey potential_output;\n+            unsigned char xonly_print[32];\n+\n+            while(1) {\n+\n+                CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(CTX,\n+                    &potential_output,\n+                    shared_secret_lightclient,\n+                    &receiver_spend_pubkey,\n+                    k\n+                ));\n+                /* At this point, we check that the utxo exists with a light client protocol.\n+                 * For this example, we'll just iterate through the list of pubkeys */\n+                found = 0;\n+                secp256k1_xonly_pubkey_serialize(CTX, xonly_print, &potential_output);\n+                printf(\"what we generated :\");\n+                print_hex(xonly_print, 32);",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 216,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "85946762a59c39dfe21ac899359bcac443ab8d20",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Tests are usually silent, so this should be removed (or maybe put in some verbose/debug #if block, though I'm not sure if this is considered a good idea due to increased maintenance burden):\r\n```suggestion\r\n```",
      "created_at": "2024-04-22T15:49:34Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1574990516",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1574990516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 215,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575010116",
      "pull_request_review_id": 2015096769,
      "id": 1575010116,
      "node_id": "PRRC_kwDOAP4Jqs5d4L9E",
      "diff_hunk": "@@ -433,4 +433,137 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    combined = (int)public_data->data[0];\n+    {\n+        unsigned char input_hash[32];\n+        unsigned char *input_hash_ptr;\n+        if (combined) {\n+            input_hash_ptr = NULL;\n+        } else {\n+            memset(input_hash, 0, 32);\n+            input_hash_ptr = input_hash;\n+        }\n+        if (!secp256k1_silentpayments_recipient_public_data_load(ctx, &A_sum, input_hash_ptr, public_data)) {\n+            return 0;\n+        }\n+        secp256k1_pubkey_load(ctx, &receiver_spend_pubkey_ge, receiver_spend_pubkey);\n+        if (!secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, scan_key, &A_sum, input_hash_ptr)) {\n+            return 0;\n+        }\n+    }\n+\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = receiver_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+            return 0;\n+        }\n+\n+        /* If the calculated output matches the one from the tx, we have a direct match and can\n+         * return without labels calculation (one of the two would result in point of infinity) */\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        found = 0;\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                found_outputs[n_found]->output = *tx_outputs[i];\n+                secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+                found = 1;\n+                n_found++;\n+                k++;\n+                break;\n+            }\n+\n+            /* If desired, also calculate label candidates */\n+            if (label_lookup != NULL) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 74,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The handling of the first and second scan label candidate look quite similar (both their calculation and the setting of the found output / advancing the counters if the label lookup in the cache was successful), seems like quite a bit of code could be duplicated here.",
      "created_at": "2024-04-22T16:01:32Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1575010116",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575010116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 505,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 491,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575023482",
      "pull_request_review_id": 2015096769,
      "id": 1575023482,
      "node_id": "PRRC_kwDOAP4Jqs5d4PN6",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *   Args:                 ctx: pointer to a context object\n+ *    Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys, one per recipient.\n+ *                              The order of outputs here matches the original ordering of the\n+ *                              recipients array.\n+ *     In:          recipients: pointer to an array of pointers to silent payment recipients,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 23,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Considering that the array is sorted in-place, is this in the category \"In/Out\"?",
      "created_at": "2024-04-22T16:10:37Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1575023482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575023482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575037779",
      "pull_request_review_id": 2015096769,
      "id": 1575037779,
      "node_id": "PRRC_kwDOAP4Jqs5d4StT",
      "diff_hunk": "@@ -173,4 +173,94 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(plain_seckeys == NULL || n_plain_seckeys >= 1);\n+    ARG_CHECK(taproot_seckeys == NULL || n_taproot_seckeys >= 1);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    ARG_CHECK((n_plain_seckeys + n_taproot_seckeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        int ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+        VERIFY_CHECK(!secp256k1_scalar_is_zero(&a_sum_scalar));\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        int ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+        /* declassify addend_point to allow using it as a branch point (this is fine because addend_point is not a secret) */\n+        secp256k1_declassify(ctx, &addend_point, sizeof(addend_point));\n+        secp256k1_fe_normalize_var(&addend_point.y);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 56,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Now that we get the point from a keypair instance, I think these lines are not needed anymore (see e.g. [a similar secret key negation code part in the schnorrsig module](https://github.com/bitcoin-core/secp256k1/blob/da515074e3ebc8abc85a4fff3a31d7694ecf897b/src/modules/schnorrsig/main_impl.h#L154-L160)):\r\n```suggestion\r\n```",
      "created_at": "2024-04-22T16:22:16Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1575037779",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575037779"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 226,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575039817",
      "pull_request_review_id": 2015096769,
      "id": 1575039817,
      "node_id": "PRRC_kwDOAP4Jqs5d4TNJ",
      "diff_hunk": "@@ -173,4 +173,94 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(plain_seckeys == NULL || n_plain_seckeys >= 1);\n+    ARG_CHECK(taproot_seckeys == NULL || n_taproot_seckeys >= 1);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    ARG_CHECK((n_plain_seckeys + n_taproot_seckeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        int ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+        VERIFY_CHECK(!secp256k1_scalar_is_zero(&a_sum_scalar));\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        int ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 52,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we return an error (i.e. `return 0`) here if the user passes in an invalid keypair?",
      "created_at": "2024-04-22T16:24:01Z",
      "updated_at": "2024-04-22T16:26:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1575039817",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1575039817"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 223,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577437389",
      "pull_request_review_id": 2019121206,
      "id": 1577437389,
      "node_id": "PRRC_kwDOAP4Jqs5eBcjN",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *   Args:                 ctx: pointer to a context object\n+ *    Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys, one per recipient.\n+ *                              The order of outputs here matches the original ordering of the\n+ *                              recipients array.\n+ *     In:          recipients: pointer to an array of pointers to silent payment recipients,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 23,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": 1575023482,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good question. I would argue no, since the caller is passing the array in and then never using it again. The fact that the array is sorted in place is irrelevant to the caller since they shouldn't be reading those values again, anyways. But maybe there is a more strict definition of In/Out, that if the function can modify the parameter it is an Out param?",
      "created_at": "2024-04-24T07:46:38Z",
      "updated_at": "2024-04-24T07:46:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577437389",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577437389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577545322",
      "pull_request_review_id": 2019306258,
      "id": 1577545322,
      "node_id": "PRRC_kwDOAP4Jqs5eB25q",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *   Args:                 ctx: pointer to a context object\n+ *    Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys, one per recipient.\n+ *                              The order of outputs here matches the original ordering of the\n+ *                              recipients array.\n+ *     In:          recipients: pointer to an array of pointers to silent payment recipients,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 23,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": 1575023482,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think there's a definition for this case and I don't remember a precedent. \"In\" seems fine to me if the modified argument is not supposed to be read again. The doc also mentions already that the array is modified (\"The recipient array will be sorted in place\").",
      "created_at": "2024-04-24T08:59:58Z",
      "updated_at": "2024-04-24T08:59:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577545322",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577545322"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577601080",
      "pull_request_review_id": 2019395443,
      "id": 1577601080,
      "node_id": "PRRC_kwDOAP4Jqs5eCEg4",
      "diff_hunk": "@@ -173,4 +173,94 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(plain_seckeys == NULL || n_plain_seckeys >= 1);\n+    ARG_CHECK(taproot_seckeys == NULL || n_taproot_seckeys >= 1);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    ARG_CHECK((n_plain_seckeys + n_taproot_seckeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        int ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+        VERIFY_CHECK(!secp256k1_scalar_is_zero(&a_sum_scalar));\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        int ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 52,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": 1575039817,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Replaced both instances of `VERIFY_CHECK` in this function with `return 0;`.",
      "created_at": "2024-04-24T09:40:05Z",
      "updated_at": "2024-04-24T09:40:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577601080",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577601080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 223,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577601481",
      "pull_request_review_id": 2019396053,
      "id": 1577601481,
      "node_id": "PRRC_kwDOAP4Jqs5eCEnJ",
      "diff_hunk": "@@ -173,4 +173,94 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(plain_seckeys == NULL || n_plain_seckeys >= 1);\n+    ARG_CHECK(taproot_seckeys == NULL || n_taproot_seckeys >= 1);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    ARG_CHECK((n_plain_seckeys + n_taproot_seckeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        int ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+        VERIFY_CHECK(!secp256k1_scalar_is_zero(&a_sum_scalar));\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        int ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        VERIFY_CHECK(ret);\n+        (void)ret;\n+        /* declassify addend_point to allow using it as a branch point (this is fine because addend_point is not a secret) */\n+        secp256k1_declassify(ctx, &addend_point, sizeof(addend_point));\n+        secp256k1_fe_normalize_var(&addend_point.y);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 56,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": 1575037779,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Removed.",
      "created_at": "2024-04-24T09:40:20Z",
      "updated_at": "2024-04-24T09:40:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577601481",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577601481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 226,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577607223",
      "pull_request_review_id": 2019405342,
      "id": 1577607223,
      "node_id": "PRRC_kwDOAP4Jqs5eCGA3",
      "diff_hunk": "@@ -433,4 +433,137 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    combined = (int)public_data->data[0];\n+    {\n+        unsigned char input_hash[32];\n+        unsigned char *input_hash_ptr;\n+        if (combined) {\n+            input_hash_ptr = NULL;\n+        } else {\n+            memset(input_hash, 0, 32);\n+            input_hash_ptr = input_hash;\n+        }\n+        if (!secp256k1_silentpayments_recipient_public_data_load(ctx, &A_sum, input_hash_ptr, public_data)) {\n+            return 0;\n+        }\n+        secp256k1_pubkey_load(ctx, &receiver_spend_pubkey_ge, receiver_spend_pubkey);\n+        if (!secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, scan_key, &A_sum, input_hash_ptr)) {\n+            return 0;\n+        }\n+    }\n+\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = receiver_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+            return 0;\n+        }\n+\n+        /* If the calculated output matches the one from the tx, we have a direct match and can\n+         * return without labels calculation (one of the two would result in point of infinity) */\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        found = 0;\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                found_outputs[n_found]->output = *tx_outputs[i];\n+                secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+                found = 1;\n+                n_found++;\n+                k++;\n+                break;\n+            }\n+\n+            /* If desired, also calculate label candidates */\n+            if (label_lookup != NULL) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 74,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": 1575010116,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree! I'm working on a commit now to improve this section and also minimize the conversions between `pubkey -> ge > gej`. Specifically, there was a [comment from Llyod](https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8?permalink_comment_id=4125475#gistcomment-4125475) on the original gist that mentions being able to test equality with `jacobian == affine`, which could save us conversions from `gej` to `ge`. I'm going to try and incorporate that feedback and remove some of the repeated code in a follow up commit.",
      "created_at": "2024-04-24T09:44:39Z",
      "updated_at": "2024-04-24T09:44:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577607223",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577607223"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 505,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 491,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577608530",
      "pull_request_review_id": 2019407393,
      "id": 1577608530,
      "node_id": "PRRC_kwDOAP4Jqs5eCGVS",
      "diff_hunk": "@@ -0,0 +1,264 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../../src/modules/silentpayments/vectors.h\"\n+#include \"../../../examples/examples_util.h\"\n+#include \"assert.h\"\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[10];\n+};\n+struct labels_cache labels_cache;\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j;\n+    int match;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        int ret = secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]);\n+        assert(ret);\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    ));\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[i]));\n+        match = 0;\n+        /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+        for (j = 0; j < test->num_recipient_outputs; j++) {\n+            if (secp256k1_memcmp_var(created_output, test->recipient_outputs[j], 32) == 0) {\n+                match = 1;\n+                break;\n+            }\n+        }\n+        CHECK(match);\n+    }\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey receiver_scan_pubkey;\n+    secp256k1_pubkey receiver_spend_pubkey;\n+    size_t i,j;\n+    int match;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));\n+            plain_pubkeys[i] = &plain_pubkeys_objs[i];\n+        }\n+        for (i = 0; i < test->num_taproot_inputs; i++) {\n+            CHECK(secp256k1_xonly_pubkey_parse(CTX, &xonly_pubkeys_objs[i], test->xonly_pubkeys[i]));\n+            xonly_pubkeys[i] = &xonly_pubkeys_objs[i];\n+        }\n+        CHECK(secp256k1_silentpayments_recipient_public_data_create(CTX, &public_data,\n+            test->outpoint_smallest,\n+            test->num_taproot_inputs > 0 ? xonly_pubkeys : NULL, test->num_taproot_inputs,\n+            test->num_plain_inputs > 0 ? plain_pubkeys : NULL, test->num_plain_inputs\n+        ));\n+    }\n+    /* prepare the outputs */\n+    {\n+        for (i = 0; i < test->num_to_scan_outputs; i++) {\n+            CHECK(secp256k1_xonly_pubkey_parse(CTX, &tx_output_objs[i], test->to_scan_outputs[i]));\n+            tx_outputs[i] = &tx_output_objs[i];\n+        }\n+        for (i = 0; i < test->num_found_output_pubkeys; i++) {\n+            found_outputs[i] = &found_output_objs[i];\n+        }\n+    }\n+\n+    /* scan / spend pubkeys are not in the given data of the receiver part, so let's compute them */\n+    CHECK(secp256k1_ec_pubkey_create(CTX, &receiver_scan_pubkey, test->scan_seckey));\n+    CHECK(secp256k1_ec_pubkey_create(CTX, &receiver_spend_pubkey, test->spend_seckey));\n+\n+    /* create labels cache */\n+    labels_cache.ctx = CTX;\n+    labels_cache.entries_used = 0;\n+    for (i = 0; i < test->num_labels; i++) {\n+        unsigned int m = test->label_integers[i];\n+        struct label_cache_entry *cache_entry = &labels_cache.entries[labels_cache.entries_used];\n+        CHECK(secp256k1_silentpayments_recipient_create_label_tweak(CTX, &cache_entry->label, cache_entry->label_tweak, test->scan_seckey, m));\n+        labels_cache.entries_used++;\n+    }\n+    CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX,\n+        found_outputs, &n_found,\n+        tx_outputs, test->num_to_scan_outputs,\n+        test->scan_seckey,\n+        &public_data,\n+        &receiver_spend_pubkey,\n+        label_lookup, &labels_cache)\n+    );\n+    for (i = 0; i < n_found; i++) {\n+        unsigned char full_seckey[32];\n+        secp256k1_keypair keypair;\n+        unsigned char signature[64];\n+        const unsigned char msg32[32] = /* sha256(\"message\") */\n+            {0xab,0x53,0x0a,0x13,0xe4,0x59,0x14,0x98,0x2b,0x79,0xf9,0xb7,0xe3,0xfb,0xa9,0x94,\n+             0xcf,0xd1,0xf3,0xfb,0x22,0xf7,0x1c,0xea,0x1a,0xfb,0xf0,0x2b,0x46,0x0c,0x6d,0x1d};\n+        const unsigned char aux32[32] = /* sha256(\"random auxiliary data\") */\n+            {0x0b,0x3f,0xdd,0xfd,0x67,0xbf,0x76,0xae,0x76,0x39,0xee,0x73,0x5b,0x70,0xff,0x15,\n+             0x83,0xfd,0x92,0x48,0xc0,0x57,0xd2,0x86,0x07,0xa2,0x15,0xf4,0x0b,0x0a,0x3e,0xcc};\n+        memcpy(&full_seckey, test->spend_seckey, 32);\n+        CHECK(secp256k1_ec_seckey_tweak_add(CTX, full_seckey, found_outputs[i]->tweak));\n+        CHECK(secp256k1_keypair_create(CTX, &keypair, full_seckey));\n+        CHECK(secp256k1_schnorrsig_sign32(CTX, signature, msg32, &keypair, aux32));\n+        memcpy(found_signatures[i], signature, 64);\n+    }\n+\n+    /* compare expected and scanned outputs (including calculated seckey tweaks and signatures) */\n+    for (i = 0; i < n_found; i++) {\n+        CHECK(secp256k1_xonly_pubkey_serialize(CTX, found_output, &found_outputs[i]->output));\n+        match = 0;\n+        for (j = 0; j < test->num_found_output_pubkeys; j++) {\n+            if (secp256k1_memcmp_var(&found_output, test->found_output_pubkeys[j], 32) == 0) {\n+                match = 1;\n+                CHECK(secp256k1_memcmp_var(found_outputs[i]->tweak, test->found_seckey_tweaks[j], 32) == 0);\n+                CHECK(secp256k1_memcmp_var(found_signatures[i], test->found_signatures[j], 64) == 0);\n+                break;\n+            }\n+        }\n+        CHECK(match);\n+    }\n+    CHECK(n_found == test->num_found_output_pubkeys);\n+    /* Scan as a light client\n+     * it is not recommended to use labels as a light client so here we are only\n+     * running this on tests that do not involve labels. Primarily, this test is to\n+     * ensure that _recipient_created_shared_secret and _create_shared_secret are the same\n+     */\n+    if (test->num_labels == 0) {\n+        CHECK(secp256k1_silentpayments_recipient_public_data_serialize(CTX, light_client_data, &public_data));\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(CTX, &public_data_index, light_client_data));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(CTX, shared_secret_lightclient, test->scan_seckey, &public_data_index));\n+        n_found = 0;\n+        {\n+            int found = 0;\n+            size_t k = 0;\n+            secp256k1_xonly_pubkey potential_output;\n+            unsigned char xonly_print[32];\n+\n+            while(1) {\n+\n+                CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(CTX,\n+                    &potential_output,\n+                    shared_secret_lightclient,\n+                    &receiver_spend_pubkey,\n+                    k\n+                ));\n+                /* At this point, we check that the utxo exists with a light client protocol.\n+                 * For this example, we'll just iterate through the list of pubkeys */\n+                found = 0;\n+                secp256k1_xonly_pubkey_serialize(CTX, xonly_print, &potential_output);\n+                printf(\"what we generated :\");\n+                print_hex(xonly_print, 32);",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 216,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "85946762a59c39dfe21ac899359bcac443ab8d20",
      "in_reply_to_id": 1574990516,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ":doh: those sneaked in from my debugging, good catch!",
      "created_at": "2024-04-24T09:45:40Z",
      "updated_at": "2024-04-24T09:45:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577608530",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577608530"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 215,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577608898",
      "pull_request_review_id": 2019407957,
      "id": 1577608898,
      "node_id": "PRRC_kwDOAP4Jqs5eCGbC",
      "diff_hunk": "@@ -328,4 +328,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 34,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "4fb8716f4f1f6b10757f53024eb22263829fe888",
      "in_reply_to_id": 1574976504,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-04-24T09:45:56Z",
      "updated_at": "2024-04-24T09:45:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577608898",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577608898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577609153",
      "pull_request_review_id": 2019408344,
      "id": 1577609153,
      "node_id": "PRRC_kwDOAP4Jqs5eCGfB",
      "diff_hunk": "@@ -222,6 +222,57 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *           public_tweak_data: pointer to the input public key sum (optionaly, with the `input_hash`",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 22,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": 1574962225,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-04-24T09:46:07Z",
      "updated_at": "2024-04-24T09:46:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577609153",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577609153"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577609295",
      "pull_request_review_id": 2019408535,
      "id": 1577609295,
      "node_id": "PRRC_kwDOAP4Jqs5eCGhP",
      "diff_hunk": "@@ -222,6 +222,57 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *           public_tweak_data: pointer to the input public key sum (optionaly, with the `input_hash`\n+ *                              multiplied in, see `_recipient_compute_public_data`).\n+ *      recipient_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                  input_hash: pointer to the input_hash. MUST be NULL if the input_hash is already\n+ *                              multipled into the input public key sum (see `_recipient_compute_public_data`)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 26,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": 1574963125,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-04-24T09:46:12Z",
      "updated_at": "2024-04-24T09:46:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577609295",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577609295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 246,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577610073",
      "pull_request_review_id": 2019409884,
      "id": 1577610073,
      "node_id": "PRRC_kwDOAP4Jqs5eCGtZ",
      "diff_hunk": "@@ -433,4 +433,137 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    combined = (int)public_data->data[0];\n+    {\n+        unsigned char input_hash[32];\n+        unsigned char *input_hash_ptr;\n+        if (combined) {\n+            input_hash_ptr = NULL;\n+        } else {\n+            memset(input_hash, 0, 32);\n+            input_hash_ptr = input_hash;\n+        }\n+        if (!secp256k1_silentpayments_recipient_public_data_load(ctx, &A_sum, input_hash_ptr, public_data)) {\n+            return 0;\n+        }\n+        secp256k1_pubkey_load(ctx, &receiver_spend_pubkey_ge, receiver_spend_pubkey);\n+        if (!secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, scan_key, &A_sum, input_hash_ptr)) {\n+            return 0;\n+        }\n+    }\n+\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = receiver_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+            return 0;\n+        }\n+\n+        /* If the calculated output matches the one from the tx, we have a direct match and can\n+         * return without labels calculation (one of the two would result in point of infinity) */\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        found = 0;\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                found_outputs[n_found]->output = *tx_outputs[i];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 65,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": 1574947042,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Updated and for now am just setting the label with the output when the output is found without a label, but would be better if we have a \"canonical\" invalid pubkey I can use.",
      "created_at": "2024-04-24T09:46:51Z",
      "updated_at": "2024-04-24T09:48:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577610073",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577610073"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 497,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577623058",
      "pull_request_review_id": 2019430407,
      "id": 1577623058,
      "node_id": "PRRC_kwDOAP4Jqs5eCJ4S",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *   Args:                 ctx: pointer to a context object\n+ *    Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys, one per recipient.\n+ *                              The order of outputs here matches the original ordering of the\n+ *                              recipients array.\n+ *     In:          recipients: pointer to an array of pointers to silent payment recipients,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 23,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "14ca7545780a1a60a5039a677546c066988654c0",
      "in_reply_to_id": 1575023482,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Going to leave it as \"In\" for now. I think it makes it more clear to the caller that they are supposed to read the `recipients` array after the function call.",
      "created_at": "2024-04-24T09:56:37Z",
      "updated_at": "2024-04-24T09:56:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1577623058",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1577623058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992204",
      "pull_request_review_id": 2026864465,
      "id": 1581992204,
      "node_id": "PRRC_kwDOAP4Jqs5eS0kM",
      "diff_hunk": "@@ -9,8 +9,36 @@\n #include \"../../../include/secp256k1.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(\n+        ((secp256k1_ec_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 18,
      "original_position": 11,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "97220f7b29b77677e66a527ec933b022ceb2cceb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`pk1`/`pk2` are addresses for _silentpayments_recipient instances, so involving double-pointers here doesn't seem to be necessary:\r\n```suggestion\r\n        &((const secp256k1_silentpayments_recipient *)pk1)->scan_pubkey,\r\n        &((const secp256k1_silentpayments_recipient *)pk2)->scan_pubkey\r\n```",
      "created_at": "2024-04-28T01:18:12Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581992204",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": 17,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": 18,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992289",
      "pull_request_review_id": 2026864465,
      "id": 1581992289,
      "node_id": "PRRC_kwDOAP4Jqs5eS0lh",
      "diff_hunk": "@@ -9,8 +9,36 @@\n #include \"../../../include/secp256k1.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(\n+        ((secp256k1_ec_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 16,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "97220f7b29b77677e66a527ec933b022ceb2cceb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: could be static, since it's not part of the public API",
      "created_at": "2024-04-28T01:18:51Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581992289",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992289"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992522",
      "pull_request_review_id": 2026864465,
      "id": 1581992522,
      "node_id": "PRRC_kwDOAP4Jqs5eS0pK",
      "diff_hunk": "@@ -173,4 +173,90 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 167,
      "original_position": 26,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could also ARG_CHECK for n_recipients here:\r\n```suggestion\r\n    ARG_CHECK(recipients != NULL);\r\n    ARG_CHECK(n_recipients >= 1);\r\n```",
      "created_at": "2024-04-28T01:21:29Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581992522",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992522"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 167,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992596",
      "pull_request_review_id": 2026864465,
      "id": 1581992596,
      "node_id": "PRRC_kwDOAP4Jqs5eS0qU",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 16,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "typo\r\n```suggestion\r\n * pairs, depending on whether the seckeys correspond to x-only outputs or not.\r\n```",
      "created_at": "2024-04-28T01:22:20Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581992596",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992596"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992633",
      "pull_request_review_id": 2026864465,
      "id": 1581992633,
      "node_id": "PRRC_kwDOAP4Jqs5eS0q5",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 18,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  Returns: 1 if creation of outputs was successful. 0 if an error occured.\r\n```",
      "created_at": "2024-04-28T01:23:07Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581992633",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581992633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993053",
      "pull_request_review_id": 2026864465,
      "id": 1581993053,
      "node_id": "PRRC_kwDOAP4Jqs5eS0xd",
      "diff_hunk": "@@ -93,6 +93,51 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan private key b_scan and a label integer m, calculate\n+ *  the corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *  label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           label_tweak: pointer to the resulting label tweak\n+ *   In:  receiver_scan_seckey: pointer to the receiver's scan private key\n+ *                           m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *receiver_scan_seckey,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate\n+ *  the corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address, consisting\n+ *  of the serialized and concatenated scan public key and (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out: l_addr_spend_pubkey33: pointer to the resulting labelled spend public key\n+ *   In: receiver_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                       label: pointer to the the receiver's label\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 44,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "aeef18499580e576f2078b20936842b899b05bd3",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: should use either `labeled` or `labelled` consistently (both seem to be correct english) for function name vs parameter",
      "created_at": "2024-04-28T01:27:04Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993053",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 134,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993106",
      "pull_request_review_id": 2026864465,
      "id": 1581993106,
      "node_id": "PRRC_kwDOAP4Jqs5eS0yS",
      "diff_hunk": "@@ -93,6 +93,51 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan private key b_scan and a label integer m, calculate\n+ *  the corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *  label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           label_tweak: pointer to the resulting label tweak\n+ *   In:  receiver_scan_seckey: pointer to the receiver's scan private key\n+ *                           m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *receiver_scan_seckey,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate\n+ *  the corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address, consisting\n+ *  of the serialized and concatenated scan public key and (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out: l_addr_spend_pubkey33: pointer to the resulting labelled spend public key",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 38,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "aeef18499580e576f2078b20936842b899b05bd3",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "the out-param description for `label` is missing",
      "created_at": "2024-04-28T01:27:36Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993106",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993106"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993315",
      "pull_request_review_id": 2026864465,
      "id": 1581993315,
      "node_id": "PRRC_kwDOAP4Jqs5eS01j",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).\n+ *\n+ *  Args:        ctx: pointer to a context object.\n+ *  Out: public_data: pointer to a silentpayments_public_data object. If 1 is returned, it is set to a\n+ *                    parsed version of input33.\n+ *  In:      input33: pointer to a serialized silentpayments_public_data.\n+ */\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:       ctx: pointer to a context object.\n+ *  Out:   output33: pointer to a 32-byte array to place the serialized key in.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 38,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  Out:   output33: pointer to a 33-byte array to place the serialized silentpayments_public_data in.\r\n```",
      "created_at": "2024-04-28T01:30:42Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993393",
      "pull_request_review_id": 2026864465,
      "id": 1581993393,
      "node_id": "PRRC_kwDOAP4Jqs5eS02x",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 19,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *           0 if the sequence is invalid (e.g. does not represent a valid public key).\r\n```",
      "created_at": "2024-04-28T01:31:17Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993393",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993506",
      "pull_request_review_id": 2026864465,
      "id": 1581993506,
      "node_id": "PRRC_kwDOAP4Jqs5eS04i",
      "diff_hunk": "@@ -324,4 +324,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 38,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can use non-constant-time ge adding for the second loop here as well:\r\n```suggestion\r\n        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\r\n```",
      "created_at": "2024-04-28T01:32:12Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993506",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993573",
      "pull_request_review_id": 2026864465,
      "id": 1581993573,
      "node_id": "PRRC_kwDOAP4Jqs5eS05l",
      "diff_hunk": "@@ -324,4 +324,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);\n+    }\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        /* TODO: do we need a special error return code for this case? */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_load(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 56,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: not used in public API, could be made static",
      "created_at": "2024-04-28T01:33:00Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993573",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 379,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993849",
      "pull_request_review_id": 2026864465,
      "id": 1581993849,
      "node_id": "PRRC_kwDOAP4Jqs5eS095",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).\n+ *\n+ *  Args:        ctx: pointer to a context object.\n+ *  Out: public_data: pointer to a silentpayments_public_data object. If 1 is returned, it is set to a\n+ *                    parsed version of input33.\n+ *  In:      input33: pointer to a serialized silentpayments_public_data.\n+ */\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:       ctx: pointer to a context object.\n+ *  Out:   output33: pointer to a 32-byte array to place the serialized key in.\n+ *  In: public_data: pointer to an initialized silentpayments_public_data object.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute Silent Payment public data from input public keys and transaction inputs.\n+ *\n+ * Given a list of n public keys A_1...A_n (one for each silent payment\n+ * eligible input to spend) and a serialized outpoint_smallest, compute\n+ * the corresponding input public tweak data:\n+ *\n+ * A_sum = A_1 + A_2 + ... + A_n\n+ * input_hash = hash(outpoint_lowest || A_sum)\n+ *\n+ * The public keys have to be passed in via two different parameter pairs,\n+ * one for regular and one for x-only public keys, in order to avoid the need\n+ * of users converting to a common pubkey format before calling this function.\n+ * The resulting data is can be used for scanning on the recipient side, or stored\n+ * in an index for late use (e.g. wallet rescanning, vending data to light clients).\n+ *\n+ * If calling this function for scanning, the reciever must provide an output param\n+ * for the `input_hash`. If calling this function for simply aggregating the inputs\n+ * for later use, the caller can save the result with `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           public_data: pointer to public_data object containing the summed public key and\n+ *                              input_hash.\n+ *  In:    outpoint_smallest36: serialized smallest outpoint\n+ *               xonly_pubkeys: pointer to an array of pointers to taproot x-only\n+ *                              public keys (can be NULL if no taproot inputs are used)\n+ *             n_xonly_pubkeys: the number of taproot input public keys\n+ *               plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                              public keys (can be NULL if no non-taproot inputs are used)\n+ *             n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(",
      "path": "include/secp256k1_silentpayments.h",
      "position": 215,
      "original_position": 78,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: could reorder that function to be above the other _public_data API functions, since that's the first one in the lifecycle of a `_public_data` instance.",
      "created_at": "2024-04-28T01:35:43Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993849",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 215,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993914",
      "pull_request_review_id": 2026864465,
      "id": 1581993914,
      "node_id": "PRRC_kwDOAP4Jqs5eS0-6",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 7,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  copied/moved. Created with `secp256k1_silentpayments_public_data_create`. Can be serialized as\r\n```",
      "created_at": "2024-04-28T01:36:52Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581993914",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581993914"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994092",
      "pull_request_review_id": 2026864465,
      "id": 1581994092,
      "node_id": "PRRC_kwDOAP4Jqs5eS1Bs",
      "diff_hunk": "@@ -222,6 +222,55 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *                 public_data: pointer to the input public key sum (optionaly, with the `input_hash`\n+ *                              multiplied in, see `_recipient_compute_public_data`).\n+ *      recipient_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                label_lookup: pointer to a callback function for looking up a label value. This fucntion\n+ *                              takes a label pubkey as an argument and returns a pointer to the label tweak\n+ *                              if the label exists, otherwise returns a nullptr (NULL if labels are not used)\n+ *               label_context: pointer to a label context object (NULL if labels are not used)\n+ */\n+\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const secp256k1_pubkey*, const void*);\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *scan_key,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 45,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "016c20d95f96a7cdbe2e36793c37fcb35532f5dd",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, to match the spend key naming:\r\n```suggestion\r\n    const unsigned char *recipient_scan_seckey,\r\n```",
      "created_at": "2024-04-28T01:39:30Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581994092",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994092"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 266,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994368",
      "pull_request_review_id": 2026864465,
      "id": 1581994368,
      "node_id": "PRRC_kwDOAP4Jqs5eS1GA",
      "diff_hunk": "@@ -429,4 +429,139 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 437,
      "original_position": 27,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "016c20d95f96a7cdbe2e36793c37fcb35532f5dd",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could add ARG_CHECKS for `n_found_outputs != NULL` and `n_tx_outputs >= 1` here",
      "created_at": "2024-04-28T01:40:57Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581994368",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994368"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 437,
      "original_line": 437,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994645",
      "pull_request_review_id": 2026864465,
      "id": 1581994645,
      "node_id": "PRRC_kwDOAP4Jqs5eS1KV",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: i think the else-brach can be removed (or at least, the `return 1;` in it); if keypair creation fails, we want to continue in the loop and try with another secret key",
      "created_at": "2024-04-28T01:44:35Z",
      "updated_at": "2024-04-28T01:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1581994645",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1581994645"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588884794",
      "pull_request_review_id": 2037624531,
      "id": 1588884794,
      "node_id": "PRRC_kwDOAP4Jqs5etHU6",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": 1581994645,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-03T08:10:38Z",
      "updated_at": "2024-05-03T08:10:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588884794",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588884794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588885068",
      "pull_request_review_id": 2037624941,
      "id": 1588885068,
      "node_id": "PRRC_kwDOAP4Jqs5etHZM",
      "diff_hunk": "@@ -429,4 +429,139 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 437,
      "original_position": 27,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "016c20d95f96a7cdbe2e36793c37fcb35532f5dd",
      "in_reply_to_id": 1581994368,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added.",
      "created_at": "2024-05-03T08:10:53Z",
      "updated_at": "2024-05-03T08:10:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588885068",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588885068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 437,
      "original_line": 437,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886367",
      "pull_request_review_id": 2037627106,
      "id": 1588886367,
      "node_id": "PRRC_kwDOAP4Jqs5etHtf",
      "diff_hunk": "@@ -222,6 +222,55 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     size_t n_plain_pubkeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *                 public_data: pointer to the input public key sum (optionaly, with the `input_hash`\n+ *                              multiplied in, see `_recipient_compute_public_data`).\n+ *      recipient_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                label_lookup: pointer to a callback function for looking up a label value. This fucntion\n+ *                              takes a label pubkey as an argument and returns a pointer to the label tweak\n+ *                              if the label exists, otherwise returns a nullptr (NULL if labels are not used)\n+ *               label_context: pointer to a label context object (NULL if labels are not used)\n+ */\n+\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const secp256k1_pubkey*, const void*);\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *scan_key,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 45,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "016c20d95f96a7cdbe2e36793c37fcb35532f5dd",
      "in_reply_to_id": 1581994092,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Changed `s/receiver/recipient/` consistently. Also removed references to `seckey` and \"private,\" considering the scan key is not a private key.",
      "created_at": "2024-05-03T08:12:00Z",
      "updated_at": "2024-05-03T08:12:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588886367",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886367"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 266,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886604",
      "pull_request_review_id": 2037627449,
      "id": 1588886604,
      "node_id": "PRRC_kwDOAP4Jqs5etHxM",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 7,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993914,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:12:13Z",
      "updated_at": "2024-05-03T08:12:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588886604",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886793",
      "pull_request_review_id": 2037627751,
      "id": 1588886793,
      "node_id": "PRRC_kwDOAP4Jqs5etH0J",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).\n+ *\n+ *  Args:        ctx: pointer to a context object.\n+ *  Out: public_data: pointer to a silentpayments_public_data object. If 1 is returned, it is set to a\n+ *                    parsed version of input33.\n+ *  In:      input33: pointer to a serialized silentpayments_public_data.\n+ */\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:       ctx: pointer to a context object.\n+ *  Out:   output33: pointer to a 32-byte array to place the serialized key in.\n+ *  In: public_data: pointer to an initialized silentpayments_public_data object.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Compute Silent Payment public data from input public keys and transaction inputs.\n+ *\n+ * Given a list of n public keys A_1...A_n (one for each silent payment\n+ * eligible input to spend) and a serialized outpoint_smallest, compute\n+ * the corresponding input public tweak data:\n+ *\n+ * A_sum = A_1 + A_2 + ... + A_n\n+ * input_hash = hash(outpoint_lowest || A_sum)\n+ *\n+ * The public keys have to be passed in via two different parameter pairs,\n+ * one for regular and one for x-only public keys, in order to avoid the need\n+ * of users converting to a common pubkey format before calling this function.\n+ * The resulting data is can be used for scanning on the recipient side, or stored\n+ * in an index for late use (e.g. wallet rescanning, vending data to light clients).\n+ *\n+ * If calling this function for scanning, the reciever must provide an output param\n+ * for the `input_hash`. If calling this function for simply aggregating the inputs\n+ * for later use, the caller can save the result with `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           public_data: pointer to public_data object containing the summed public key and\n+ *                              input_hash.\n+ *  In:    outpoint_smallest36: serialized smallest outpoint\n+ *               xonly_pubkeys: pointer to an array of pointers to taproot x-only\n+ *                              public keys (can be NULL if no taproot inputs are used)\n+ *             n_xonly_pubkeys: the number of taproot input public keys\n+ *               plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                              public keys (can be NULL if no non-taproot inputs are used)\n+ *             n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(",
      "path": "include/secp256k1_silentpayments.h",
      "position": 215,
      "original_position": 78,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993849,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-03T08:12:24Z",
      "updated_at": "2024-05-03T08:12:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588886793",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 215,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886959",
      "pull_request_review_id": 2037628025,
      "id": 1588886959,
      "node_id": "PRRC_kwDOAP4Jqs5etH2v",
      "diff_hunk": "@@ -324,4 +324,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);\n+    }\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        /* TODO: do we need a special error return code for this case? */\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_load(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 56,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993573,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-03T08:12:35Z",
      "updated_at": "2024-05-03T08:12:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588886959",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588886959"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 379,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588887146",
      "pull_request_review_id": 2037628330,
      "id": 1588887146,
      "node_id": "PRRC_kwDOAP4Jqs5etH5q",
      "diff_hunk": "@@ -324,4 +324,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge(&A_sum_gej, &A_sum_gej, &addend);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 38,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993506,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:12:48Z",
      "updated_at": "2024-05-03T08:12:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588887146",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588887146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588887330",
      "pull_request_review_id": 2037628563,
      "id": 1588887330,
      "node_id": "PRRC_kwDOAP4Jqs5etH8i",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 19,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993393,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:12:58Z",
      "updated_at": "2024-05-03T08:12:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588887330",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588887330"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588889660",
      "pull_request_review_id": 2037632371,
      "id": 1588889660,
      "node_id": "PRRC_kwDOAP4Jqs5etIg8",
      "diff_hunk": "@@ -93,6 +93,51 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan private key b_scan and a label integer m, calculate\n+ *  the corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *  label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           label_tweak: pointer to the resulting label tweak\n+ *   In:  receiver_scan_seckey: pointer to the receiver's scan private key\n+ *                           m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *receiver_scan_seckey,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate\n+ *  the corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address, consisting\n+ *  of the serialized and concatenated scan public key and (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out: l_addr_spend_pubkey33: pointer to the resulting labelled spend public key",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 38,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "aeef18499580e576f2078b20936842b899b05bd3",
      "in_reply_to_id": 1581993106,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added.",
      "created_at": "2024-05-03T08:15:27Z",
      "updated_at": "2024-05-03T08:15:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588889660",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588889660"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 130,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588889968",
      "pull_request_review_id": 2037632929,
      "id": 1588889968,
      "node_id": "PRRC_kwDOAP4Jqs5etIlw",
      "diff_hunk": "@@ -93,6 +93,51 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan private key b_scan and a label integer m, calculate\n+ *  the corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *  label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           label_tweak: pointer to the resulting label tweak\n+ *   In:  receiver_scan_seckey: pointer to the receiver's scan private key\n+ *                           m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label_tweak(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *receiver_scan_seckey,\n+    unsigned int m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labelled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate\n+ *  the corresponding serialized labelled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address, consisting\n+ *  of the serialized and concatenated scan public key and (labelled) spend public key each.\n+ *\n+ *  Returns: 1 if labelled spend public key creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out: l_addr_spend_pubkey33: pointer to the resulting labelled spend public key\n+ *   In: receiver_spend_pubkey: pointer to the receiver's spend pubkey\n+ *                       label: pointer to the the receiver's label\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 44,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "aeef18499580e576f2078b20936842b899b05bd3",
      "in_reply_to_id": 1581993053,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Used `labelled` throughout.",
      "created_at": "2024-05-03T08:15:50Z",
      "updated_at": "2024-05-03T08:15:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588889968",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588889968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 134,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588890103",
      "pull_request_review_id": 2037633133,
      "id": 1588890103,
      "node_id": "PRRC_kwDOAP4Jqs5etIn3",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 18,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": 1581992633,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:15:59Z",
      "updated_at": "2024-05-03T08:15:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588890103",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588890103"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588890267",
      "pull_request_review_id": 2037633411,
      "id": 1588890267,
      "node_id": "PRRC_kwDOAP4Jqs5etIqb",
      "diff_hunk": "@@ -40,6 +40,59 @@ typedef struct {\n     size_t index;\n } secp256k1_silentpayments_recipient;\n \n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ * Given a list of n private keys a_1...a_n (one for each silent payment\n+ * eligible input to spend), a serialized outpoint, and a list of recipients,\n+ * create the taproot outputs:\n+ *\n+ * a_sum = a_1 + a_2 + ... + a_n\n+ * input_hash = hash(outpoint_smallest || (a_sum * G))\n+ * taproot_output = B_spend + hash(a_sum * input_hash * B_scan || k) * G\n+ *\n+ * If necessary, the private keys are negated to enforce the right y-parity.\n+ * For that reason, the private keys have to be passed in via two different parameter\n+ * pairs, depending on whether they seckeys correspond to x-only outputs or not.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 16,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": 1581992596,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:16:10Z",
      "updated_at": "2024-05-03T08:16:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588890267",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588890267"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588892139",
      "pull_request_review_id": 2037636286,
      "id": 1588892139,
      "node_id": "PRRC_kwDOAP4Jqs5etJHr",
      "diff_hunk": "@@ -173,4 +173,90 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 167,
      "original_position": 26,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": 1581992522,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added. Out of curiosity, I noticed we have `VERIFY_CHECK` and `ARG_CHECK`, do you know when one is preferred over the other? In most cases, I see `VERIFY_CHECK` being used to check the `ctx`, but there were a few places where `VERIFY_CHECK` was also being used to check the arguments.",
      "created_at": "2024-05-03T08:17:35Z",
      "updated_at": "2024-05-03T08:17:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588892139",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588892139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 167,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588892272",
      "pull_request_review_id": 2037636462,
      "id": 1588892272,
      "node_id": "PRRC_kwDOAP4Jqs5etJJw",
      "diff_hunk": "@@ -9,8 +9,36 @@\n #include \"../../../include/secp256k1.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(\n+        ((secp256k1_ec_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 16,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "97220f7b29b77677e66a527ec933b022ceb2cceb",
      "in_reply_to_id": 1581992289,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-03T08:17:42Z",
      "updated_at": "2024-05-03T08:17:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588892272",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588892272"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588894474",
      "pull_request_review_id": 2037639947,
      "id": 1588894474,
      "node_id": "PRRC_kwDOAP4Jqs5etJsK",
      "diff_hunk": "@@ -9,8 +9,36 @@\n #include \"../../../include/secp256k1.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *cmp_data) {\n+    return secp256k1_ec_pubkey_cmp(\n+        ((secp256k1_ec_pubkey_sort_cmp_data*)cmp_data)->ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 18,
      "original_position": 11,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "97220f7b29b77677e66a527ec933b022ceb2cceb",
      "in_reply_to_id": 1581992204,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'll admit, I don't fully understand why the double pointers are necessary, but they are: when I removed them, my tests would pass locally but the branch would fail the CI. I noticed the double pointers are also used for the `secp256k1_pubkey_sort` function, so leaving for now.",
      "created_at": "2024-05-03T08:20:03Z",
      "updated_at": "2024-05-03T08:20:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588894474",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588894474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": 17,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": 18,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588895904",
      "pull_request_review_id": 2037642324,
      "id": 1588895904,
      "node_id": "PRRC_kwDOAP4Jqs5etKCg",
      "diff_hunk": "@@ -138,6 +138,90 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_compute_public_data`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represnt a valid public key).\n+ *\n+ *  Args:        ctx: pointer to a context object.\n+ *  Out: public_data: pointer to a silentpayments_public_data object. If 1 is returned, it is set to a\n+ *                    parsed version of input33.\n+ *  In:      input33: pointer to a serialized silentpayments_public_data.\n+ */\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:       ctx: pointer to a context object.\n+ *  Out:   output33: pointer to a 32-byte array to place the serialized key in.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 38,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "41cd97dea39f10a9f537b206b8e3b6a6ab015f35",
      "in_reply_to_id": 1581993315,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-05-03T08:21:36Z",
      "updated_at": "2024-05-03T08:21:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588895904",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588895904"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588905125",
      "pull_request_review_id": 2037657732,
      "id": 1588905125,
      "node_id": "PRRC_kwDOAP4Jqs5etMSl",
      "diff_hunk": "@@ -433,4 +433,137 @@ int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *receiver_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar;\n+    secp256k1_ge receiver_spend_pubkey_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    secp256k1_pubkey A_sum;\n+    unsigned char shared_secret[33];\n+    size_t i, k, n_found;\n+    int found, combined;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    combined = (int)public_data->data[0];\n+    {\n+        unsigned char input_hash[32];\n+        unsigned char *input_hash_ptr;\n+        if (combined) {\n+            input_hash_ptr = NULL;\n+        } else {\n+            memset(input_hash, 0, 32);\n+            input_hash_ptr = input_hash;\n+        }\n+        if (!secp256k1_silentpayments_recipient_public_data_load(ctx, &A_sum, input_hash_ptr, public_data)) {\n+            return 0;\n+        }\n+        secp256k1_pubkey_load(ctx, &receiver_spend_pubkey_ge, receiver_spend_pubkey);\n+        if (!secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, scan_key, &A_sum, input_hash_ptr)) {\n+            return 0;\n+        }\n+    }\n+\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = receiver_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+            return 0;\n+        }\n+\n+        /* If the calculated output matches the one from the tx, we have a direct match and can\n+         * return without labels calculation (one of the two would result in point of infinity) */\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        found = 0;\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                found_outputs[n_found]->output = *tx_outputs[i];\n+                secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+                found = 1;\n+                n_found++;\n+                k++;\n+                break;\n+            }\n+\n+            /* If desired, also calculate label candidates */\n+            if (label_lookup != NULL) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 74,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "f113564298e8e76813289fdcefa6968462dc3fda",
      "in_reply_to_id": 1575010116,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Coming back to this, I tried a few variations but found with the benchmark that comparing the generated output to the tx outputs as serialized bytes is marginally faster than the alternatives, so there wasn't much opportunity for minimizing conversions. I was able to clean up this code a bit, but will likely take a second pass at it.",
      "created_at": "2024-05-03T08:30:50Z",
      "updated_at": "2024-05-03T08:30:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1588905125",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1588905125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 505,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 491,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1616957538",
      "pull_request_review_id": 2082332210,
      "id": 1616957538,
      "node_id": "PRRC_kwDOAP4Jqs5gYNBi",
      "diff_hunk": "@@ -24,6 +24,21 @@ extern \"C\" {\n  * implementation without requiring any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address data.\n+ * The index field is for when more than one address is being sent to in a transaction. Index is\n+ * set based on the original ordering of the addresses and used to return the generated outputs\n+ * matching the original ordering. When more than one recipient is used the recipient array\n+ * will be sorted in place as part of generating the outputs, but the generated outputs will be\n+ * outputs will be returned original ordering specified by the index to ensure the caller is able",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 9,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "ac97828119f39b3fc3f32e00a60e8cc026004306",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, duplicated \"outputs will be\":\r\n```suggestion\r\n * returned in original ordering specified by the index to ensure the caller is able\r\n```",
      "created_at": "2024-05-28T10:08:36Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1616957538",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1616957538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1616958118",
      "pull_request_review_id": 2082332210,
      "id": 1616958118,
      "node_id": "PRRC_kwDOAP4Jqs5gYNKm",
      "diff_hunk": "@@ -24,6 +24,21 @@ extern \"C\" {\n  * implementation without requiring any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address data.\n+ * The index field is for when more than one address is being sent to in a transaction. Index is\n+ * set based on the original ordering of the addresses and used to return the generated outputs\n+ * matching the original ordering. When more than one recipient is used the recipient array\n+ * will be sorted in place as part of generating the outputs, but the generated outputs will be\n+ * outputs will be returned original ordering specified by the index to ensure the caller is able\n+ * to match up the generated outputs to the correct silent payment address (e.g. to be able to\n+ * assign the correct amounts to the correct generatetd outputs in the final transaction).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 11,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "ac97828119f39b3fc3f32e00a60e8cc026004306",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n * assign the correct amounts to the correct generated outputs in the final transaction).\r\n```",
      "created_at": "2024-05-28T10:08:59Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1616958118",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1616958118"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617682290",
      "pull_request_review_id": 2082332210,
      "id": 1617682290,
      "node_id": "PRRC_kwDOAP4Jqs5ga99y",
      "diff_hunk": "@@ -173,4 +173,90 @@ int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx,\n     return 1;\n }\n \n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char a_sum[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(recipients != NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 167,
      "original_position": 26,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "50dcc1aeddfc2d522ebe02b9709f8c1c119c6027",
      "in_reply_to_id": 1581992522,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sorry for the late reply, missed this comment. To my understanding, the differences are: `VERIFY_CHECK`s are not included in production builds (i.e. only done for tests), while `ARG_CHECK`s are always done. The latter call an illegal callback if the check fails, but need a `ctx` object for that, so the `ctx != NULL` condition can't be checked via `ARG_CHECK` (if it failed, `ctx->illegal_callback` would be a null pointer dereference). I don't think there is usually a good reason to do an argument check with `VERIFY_CHECK` though, as users wouldn't notice immediately if they pass something wrong. I guess you saw `VERIFY_CHECK`s for argument checks that are not for public API functions?\r\n\r\nnit: could also add `ARG_CHECK(generated_outputs != NULL)` here",
      "created_at": "2024-05-28T17:43:42Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617682290",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617682290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 167,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617695781",
      "pull_request_review_id": 2082332210,
      "id": 1617695781,
      "node_id": "PRRC_kwDOAP4Jqs5gbBQl",
      "diff_hunk": "@@ -37,4 +38,84 @@ int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+/* secp256k1_ecdh expects a hash function to be passed in or uses its default\n+ * hashing function. We don't want to hash the ECDH result yet (it will be\n+ * hashed later with a counter `k`), so we define a custom function which simply\n+ * returns the pubkey without hashing.\n+ */\n+static int secp256k1_silentpayments_ecdh_return_pubkey(unsigned char *output, const unsigned char *x32, const unsigned char *y32, void *data) {\n+    secp256k1_ge point;\n+    secp256k1_fe x, y;\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    (void)data;\n+    /* Parse point as group element */\n+    if (!secp256k1_fe_set_b32_limit(&x, x32) || !secp256k1_fe_set_b32_limit(&y, y32)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_xy(&point, &x, &y);\n+\n+    /* Serialize as compressed pubkey */\n+    ser_ret = secp256k1_eckey_pubkey_serialize(&point, output, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == 33);\n+    (void)ser_ret;\n+\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const unsigned char *secret_component, const secp256k1_pubkey *public_component, unsigned char *input_hash) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 68,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "f35ab7daa4aa598923e3e3774c14f97bf1e522c9",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: can be made static, as it's not part of the public API (I was slightly confused as I wondered why the API description isn't added in the same commit, but the API function in a later commit calls this function rather than directly exposing it).",
      "created_at": "2024-05-28T17:56:09Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617695781",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617695781"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617696482",
      "pull_request_review_id": 2082332210,
      "id": 1617696482,
      "node_id": "PRRC_kwDOAP4Jqs5gbBbi",
      "diff_hunk": "@@ -118,4 +119,54 @@ int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx,\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 41,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "a4f35830914cde97de0082e8d695df51e0de1b8b",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: can also be made static",
      "created_at": "2024-05-28T17:56:44Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617696482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617696482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617700300",
      "pull_request_review_id": 2082332210,
      "id": 1617700300,
      "node_id": "PRRC_kwDOAP4Jqs5gbCXM",
      "diff_hunk": "@@ -139,6 +139,139 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in size. It can be safely\n+ *  copied/moved. Created with `secp256k1_silentpayments_public_data_create`. Can be serialized as\n+ *  a compressed public key using `secp256k1_silentpayments_public_data_serialize`. The serialization\n+ *  is intended for sending the public input data to light clients. Light clients can use this\n+ *  serialization with `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction inputs.\n+ *\n+ * Given a list of n public keys A_1...A_n (one for each silent payment\n+ * eligible input to spend) and a serialized outpoint_smallest, compute\n+ * the corresponding input public tweak data:\n+ *\n+ * A_sum = A_1 + A_2 + ... + A_n\n+ * input_hash = hash(outpoint_lowest || A_sum)\n+ *\n+ * The public keys have to be passed in via two different parameter pairs,\n+ * one for regular and one for x-only public keys, in order to avoid the need\n+ * of users converting to a common pubkey format before calling this function.\n+ * The resulting data is can be used for scanning on the recipient side, or stored\n+ * in an index for late use (e.g. wallet rescanning, vending data to light clients).\n+ *\n+ * If calling this function for scanning, the reciever must provide an output param\n+ * for the `input_hash`. If calling this function for simply aggregating the inputs\n+ * for later use, the caller can save the result with `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:           public_data: pointer to public_data object containing the summed public key and\n+ *                              input_hash.\n+ *  In:    outpoint_smallest36: serialized smallest outpoint\n+ *               xonly_pubkeys: pointer to an array of pointers to taproot x-only\n+ *                              public keys (can be NULL if no taproot inputs are used)\n+ *             n_xonly_pubkeys: the number of taproot input public keys\n+ *               plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                              public keys (can be NULL if no non-taproot inputs are used)\n+ *             n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:       ctx: pointer to a context object.\n+ *  Out:   output33: pointer to a 33-byte array to place the serialized `silentpayments_public_data` in.\n+ *  In: public_data: pointer to an initialized silentpayments_public_data object.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g. does not represent a valid public key).\n+ *\n+ *  Args:        ctx: pointer to a context object.\n+ *  Out: public_data: pointer to a silentpayments_public_data object. If 1 is returned, it is set to a\n+ *                    parsed version of input33.\n+ *  In:      input33: pointer to a serialized silentpayments_public_data.\n+ */\n+\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key B_spend, and the relevant transaction\n+ *  outputs, scan for outputs belong to the recipient and return the tweak(s) needed for spending\n+ *  the output(s). An optional label_lookup callback function and label_context can be passed if the\n+ *  recipient uses labels. This allows for checking if a label exists in the recipients label cache\n+ *  and retrieving the label tweak during scanning.\n+ *\n+ *  Returns: 1 if output scanning was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:         found_outputs: pointer to an array of pointers to found output objects. The found outputs\n+ *                              array MUST be initialized to be the same length as the tx_outputs array\n+ *             n_found_outputs: pointer to an integer indicating the final size of the found outputs array.\n+ *                              This number represents the number of outputs found while scanning (0 if\n+ *                              none are found)\n+ *  In:             tx_outputs: pointer to the tx's x-only public key outputs\n+ *                n_tx_outputs: the number of tx_outputs being scanned\n+ *                    scan_key: pointer to the recipient's scan key\n+ *                 public_data: pointer to the input public key sum (optionaly, with the `input_hash`\n+ *                              multiplied in, see `_recipient_compute_public_data`).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 107,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "d43636b96d359b4ba5e7af5c12c7833e116ecc26",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *                              multiplied in, see `_recipient_public_data_create`).\r\n```",
      "created_at": "2024-05-28T18:00:12Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617700300",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617700300"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617702291",
      "pull_request_review_id": 2082332210,
      "id": 1617702291,
      "node_id": "PRRC_kwDOAP4Jqs5gbC2T",
      "diff_hunk": "@@ -272,6 +272,58 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)\n     SECP256K1_ARG_NONNULL(6) SECP256K1_ARG_NONNULL(7) SECP256K1_ARG_NONNULL(8);\n \n+/** Create Silent Payment shared secret.\n+ *\n+ * Given the public input data (A_tweaked = input_hash * A_sum), calculate the shared secret using ECDH:\n+ *\n+ * shared_secret = b_scan * A_tweaked   [Recipient, Light client scenario]\n+ *\n+ * The resulting shared secret is needed as input for creating silent payments\n+ * outputs belonging to the same recipient scan public key.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occured.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:       shared_secret33: pointer to the resulting 33-byte shared secret\n+ *  In:     recipient_scan_key: pointer to the recipient's scan key\n+ *                 public_data: pointer to the input public key sum, tweaked with the input_hash\n+ *                              (see `_recipient_compute_public_data`)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 18,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "b58f89117e0765759a2f3c2a3f1782d9c30eb776",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *                              (see `_recipient_public_data_create`)\r\n```",
      "created_at": "2024-05-28T18:01:56Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617702291",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617702291"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617706659",
      "pull_request_review_id": 2082332210,
      "id": 1617706659,
      "node_id": "PRRC_kwDOAP4Jqs5gbD6j",
      "diff_hunk": "@@ -179,7 +183,7 @@ int main(int argc, char** argv) {\n     char* valid_args[] = {\"ecdsa\", \"verify\", \"ecdsa_verify\", \"sign\", \"ecdsa_sign\", \"ecdh\", \"recover\",\n                          \"ecdsa_recover\", \"schnorrsig\", \"schnorrsig_verify\", \"schnorrsig_sign\", \"ec\",\n                          \"keygen\", \"ec_keygen\", \"ellswift\", \"encode\", \"ellswift_encode\", \"decode\",\n-                         \"ellswift_decode\", \"ellswift_keygen\", \"ellswift_ecdh\"};\n+                         \"ellswift_decode\", \"ellswift_keygen\", \"ellswift_ecdh\", \"silentpayments\"};",
      "path": "src/bench.c",
      "position": 27,
      "original_position": 16,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "baafed004cdf3580659e0a475b91564efef837fb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: should also add this on the `help` function on top of the file",
      "created_at": "2024-05-28T18:04:47Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617706659",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617706659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 190,
      "original_line": 190,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617720108",
      "pull_request_review_id": 2082332210,
      "id": 1617720108,
      "node_id": "PRRC_kwDOAP4Jqs5gbHMs",
      "diff_hunk": "@@ -320,4 +320,109 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(plain_pubkeys == NULL || n_plain_pubkeys >= 1);\n+    ARG_CHECK(xonly_pubkeys == NULL || n_xonly_pubkeys >= 1);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    ARG_CHECK((n_plain_pubkeys + n_xonly_pubkeys) >= 1);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        /* TODO: do we need a special error return code for this case? */\n+        return 0;\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 43,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "d43636b96d359b4ba5e7af5c12c7833e116ecc26",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd say the answer to this open TODO question is \"yes\". If a user scans a tx where the silent payments eligible input's public keys cancel each other out, this probably deserves its own return code to differentiate between the cases \"user misuses API / passed in wrong data\" and \"passed in data could be legit, but we can't continue\" (as discussed before in the earlier PR, e.g. https://github.com/bitcoin-core/secp256k1/pull/1471#issuecomment-1913695251). Would be interesting to hear maintainers opinions on API design here; to my knowledge, currently there is no public API functions that returns anything different than 0 or 1. If the successful return value is still 1, having two errors codes would be e.g. 0 and 2, which seems kind of strange.",
      "created_at": "2024-05-28T18:17:35Z",
      "updated_at": "2024-05-28T18:19:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1617720108",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1617720108"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 359,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670455581",
      "pull_request_review_id": 2166196376,
      "id": 1670455581,
      "node_id": "PRRC_kwDOAP4Jqs5jkSEd",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 449,
      "original_position": 101,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ef597945b2632862158a9477a74c1a525e92ffe9: to sanity check the test vectors themselves, if a matching `plain_seckeys[i]` entry exists, derive the public key to see that it matches. I can currently change a byte in the first test vector sec and pub key without breaking a test.",
      "created_at": "2024-07-09T12:37:42Z",
      "updated_at": "2024-07-09T12:38:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670455581",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670455581"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 449,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670483699",
      "pull_request_review_id": 2166243919,
      "id": 1670483699,
      "node_id": "PRRC_kwDOAP4Jqs5jkY7z",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 449,
      "original_position": 101,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Mmm, even if malform `vectors.h` by deleting the `struct bip352_test_vector {` line `make check` is fine. That take a `make clean`. Seems like a Makefile bug.",
      "created_at": "2024-07-09T12:56:19Z",
      "updated_at": "2024-07-09T12:56:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670483699",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670483699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 449,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670493260",
      "pull_request_review_id": 2166261003,
      "id": 1670493260,
      "node_id": "PRRC_kwDOAP4Jqs5jkbRM",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 449,
      "original_position": 101,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So when I modify the first sec key in the first test vector the test does fail, and test-suite.log shows it happens at line 412 - which makes sense. The suggested sanity check would help debugging though.",
      "created_at": "2024-07-09T13:02:42Z",
      "updated_at": "2024-07-09T13:02:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670493260",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670493260"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 449,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670519831",
      "pull_request_review_id": 2166304629,
      "id": 1670519831,
      "node_id": "PRRC_kwDOAP4Jqs5jkhwX",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,",
      "path": "examples/silentpayments.c",
      "position": 224,
      "original_position": 201,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: it might be safer to have this function take an array of all outpoints of the previous transaction (and `N_TX_INPUTS`) and pick the \"smallest\" one. An implementer who [knows what they're doing](https://github.com/bitcoin/bitcoin/pull/28241#issuecomment-2079095313) can pick it themselves and simply pass an array of size 1.\r\n\r\nIf you keep the interface the same, then it would be good to document `unsigned char smallest_outpoint` above, because it's the only non-obvious variable in this example.",
      "created_at": "2024-07-09T13:19:29Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670519831",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670519831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670529348",
      "pull_request_review_id": 2166304629,
      "id": 1670529348,
      "node_id": "PRRC_kwDOAP4Jqs5jkkFE",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 175,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: is there a reason to make this more contrived than just a single change address? The \"Note\" below would be fine even if the second Carol address wasn't used in the example.",
      "created_at": "2024-07-09T13:25:42Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670529348",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670529348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670534893",
      "pull_request_review_id": 2166304629,
      "id": 1670534893,
      "node_id": "PRRC_kwDOAP4Jqs5jklbt",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 177,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: maybe move \"adds the index of the ...\" below to where you set `index`.",
      "created_at": "2024-07-09T13:28:50Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670534893",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670534893"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670536761",
      "pull_request_review_id": 2166304629,
      "id": 1670536761,
      "node_id": "PRRC_kwDOAP4Jqs5jkl45",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 188,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60\r\n\r\n```c\r\n/** Read the scan public key, which is the first part of a silent payment address */\r\n```",
      "created_at": "2024-07-09T13:30:08Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670536761",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670536761"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670544678",
      "pull_request_review_id": 2166304629,
      "id": 1670544678,
      "node_id": "PRRC_kwDOAP4Jqs5jkn0m",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 196,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: I find myself confused about the difference between `tx_outputs` and `generated_output_ptrs`. Can you make `tx_outputs` an array of pointers and just use that? I might have missed something.\r\n\r\nA better name might be:\r\n```c\r\n/** The x-only pubkey for each output taproot scriptPubKey. */\r\nsecp256k1_xonly_pubkey *tx_output_pubkey_ptrs[N_TX_OUTPUTS];\r\n```",
      "created_at": "2024-07-09T13:35:22Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670544678",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670544678"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670566910",
      "pull_request_review_id": 2166304629,
      "id": 1670566910,
      "node_id": "PRRC_kwDOAP4Jqs5jktP-",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,",
      "path": "examples/silentpayments.c",
      "position": 223,
      "original_position": 200,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you like the above rename, then this one would be:\r\n\r\n```c\r\n/** The silent recipient for each output or null for a regular address. */\r\nconst secp256k1_silentpayments_recipient *tx_output_recipient_ptrs[N_TX_OUTPUTS];\r\n```\r\n\r\n(the description here is more important than the name, just `recipient_ptrs` is probably fine)",
      "created_at": "2024-07-09T13:48:55Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670566910",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670566910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670572194",
      "pull_request_review_id": 2166304629,
      "id": 1670572194,
      "node_id": "PRRC_kwDOAP4Jqs5jkuii",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": 137,
      "original_position": 127,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```c\r\n/** The private key for each silent payment eligible input, null otherwise. */\r\n```",
      "created_at": "2024-07-09T13:52:14Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670572194",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670572194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 137,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670590035",
      "pull_request_review_id": 2166304629,
      "id": 1670590035,
      "node_id": "PRRC_kwDOAP4Jqs5jky5T",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": 274,
      "original_position": 236,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60\r\n\r\n```c\r\n/** For each Silent Payment eligible input we collect all pubkeys\r\n  * found in the scriptSig or witness. For simplicity in this \r\n  * example inputs have only one pubkey.\r\n  */\r\nconst secp256k1_xonly_pubkey *tx_input_pubkey_ptrs[N_TX_INPUTS];\r\n```",
      "created_at": "2024-07-09T14:02:42Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670590035",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670590035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 274,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670599501",
      "pull_request_review_id": 2166304629,
      "id": 1670599501,
      "node_id": "PRRC_kwDOAP4Jqs5jk1NN",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 256,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: the example would be easier to follow if you first demonstrate usage without labels, since they're optional.",
      "created_at": "2024-07-09T14:08:50Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670599501",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670599501"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670602364",
      "pull_request_review_id": 2166304629,
      "id": 1670602364,
      "node_id": "PRRC_kwDOAP4Jqs5jk158",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 280,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c71791c629ec88e2e253aae4157d7113b60bee60: maybe emphasise that we only need the _scan_ private key",
      "created_at": "2024-07-09T14:10:27Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670602364",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670602364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670608423",
      "pull_request_review_id": 2166304629,
      "id": 1670608423,
      "node_id": "PRRC_kwDOAP4Jqs5jk3Yn",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and used the labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key. Storing it this way saves 32 bytes for the light client because\n+             * now it can be send as a 33 byte compressed public key instead of 33 bytes for A_sum and 32 bytes for input_hash.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,",
      "path": "examples/silentpayments.c",
      "position": 384,
      "original_position": 318,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The documentation for `secp256k1_silentpayments_recipient_scan_outputs` needs to be moved below the typedef and struct. At least otherwise VSCode doesn't find it.",
      "created_at": "2024-07-09T14:14:27Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670608423",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670608423"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 384,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670624345",
      "pull_request_review_id": 2166304629,
      "id": 1670624345,
      "node_id": "PRRC_kwDOAP4Jqs5jk7RZ",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": 297,
      "original_position": 265,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can be demystified with something like this:\r\n\r\n```c\r\n/** Public data is an x-only (?) public key that can be generated\r\n  * for each transaction without knowledge of either the input\r\n  * private keys or the recipient silent payment address. This\r\n  * function performs ECDH on it and checks if any found_output_ptrs\r\n  * contains the resulting x-only pubkey - indication it's a silent\r\n  * payment to us.\r\n  * See also light client scanning below.\r\n  */\r\n```",
      "created_at": "2024-07-09T14:24:24Z",
      "updated_at": "2024-07-09T14:30:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670624345",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670624345"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 297,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670637013",
      "pull_request_review_id": 2166504001,
      "id": 1670637013,
      "node_id": "PRRC_kwDOAP4Jqs5jk-XV",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": 297,
      "original_position": 265,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It might even make sense to move the light client example up, since by necessity it explains some of the things that happen automagically.",
      "created_at": "2024-07-09T14:31:39Z",
      "updated_at": "2024-07-09T14:31:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670637013",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670637013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 297,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670750586",
      "pull_request_review_id": 2166692075,
      "id": 1670750586,
      "node_id": "PRRC_kwDOAP4Jqs5jlaF6",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 449,
      "original_position": 101,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Mmm, even if malform vectors.h by deleting the struct bip352_test_vector { line make check is fine.\r\n\r\nSounds like make is not picking up that `vectors.h` changed? Will look into this.\r\n\r\n> to sanity check the test vectors themselves, if a matching plain_seckeys[i] entry exists, derive the public key to see that it matches\r\n\r\nThis would make the tests run slower, and I don't really see the value. Since the values for the tests are static, seems sufficient to do a one-time manual check as part of testing vs make this run every time in the CI?",
      "created_at": "2024-07-09T15:36:18Z",
      "updated_at": "2024-07-09T15:36:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1670750586",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1670750586"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 449,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673610346",
      "pull_request_review_id": 2171240854,
      "id": 1673610346,
      "node_id": "PRRC_kwDOAP4Jqs5jwURq",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 449,
      "original_position": 101,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> a one-time manual check\r\n\r\nMaybe the Python script can do it?",
      "created_at": "2024-07-11T08:22:17Z",
      "updated_at": "2024-07-11T08:22:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673610346",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673610346"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 449,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673629197",
      "pull_request_review_id": 2171270367,
      "id": 1673629197,
      "node_id": "PRRC_kwDOAP4Jqs5jwY4N",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 449,
      "original_position": 101,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You can add the file here:\r\nhttps://github.com/bitcoin-core/secp256k1/blob/0055b86780f2aa7272a1c307f6b9cd298584340f/Makefile.am#L237-L243 \r\n\r\nThen CI will check that the files match:\r\nhttps://github.com/bitcoin-core/secp256k1/blob/0055b86780f2aa7272a1c307f6b9cd298584340f/ci/ci.sh#L138-L147\r\n\r\nNote in case you're wondering: There's no CMake equivalent for this. It's our own internal stuff, so there was no need to port it to CMake.\r\n\r\n",
      "created_at": "2024-07-11T08:35:48Z",
      "updated_at": "2024-07-11T08:35:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673629197",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673629197"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 449,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673641829",
      "pull_request_review_id": 2171290605,
      "id": 1673641829,
      "node_id": "PRRC_kwDOAP4Jqs5jwb9l",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": 297,
      "original_position": 265,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> ```c\r\n> /** Public data is an x-only (?) public key that can be generated\r\n>   * for each transaction without knowledge of either the input\r\n>   * private keys or the recipient silent payment address. This\r\n>   * function performs ECDH on it and checks if any found_output_ptrs\r\n>   * contains the resulting x-only pubkey - indication it's a silent\r\n>   * payment to us.\r\n>   * See also light client scanning below.\r\n>   */\r\n> ```\r\n\r\nDemystifying is a good idea, but I think we shouldn't mix API usage with protocol internals. (If people want to know how it works under the hood, they should just read the BIP.)\r\n\r\n - The public data is public data that can be generated for each transaction without knowledge of either the input private keys or the recipient silent payment address. Whether it's a public key is not relevant for API users. \r\n - This checks if it's (potential) silent payment to us. The fact that it does an ECDH key exchange is a detail of the protocol. \r\n\r\nedit: Of course, this is not a strict requirement but rather a rule of thumb. For example, the first few lines of the module docs in `include/secp256k1_silentpayments.h` mention ECDH, and I guess that's fine as a tiny bit of background what this module does at all.",
      "created_at": "2024-07-11T08:44:43Z",
      "updated_at": "2024-07-11T08:50:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673641829",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673641829"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 297,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673706429",
      "pull_request_review_id": 2171391280,
      "id": 1673706429,
      "node_id": "PRRC_kwDOAP4Jqs5jwru9",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": 297,
      "original_position": 265,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I wrote most of this based on my own initial confusion with the example code, and I have read the BIP. Agree it shouldn't duplicate the whole thing, just enough so people understand what the code is trying to do.\r\n\r\nE.g. the only reason I understood what \"public data\" referred to was from @josibake's way of phrasing stuff in a podcast.",
      "created_at": "2024-07-11T09:26:44Z",
      "updated_at": "2024-07-11T09:28:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673706429",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673706429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 297,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673724190",
      "pull_request_review_id": 2171419611,
      "id": 1673724190,
      "node_id": "PRRC_kwDOAP4Jqs5jwwEe",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,",
      "path": "examples/silentpayments.c",
      "position": 224,
      "original_position": 201,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670519831,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd prefer to keep the interface the same, but agree \"smallest outpoint\" needs better documentation.\r\n\r\nIf we change this to accept an array of outpoints, it doesn't actually prevent the caller from making a mistake: they can pass an array of size 1 with the wrong outpoint, or pass a subset of outpoints that doesn't include the smallest outpoint. It does, however, require the caller to pass extra data to the function that is then immediately discarded and makes the API a bit more complicated.\r\n\r\nIn this case, seems better to prefer the simpler API along with good documentation on the importance of choosing this value correctly.",
      "created_at": "2024-07-11T09:38:24Z",
      "updated_at": "2024-07-11T09:38:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673724190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673724190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673837049",
      "pull_request_review_id": 2171602423,
      "id": 1673837049,
      "node_id": "PRRC_kwDOAP4Jqs5jxLn5",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": 297,
      "original_position": 265,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> E.g. the only reason I understood what \"public data\" referred to was from @josibake's way of phrasing stuff in a podcast.\r\n\r\nPerhaps we can find a better term? (Public) scanning data?\r\n\r\nBy the way, I listened to that epsiode yesterday... :)",
      "created_at": "2024-07-11T11:12:14Z",
      "updated_at": "2024-07-11T11:12:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673837049",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673837049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 297,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673844535",
      "pull_request_review_id": 2171615005,
      "id": 1673844535,
      "node_id": "PRRC_kwDOAP4Jqs5jxNc3",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 175,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670529348,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The reason is to demonstrate how to create multiple outputs for the same user. This is mentioned in the documentation for the API but I felt this would be a good one to have an example for, e.g., to show how to set the indexes on the recipient object correctly and to demonstrate how the generated outputs are matched back up to the correct recipients.\r\n\r\nI think it's better to have a more complicated example for demonstrating the API usage considering in this case, all that's needed for a more simple use case is to just remove objects from the recipient array.",
      "created_at": "2024-07-11T11:19:05Z",
      "updated_at": "2024-07-11T11:19:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673844535",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673844535"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673851404",
      "pull_request_review_id": 2171626279,
      "id": 1673851404,
      "node_id": "PRRC_kwDOAP4Jqs5jxPIM",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 196,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670544678,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch, I think this would be less confusing if more consistent naming were used, e.g., `tx_outputs; tx_output_ptrs`. Regarding the API: arrays are passed as a pointer to an array of pointers to objects. This means we need to first create the array of objects (`tx_outputs`), and then create the array of pointers to those objects (`tx_output_ptrs`).\r\n\r\nIn the case of `tx_outputs`, it's less obvious why the we want the pointer to array of pointers approach, but I think its better to keep the API consistent, i.e., if passing an array to the function, it must be a pointer to an array of pointers.\r\n\r\nI think this might warrant a `doc/silentpayments.md` explaining the usage of the API, similar to the musig2 PR.",
      "created_at": "2024-07-11T11:25:15Z",
      "updated_at": "2024-07-11T11:52:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673851404",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673851404"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673854679",
      "pull_request_review_id": 2171631797,
      "id": 1673854679,
      "node_id": "PRRC_kwDOAP4Jqs5jxP7X",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": 274,
      "original_position": 236,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670590035,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually, the eligible inputs from the BIP were chosen so that there is only one public key per input. This is why `OP_CHECKMULTISIG` inputs are not eligible for silent payments, for example.",
      "created_at": "2024-07-11T11:28:13Z",
      "updated_at": "2024-07-11T11:28:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673854679",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673854679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 274,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673857157",
      "pull_request_review_id": 2171635848,
      "id": 1673857157,
      "node_id": "PRRC_kwDOAP4Jqs5jxQiF",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 256,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670599501,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I considered this, but as mentioned in https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673844535, the goal of the example is to provide guidance for the more complicated usage of the API. In this case, the goal is to give a concrete example of what the `label_context` is.\r\n\r\nPerhaps its worth adding a comment mentioning that labels are optional and using without labels is as simple as calling the function with `NULL, NULL` for label_lookup and label_context.",
      "created_at": "2024-07-11T11:30:23Z",
      "updated_at": "2024-07-11T11:30:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673857157",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673857157"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673858218",
      "pull_request_review_id": 2171637646,
      "id": 1673858218,
      "node_id": "PRRC_kwDOAP4Jqs5jxQyq",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 280,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670602364,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not sure what you mean here? In order to scan, Bob needs his `scan` key _and_ spend public key.",
      "created_at": "2024-07-11T11:31:21Z",
      "updated_at": "2024-07-11T11:31:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673858218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673858218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673858617",
      "pull_request_review_id": 2171638377,
      "id": 1673858617,
      "node_id": "PRRC_kwDOAP4Jqs5jxQ45",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and used the labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key. Storing it this way saves 32 bytes for the light client because\n+             * now it can be send as a 33 byte compressed public key instead of 33 bytes for A_sum and 32 bytes for input_hash.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,",
      "path": "examples/silentpayments.c",
      "position": 384,
      "original_position": 318,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670608423,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nice catch! Will fix and add documentation for the struct.",
      "created_at": "2024-07-11T11:31:44Z",
      "updated_at": "2024-07-11T11:31:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673858617",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673858617"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 384,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673946164",
      "pull_request_review_id": 2171781333,
      "id": 1673946164,
      "node_id": "PRRC_kwDOAP4Jqs5jxmQ0",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,",
      "path": "examples/silentpayments.c",
      "position": 223,
      "original_position": 200,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670566910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The array here would never contain nulls for \"regular addresses,\" so I don't think the description here is accurate.",
      "created_at": "2024-07-11T12:41:27Z",
      "updated_at": "2024-07-11T12:41:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673946164",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673946164"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673946884",
      "pull_request_review_id": 2171782382,
      "id": 1673946884,
      "node_id": "PRRC_kwDOAP4Jqs5jxmcE",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": 137,
      "original_position": 127,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670572194,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same comment as above, these arrays would never contain non-silent payment eligible data.",
      "created_at": "2024-07-11T12:41:56Z",
      "updated_at": "2024-07-11T12:41:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673946884",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673946884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 137,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673973270",
      "pull_request_review_id": 2171825201,
      "id": 1673973270,
      "node_id": "PRRC_kwDOAP4Jqs5jxs4W",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": 297,
      "original_position": 265,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I agree its better to refer people to the BIP if they are interested in the internals. For `public_data` specifically, I think the documentation for `_public_data_create` should be sufficient for explaining to the caller what a `public_data` object is.\r\n\r\nAs @Sjors pointed out in a different comment, `smallest_outpoint` isn't well documented, but aside from that I think referring to this function should be sufficient for the caller.",
      "created_at": "2024-07-11T12:58:04Z",
      "updated_at": "2024-07-11T12:58:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1673973270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1673973270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 297,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674828546",
      "pull_request_review_id": 2173313611,
      "id": 1674828546,
      "node_id": "PRRC_kwDOAP4Jqs5j09sC",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 18,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "as this function always succeeds, it could just be `void` with the `return 1;` removed",
      "created_at": "2024-07-11T23:48:36Z",
      "updated_at": "2024-07-12T00:24:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1674828546",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674828546"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674829069",
      "pull_request_review_id": 2173313611,
      "id": 1674829069,
      "node_id": "PRRC_kwDOAP4Jqs5j090N",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 68,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "micro-nit: `len` is a pure out-parameter for `_eckey_pubkey_serialize`, so it doesn't need to be initialized (in contrast to the public API function `_ec_pubkey_serialize` where it is an In/Out param)\r\n```suggestion\r\n    size_t len;\r\n```",
      "created_at": "2024-07-11T23:49:34Z",
      "updated_at": "2024-07-12T00:24:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1674829069",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674829069"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674831667",
      "pull_request_review_id": 2173313611,
      "id": 1674831667,
      "node_id": "PRRC_kwDOAP4Jqs5j0-cz",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 76,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this call should always succeed (same as in `_silentpayments_calculate_input_hash` above), given that the only reason to return 0 is if the passed group element is the point at inifinity, which should never happen? If that assumption is right, then we could make the whole function `void`, and a `VERIFY_CHECK` on `ret` and `len` would be sufficient",
      "created_at": "2024-07-11T23:55:04Z",
      "updated_at": "2024-07-12T00:24:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1674831667",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674831667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674851580",
      "pull_request_review_id": 2173313611,
      "id": 1674851580,
      "node_id": "PRRC_kwDOAP4Jqs5j1DT8",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+\n+    /* This will fail if B_spend + t_k*G is the point at infinity */\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    /* TODO: any concerns here with multiplying a \"secret\" by a scalar here, i.e., input_hash * a_sum\n+     * Mostly concerned about cases where a_sum is a single key and leaking information about a_sum\n+     * since input_hash can be calculated by anyone\n+     */\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 209,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Regarding the TODO, I strongly assume that this is fine. For example, in `secp256k1_ecdsa_sig_sign` we also have a `_scalar_mul` call with a scalar corresponding to a secret key.",
      "created_at": "2024-07-12T00:14:40Z",
      "updated_at": "2024-07-12T00:24:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1674851580",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674851580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 209,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674861098",
      "pull_request_review_id": 2173313611,
      "id": 1674861098,
      "node_id": "PRRC_kwDOAP4Jqs5j1Foq",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 104,
      "original_position": 97,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`hash_ser` should probably also be cleaned out, as it's just another representation of `t_k_scalar` (which is in turn cleaned out in the calling function below)",
      "created_at": "2024-07-12T00:19:15Z",
      "updated_at": "2024-07-12T00:24:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1674861098",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1674861098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 104,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675214177",
      "pull_request_review_id": 2173748186,
      "id": 1675214177,
      "node_id": "PRRC_kwDOAP4Jqs5j2b1h",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+\n+    /* This will fail if B_spend + t_k*G is the point at infinity */\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    /* TODO: any concerns here with multiplying a \"secret\" by a scalar here, i.e., input_hash * a_sum\n+     * Mostly concerned about cases where a_sum is a single key and leaking information about a_sum\n+     * since input_hash can be calculated by anyone\n+     */\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 209,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674851580,
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "But if `a_sum` is a single key, is it possible to calculate the secret key, given any derived public information (such as the generated output) ?",
      "created_at": "2024-07-12T04:00:24Z",
      "updated_at": "2024-07-12T04:00:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675214177",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675214177"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 209,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675423437",
      "pull_request_review_id": 2174042925,
      "id": 1675423437,
      "node_id": "PRRC_kwDOAP4Jqs5j3O7N",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,",
      "path": "examples/silentpayments.c",
      "position": 224,
      "original_position": 201,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670519831,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good documentation sounds fine too. IIRC the main gotcha is to not interpret the output position as an integer when doing the comparison, as most wallets probably store outpoints as `{uint256, uint32}` instead of 36 (?) serialized bytes.",
      "created_at": "2024-07-12T07:16:29Z",
      "updated_at": "2024-07-12T07:17:48Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675423437",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675423437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675430786",
      "pull_request_review_id": 2174054366,
      "id": 1675430786,
      "node_id": "PRRC_kwDOAP4Jqs5j3QuC",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 175,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670529348,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The problem with complicated examples in general is that they distract the reader into trying to understand what the example is about, rather than focus on how to code it.\r\n\r\nAnother approach could be:\r\n\r\n```c\r\nsp_addresses[0] = &carol_address; /* : 1.0 BTC */\r\nsp_addresses[1] = &bob_address;   /* : 2.0 BTC */\r\n/*\r\n * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\r\n * address again, e.g.:\r\n * \r\n * sp_addresses[2] = &carol_address; /* : 3.0 BTC */\r\n * \r\n */",
      "created_at": "2024-07-12T07:23:34Z",
      "updated_at": "2024-07-12T07:24:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675430786",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675430786"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675436453",
      "pull_request_review_id": 2174063598,
      "id": 1675436453,
      "node_id": "PRRC_kwDOAP4Jqs5j3SGl",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 196,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670544678,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree it's better to keep the API consistent.\r\n\r\nThere's no magical C way to create an array of pointers to objects without first going through an array of objects? In any case the naming change makes it clear that `tx_outputs` and `tx_output_ptrs` refer to the same \"stuff\".",
      "created_at": "2024-07-12T07:28:35Z",
      "updated_at": "2024-07-12T07:28:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675436453",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675436453"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675437422",
      "pull_request_review_id": 2174065075,
      "id": 1675437422,
      "node_id": "PRRC_kwDOAP4Jqs5j3SVu",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,",
      "path": "examples/silentpayments.c",
      "position": 223,
      "original_position": 200,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670566910,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Then what's in the output positions that aren't a silent payment?",
      "created_at": "2024-07-12T07:29:28Z",
      "updated_at": "2024-07-12T07:29:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675437422",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675437422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675439259",
      "pull_request_review_id": 2174067878,
      "id": 1675439259,
      "node_id": "PRRC_kwDOAP4Jqs5j3Syb",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+\n+    /* This will fail if B_spend + t_k*G is the point at infinity */\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    /* TODO: any concerns here with multiplying a \"secret\" by a scalar here, i.e., input_hash * a_sum\n+     * Mostly concerned about cases where a_sum is a single key and leaking information about a_sum\n+     * since input_hash can be calculated by anyone\n+     */\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 209,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674851580,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I strongly assume that this is fine\r\n\r\nSame. Left the comment more to draw eyes from the \"Friendly Neighborhood Cryptographers.\" I'm not aware of any timing attacks that work with multiplying scalars or information that could be leaked, but wanted to double check.\r\n\r\n> is it possible to calculate the secret key, given any derived public information\r\n\r\nNo. This is a question about whether or not an attacker can learn anything from the multiplication step.",
      "created_at": "2024-07-12T07:31:04Z",
      "updated_at": "2024-07-12T07:31:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675439259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675439259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 209,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675442354",
      "pull_request_review_id": 2174072251,
      "id": 1675442354,
      "node_id": "PRRC_kwDOAP4Jqs5j3Tiy",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": 274,
      "original_position": 236,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670590035,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, nice! In that case:\r\n\r\n```c\r\n/** For each Silent Payment eligible input we collect the pubkey\r\n  * found in its scriptSig or witness. See Inputs For Shared Secret Derivation\r\n  * in the BIP.\r\n  */\r\n```\r\n",
      "created_at": "2024-07-12T07:33:36Z",
      "updated_at": "2024-07-12T07:34:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675442354",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675442354"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 274,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675447695",
      "pull_request_review_id": 2174080834,
      "id": 1675447695,
      "node_id": "PRRC_kwDOAP4Jqs5j3U2P",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 256,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670599501,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same reaction. I think you need to guide people through a simple usage before covering a more advanced one. Otherwise anyone just looking for the simple use case will give up confused. And most people looking for an advanced use case probably want to start with the simple one and then expand it.\r\n\r\nIt's already clear from the comment that labels are optional, but it's not clear how to avoid using them (without staring for a long time). You could perhaps add comments along the lines of \"// Skip this if you're not using labels\".",
      "created_at": "2024-07-12T07:38:32Z",
      "updated_at": "2024-07-12T07:38:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675447695",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675447695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675452696",
      "pull_request_review_id": 2174088666,
      "id": 1675452696,
      "node_id": "PRRC_kwDOAP4Jqs5j3WEY",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 280,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670602364,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, it's already loaded.\r\n\r\n```c\r\n/* Load Bob's spend public key. We already loaded his scan (secret) key. */\r\n```",
      "created_at": "2024-07-12T07:43:07Z",
      "updated_at": "2024-07-12T07:43:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675452696",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675452696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675452763",
      "pull_request_review_id": 2174088750,
      "id": 1675452763,
      "node_id": "PRRC_kwDOAP4Jqs5j3WFb",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,",
      "path": "examples/silentpayments.c",
      "position": 224,
      "original_position": 201,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670519831,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yep, this was an issue we ran into before. There is now a test for exactly this mistake in the test vectors.",
      "created_at": "2024-07-12T07:43:10Z",
      "updated_at": "2024-07-12T07:43:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675452763",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675452763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 224,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675459644",
      "pull_request_review_id": 2174099940,
      "id": 1675459644,
      "node_id": "PRRC_kwDOAP4Jqs5j3Xw8",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": 297,
      "original_position": 265,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The term \"public data\" doesn't occur in the BIP. Even if you point to the section \"Creating outputs\" it's not obvious. But it might be better to clarify this in the BIP instead of in the demo. It could more clearly separate the derivation that needs only public data from the tweaks with the private key.",
      "created_at": "2024-07-12T07:49:32Z",
      "updated_at": "2024-07-12T07:50:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675459644",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675459644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 297,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675460730",
      "pull_request_review_id": 2174101556,
      "id": 1675460730,
      "node_id": "PRRC_kwDOAP4Jqs5j3YB6",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 175,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670529348,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> The problem with complicated examples in general is that they distract the reader into trying to understand what the example is about, rather than focus on how to code it.\r\n\r\nI don't think that is the case here. I'd prefer to keep the line in, considering it's about as complicated as the comment.",
      "created_at": "2024-07-12T07:50:27Z",
      "updated_at": "2024-07-12T07:50:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675460730",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675460730"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675466437",
      "pull_request_review_id": 2174110444,
      "id": 1675466437,
      "node_id": "PRRC_kwDOAP4Jqs5j3ZbF",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and used the labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key. Storing it this way saves 32 bytes for the light client because\n+             * now it can be send as a 33 byte compressed public key instead of 33 bytes for A_sum and 32 bytes for input_hash.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,",
      "path": "examples/silentpayments.c",
      "position": 384,
      "original_position": 318,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670608423,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T07:55:26Z",
      "updated_at": "2024-07-12T07:55:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675466437",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675466437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 384,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675467092",
      "pull_request_review_id": 2174111556,
      "id": 1675467092,
      "node_id": "PRRC_kwDOAP4Jqs5j3ZlU",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+         * every label he has previously used and uses a callback to check if a potential label exists\n+         * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+         * forgets how many labels he has previously used, he can pregenerate a large number of\n+         * labels (e.g. 0..100_000) and use that while scanning.\n+         */\n+        {\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;",
      "path": "examples/silentpayments.c",
      "position": 297,
      "original_position": 265,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670624345,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Updated the wording and added documentation for `smallest_outpoint`.",
      "created_at": "2024-07-12T07:56:02Z",
      "updated_at": "2024-07-12T07:56:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675467092",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675467092"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 297,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675471958",
      "pull_request_review_id": 2174119654,
      "id": 1675471958,
      "node_id": "PRRC_kwDOAP4Jqs5j3axW",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        /*** Scanning with labels as a full node (Bob) ***\n+         *\n+         * Since Bob has access to the full transaction, scanning is simple:\n+         *\n+         *     1. Collect the relevant data from the transaction inputs and call\n+         *        `secp256k1_silentpayments_recipient_public_data_create`\n+         *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+         *\n+         * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+         * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 256,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670599501,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd prefer to keep labels in the example since it shows usage of the `secp256k1_silentpayments_recipient_create_label_tweak` function. I added a comment near the top that makes it more clear that labels are optional and that the function can be called with `NULL, NULL` if not using labels. This comment is then reiterated in the scanning section with a comment at the call site of the scanning function.",
      "created_at": "2024-07-12T08:00:24Z",
      "updated_at": "2024-07-12T08:00:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675471958",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675471958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675483412",
      "pull_request_review_id": 2174137797,
      "id": 1675483412,
      "node_id": "PRRC_kwDOAP4Jqs5j3dkU",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &tx_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];",
      "path": "examples/silentpayments.c",
      "position": 274,
      "original_position": 236,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670590035,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This comment still feels like protocol exposition and doesn't add any information on how to use the API, which is what the example is aimed at, so I'd prefer to keep it as is.",
      "created_at": "2024-07-12T08:10:22Z",
      "updated_at": "2024-07-12T08:10:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675483412",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675483412"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 274,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675499986",
      "pull_request_review_id": 2174163192,
      "id": 1675499986,
      "node_id": "PRRC_kwDOAP4Jqs5j3hnS",
      "diff_hunk": "@@ -347,11 +348,244 @@ static void test_recipient_api(void) {\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, NULL));\n }\n \n+void run_silentpayments_test_vector_send(const struct bip352_test_vector *test) {\n+    secp256k1_silentpayments_recipient recipients[MAX_OUTPUTS_PER_TEST_CASE];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey generated_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_keypair taproot_keypairs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_keypair const *taproot_keypair_ptrs[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char const *plain_seckeys[MAX_INPUTS_PER_TEST_CASE];\n+    unsigned char created_output[32];\n+    size_t i, j, k;\n+    int match, ret;\n+\n+    /* Check that sender creates expected outputs */\n+    for (i = 0; i < test->num_outputs; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, test->recipient_pubkeys[i].scan_pubkey, 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey, test->recipient_pubkeys[i].spend_pubkey, 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    for (i = 0; i < test->num_plain_inputs; i++) {\n+        plain_seckeys[i] = test->plain_seckeys[i];\n+    }\n+    for (i = 0; i < test->num_taproot_inputs; i++) {\n+        CHECK(secp256k1_keypair_create(CTX, &taproot_keypairs[i], test->taproot_seckeys[i]));\n+        taproot_keypair_ptrs[i] = &taproot_keypairs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+                generated_output_ptrs,\n+                recipient_ptrs,\n+                test->num_outputs,\n+                test->outpoint_smallest,\n+                test->num_taproot_inputs > 0 ? taproot_keypair_ptrs : NULL, test->num_taproot_inputs,\n+                test->num_plain_inputs > 0 ? plain_seckeys : NULL, test->num_plain_inputs\n+    );\n+    /* If we are unable to create outputs, e.g., the input keys sum to zero, check that the\n+     * expected number of recipient outputs for this test case is zero\n+     */\n+    if (!ret) {\n+        CHECK(test->num_recipient_outputs == 0);\n+        return;\n+    }\n+\n+    match = 0;\n+    for (i = 0; i < test->num_output_sets; i++) {\n+        size_t n_matches = 0;\n+        for (j = 0; j < test->num_outputs; j++) {\n+            CHECK(secp256k1_xonly_pubkey_serialize(CTX, created_output, &generated_outputs[j]));\n+            /* Loop over both lists to ensure tests don't fail due to different orderings of outputs */\n+            for (k = 0; k < test->num_recipient_outputs; k++) {\n+                if (secp256k1_memcmp_var(created_output, test->recipient_outputs[i][k], 32) == 0) {\n+                    n_matches++;\n+                    break;\n+                }\n+            }\n+        }\n+        if (n_matches == test->num_recipient_outputs) {\n+            match = 1;\n+            break;\n+        }\n+    }\n+    CHECK(match);\n+}\n+\n+void run_silentpayments_test_vector_receive(const struct bip352_test_vector *test) {\n+    secp256k1_pubkey plain_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey xonly_pubkeys_objs[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey tx_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output found_output_objs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_pubkey const *plain_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *xonly_pubkeys[MAX_INPUTS_PER_TEST_CASE];\n+    secp256k1_xonly_pubkey const *tx_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    secp256k1_silentpayments_found_output *found_outputs[MAX_OUTPUTS_PER_TEST_CASE];\n+    unsigned char found_outputs_light_client[MAX_OUTPUTS_PER_TEST_CASE][32];\n+    secp256k1_pubkey recipient_scan_pubkey;\n+    secp256k1_pubkey recipient_spend_pubkey;\n+    size_t i,j;\n+    int match, ret;\n+    size_t n_found = 0;\n+    unsigned char found_output[32];\n+    unsigned char found_signatures[10][64];\n+    secp256k1_silentpayments_public_data public_data, public_data_index;\n+    unsigned char shared_secret_lightclient[33];\n+    unsigned char light_client_data[33];\n+\n+\n+    /* prepare the inputs */\n+    {\n+        for (i = 0; i < test->num_plain_inputs; i++) {\n+            CHECK(secp256k1_ec_pubkey_parse(CTX, &plain_pubkeys_objs[i], test->plain_pubkeys[i], 33));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 449,
      "original_position": 101,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "ef597945b2632862158a9477a74c1a525e92ffe9",
      "in_reply_to_id": 1670455581,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added.",
      "created_at": "2024-07-12T08:24:14Z",
      "updated_at": "2024-07-12T08:24:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675499986",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675499986"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 449,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675523065",
      "pull_request_review_id": 2174199522,
      "id": 1675523065,
      "node_id": "PRRC_kwDOAP4Jqs5j3nP5",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 230,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: s/Or/or (https://github.com/bitcoin-core/secp256k1/pull/1551/commits/fe4fbaa7f3eaa404f7ded669e611e28260839f9c)",
      "created_at": "2024-07-12T08:43:16Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675523065",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675523065"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675526075",
      "pull_request_review_id": 2174199522,
      "id": 1675526075,
      "node_id": "PRRC_kwDOAP4Jqs5j3n-7",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 25,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: We typically have spaces after the commas here.",
      "created_at": "2024-07-12T08:45:40Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675526075",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675526075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675543067",
      "pull_request_review_id": 2174199522,
      "id": 1675543067,
      "node_id": "PRRC_kwDOAP4Jqs5j3sIb",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+#!/usr/bin/env python3\n+import hashlib\n+import json\n+import sys\n+\n+import bech32m\n+import ripemd160\n+\n+NUMS_H = bytes.fromhex(\"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\")\n+MAX_INPUTS_PER_TEST_CASE = 3\n+MAX_OUTPUTS_PER_TEST_CASE = 4\n+MAX_PERMUTATIONS_PER_SENDING_TEST_CASE = 12\n+\n+def sha256(s):\n+    return hashlib.sha256(s).digest()\n+\n+def hash160(s):\n+    return ripemd160.ripemd160(sha256(s))\n+\n+def smallest_outpoint(outpoints):\n+    serialized_outpoints = [bytes.fromhex(txid)[::-1] + n.to_bytes(4, 'little') for txid, n in outpoints]\n+    return sorted(serialized_outpoints)[0]\n+\n+def decode_silent_payments_address(address):\n+    _, data = bech32m.decode(\"sp\", address)\n+    data = bytes(data)  # convert from list to bytes\n+    assert len(data) == 66\n+    return data[:33], data[33:]\n+\n+def is_p2tr(s):  # OP_1 OP_PUSHBYTES_32 <32 bytes>\n+    return (len(s) == 34) and (s[0] == 0x51) and (s[1] == 0x20)\n+\n+def is_p2wpkh(s):  # OP_0 OP_PUSHBYTES_20 <20 bytes>\n+    return (len(s) == 22) and (s[0] == 0x00) and (s[1] == 0x14)\n+\n+def is_p2sh(s):  # OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUAL\n+    return (len(s) == 23) and (s[0] == 0xA9) and (s[1] == 0x14) and (s[-1] == 0x87)\n+\n+def is_p2pkh(s):  # OP_DUP OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUALVERIFY OP_CHECKSIG\n+    return (len(s) == 25) and (s[0] == 0x76) and (s[1] == 0xA9) and (s[2] == 0x14) and \\\n+        (s[-2] == 0x88) and (s[-1] == 0xAC)\n+\n+def get_pubkey_from_input(spk, script_sig, witness):\n+    # build witness stack from raw witness data\n+    witness_stack = []\n+    no_witness_items = 0\n+    if len(witness) > 0:\n+        no_witness_items = witness[0]\n+        witness = witness[1:]\n+    for i in range(no_witness_items):\n+        item_len = witness[0]\n+        witness_stack.append(witness[1:item_len+1])\n+        witness = witness[item_len+1:]\n+\n+    if is_p2pkh(spk):\n+        spk_pkh = spk[3:3 + 20]\n+        for i in range(len(script_sig), 0, -1):\n+            if i - 33 >= 0:\n+                pk = script_sig[i - 33:i]\n+                if hash160(pk) == spk_pkh:\n+                    return pk\n+    elif is_p2sh(spk) and is_p2wpkh(script_sig[1:]):\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2wpkh(spk):\n+        # the witness must contain two items and the second item is the pubkey\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2tr(spk):\n+        if len(witness_stack) > 1 and witness_stack[-1][0] == 0x50:\n+            witness_stack.pop()\n+        if len(witness_stack) > 1:  # script-path spend?\n+            control_block = witness_stack[-1]\n+            internal_key = control_block[1:33]\n+            if internal_key == NUMS_H:  # skip\n+                return b''\n+        return spk[2:]\n+\n+    return b''\n+\n+def to_c_array(x):\n+    if x == \"\":\n+        return \"\"\n+    s = ',0x'.join(a+b for a,b in zip(x[::2], x[1::2]))\n+    return \"0x\" + s\n+\n+def emit_key_material(comment, keys, include_count=False):\n+    global out\n+    if include_count:\n+        out += f\"        {len(keys)},\" + \"\\n\"\n+    out += f\"        {{ /* {comment} */\" + \"\\n\"\n+    for i in range(MAX_INPUTS_PER_TEST_CASE):\n+        out += \"            \"\n+        if i < len(keys):\n+            out += \"{\"\n+            out += to_c_array(keys[i])\n+            out += \"}\"\n+        else:\n+            out += '\"\"'\n+        if i != MAX_INPUTS_PER_TEST_CASE - 1:\n+            out += ','",
      "path": "tools/tests_silentpayments_generate.py",
      "position": null,
      "original_position": 103,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0b6827182d29c2ca78085f0c435a87eeb9d59501",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Believe it or not, but C89 allows trailing commas here, so you don't need to check.",
      "created_at": "2024-07-12T08:55:24Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675543067",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675543067"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 102,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675549354",
      "pull_request_review_id": 2174199522,
      "id": 1675549354,
      "node_id": "PRRC_kwDOAP4Jqs5j3tqq",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 147,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: I think it will be good to limit the lines to 80 chars if possible/reasonable. (We have a rule about this in CONTRIBUTING.md for headers. I guess it should apply to examples, too.)",
      "created_at": "2024-07-12T09:00:42Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675549354",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675549354"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 146,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675550482",
      "pull_request_review_id": 2174199522,
      "id": 1675550482,
      "node_id": "PRRC_kwDOAP4Jqs5j3t8S",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 224,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: spacing",
      "created_at": "2024-07-12T09:01:43Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675550482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675550482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675553262",
      "pull_request_review_id": 2174199522,
      "id": 1675553262,
      "node_id": "PRRC_kwDOAP4Jqs5j3unu",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": 1581994645,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Really done? \r\n\r\nedit: Well, we should change the other examples and perhaps also the API docs. Creating keys in a while loop is not good practice. If you hit an invalid key, you're most probably not very lucky, but very unlucky because your randomness is broken. But hey, yeah, let's just yolo and try again. :)\r\n\r\nSo I guess either is fine for now: keep the loop for consistency with the other examples, or just return 1 here, but having a loop *and* the else branch is certainly a smell.  \r\n\r\n",
      "created_at": "2024-07-12T09:03:59Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675553262",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675553262"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675559211",
      "pull_request_review_id": 2174199522,
      "id": 1675559211,
      "node_id": "PRRC_kwDOAP4Jqs5j3wEr",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 182,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: s/bitcoin/BTC for consistency>",
      "created_at": "2024-07-12T09:09:14Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675559211",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675559211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675563261",
      "pull_request_review_id": 2174199522,
      "id": 1675563261,
      "node_id": "PRRC_kwDOAP4Jqs5j3xD9",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_TX_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL if scanning without labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &found_outputs[i].output);\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the transaction outputs. This\n+             * means she will need to first generate an output, check if it exists in the UTXO set (e.g.\n+             * BIP158 or some other means of querying) and only proceed to check the next output (by\n+             * incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the transaction inputs and prevout information,\n+             * so she uses the `public_data` object creatd by Bob's full node earlier. This serialized `public_data` object\n+             * contains everything she needs for generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of time but we are cheating here\n+             * to keep the example simple.\n+             */\n+            unsigned char ser_found_outputs[2][32];\n+            unsigned char shared_secret[33];\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_silentpayments_public_data public_data;\n+            size_t n_found_outputs;\n+\n+            /* Load Carol's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, carol_address[1], 33);\n+            assert(ret);\n+\n+            /* Scan one output at a time, using the serialized `public_data` created by Bob's full node */\n+            ret = secp256k1_silentpayments_recipient_public_data_parse(ctx, &public_data, light_client_data33);\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_create_shared_secret(ctx,\n+                shared_secret,\n+                carol_scan_key,\n+                &public_data\n+            );\n+            assert(ret);\n+            n_found_outputs = 0;\n+            {\n+                int found = 0;\n+                size_t k = 0;\n+                secp256k1_xonly_pubkey potential_output;\n+\n+                while(1) {\n+",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 390,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: add space after `while` and remove the empty line ",
      "created_at": "2024-07-12T09:12:32Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675563261",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675563261"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 389,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675565206",
      "pull_request_review_id": 2174199522,
      "id": 1675565206,
      "node_id": "PRRC_kwDOAP4Jqs5j3xiW",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 293,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do you think this could be simplified by working with the serializations of the pubkeys?",
      "created_at": "2024-07-12T09:14:17Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675565206",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675565206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 290,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675567599",
      "pull_request_review_id": 2174199522,
      "id": 1675567599,
      "node_id": "PRRC_kwDOAP4Jqs5j3yHv",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_TX_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL if scanning without labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &found_outputs[i].output);\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the transaction outputs. This\n+             * means she will need to first generate an output, check if it exists in the UTXO set (e.g.\n+             * BIP158 or some other means of querying) and only proceed to check the next output (by\n+             * incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the transaction inputs and prevout information,\n+             * so she uses the `public_data` object creatd by Bob's full node earlier. This serialized `public_data` object",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 358,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: created",
      "created_at": "2024-07-12T09:16:22Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675567599",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675567599"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 358,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675573384",
      "pull_request_review_id": 2174199522,
      "id": 1675573384,
      "node_id": "PRRC_kwDOAP4Jqs5j3ziI",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 2,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Our current recommendation is to skip all years and author info in new files (also in the C files), see the ellswift module for example. If there's no data, it cannot become wrong and outdated, and the git history anyway does a better job here. (And copyright notices are simply not required to obtain copyright.) But this is really just a recommendation, feel free to keep your name if you feel that attribution is a good idea.",
      "created_at": "2024-07-12T09:21:10Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675573384",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675573384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675577891",
      "pull_request_review_id": 2174199522,
      "id": 1675577891,
      "node_id": "PRRC_kwDOAP4Jqs5j30oj",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 312,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: \"vend\" is a word that I had to look up, which is a bit uncommon for me, even as a non-native speaker. Maybe you can find a more common word. Perhaps just \"provide\"?",
      "created_at": "2024-07-12T09:24:50Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675577891",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675577891"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675578061",
      "pull_request_review_id": 2174199522,
      "id": 1675578061,
      "node_id": "PRRC_kwDOAP4Jqs5j30rN",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 321,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/null/NULL",
      "created_at": "2024-07-12T09:24:59Z",
      "updated_at": "2024-07-12T09:25:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675578061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675578061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 321,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675579758",
      "pull_request_review_id": 2174287912,
      "id": 1675579758,
      "node_id": "PRRC_kwDOAP4Jqs5j31Fu",
      "diff_hunk": "@@ -63,6 +63,10 @@ static void help(int default_iters) {\n     printf(\"    ellswift_ecdh     : ECDH on ElligatorSwift keys\\n\");\n #endif\n \n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    printf(\"    silentpayments    : Silent payments recipient scanning\\n\");",
      "path": "src/bench.c",
      "position": 5,
      "original_position": 5,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not just scanning, right?",
      "created_at": "2024-07-12T09:26:24Z",
      "updated_at": "2024-07-12T09:26:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675579758",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675579758"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675748763",
      "pull_request_review_id": 2174566516,
      "id": 1675748763,
      "node_id": "PRRC_kwDOAP4Jqs5j4eWb",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 293,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675565206,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good question! Initially, I think I was worried going from `ge -> secp256k1_pubkey -> bytes` would add extra overhead during scanning, but since then I've discovered we can go from `ge -> bytes`. I also benchmarked using `secp256k1_pubkey` vs `unsigned char` for the label callback and there was no difference in scanning.\r\n\r\nI'd say this is preferable too because now the callback function doesn't need to be aware of `secp256k1_pubkey` and it's very likely the labels will be stored in the labels cache as bytes (which would mean in the previous version the callback function would need to do the serialization, anyways).",
      "created_at": "2024-07-12T12:03:06Z",
      "updated_at": "2024-07-12T12:03:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675748763",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675748763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 290,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675750550",
      "pull_request_review_id": 2174569515,
      "id": 1675750550,
      "node_id": "PRRC_kwDOAP4Jqs5j4eyW",
      "diff_hunk": "@@ -63,6 +63,10 @@ static void help(int default_iters) {\n     printf(\"    ellswift_ecdh     : ECDH on ElligatorSwift keys\\n\");\n #endif\n \n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    printf(\"    silentpayments    : Silent payments recipient scanning\\n\");",
      "path": "src/bench.c",
      "position": 5,
      "original_position": 5,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "in_reply_to_id": 1675579758,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Currently, I only have a benchmark for the scanning function (since that's the only function were performance is absolutely critical). Perhaps I can update this to `silentpayments_scanning` ? ",
      "created_at": "2024-07-12T12:04:57Z",
      "updated_at": "2024-07-12T12:04:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675750550",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675750550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675755647",
      "pull_request_review_id": 2174577664,
      "id": 1675755647,
      "node_id": "PRRC_kwDOAP4Jqs5j4gB_",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": 1581994645,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Whoops! I think I had a local commit for this but forgot to squash it in.\r\n\r\nRegarding best practices, creating the keys in a loop seemed excessive to me but figured I'd just copy the existing examples in case there was something I wasn't understanding.\r\n\r\nConsidering this is new code, seems fine to me to break from the other examples and then I can open a separate PR to clean up the examples/API docs.",
      "created_at": "2024-07-12T12:10:01Z",
      "updated_at": "2024-07-12T12:10:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675755647",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675755647"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675765972",
      "pull_request_review_id": 2174594552,
      "id": 1675765972,
      "node_id": "PRRC_kwDOAP4Jqs5j4ijU",
      "diff_hunk": "@@ -63,6 +63,10 @@ static void help(int default_iters) {\n     printf(\"    ellswift_ecdh     : ECDH on ElligatorSwift keys\\n\");\n #endif\n \n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    printf(\"    silentpayments    : Silent payments recipient scanning\\n\");",
      "path": "src/bench.c",
      "position": 5,
      "original_position": 5,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0c63b8b1911ef1183f411a5e232165b543c668ea",
      "in_reply_to_id": 1675579758,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I only have a benchmark for the scanning function\r\n\r\nAh, nevermind, I got this wrong.",
      "created_at": "2024-07-12T12:19:53Z",
      "updated_at": "2024-07-12T12:19:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675765972",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675765972"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675769443",
      "pull_request_review_id": 2174600420,
      "id": 1675769443,
      "node_id": "PRRC_kwDOAP4Jqs5j4jZj",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+\n+    /* This will fail if B_spend + t_k*G is the point at infinity */\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    /* TODO: any concerns here with multiplying a \"secret\" by a scalar here, i.e., input_hash * a_sum\n+     * Mostly concerned about cases where a_sum is a single key and leaking information about a_sum\n+     * since input_hash can be calculated by anyone\n+     */\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 209,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674851580,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is fine. The entire scalar module treats scalars as secrets (because they typically represent secret keys).",
      "created_at": "2024-07-12T12:23:21Z",
      "updated_at": "2024-07-12T12:23:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675769443",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675769443"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 209,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675985940",
      "pull_request_review_id": 2174997157,
      "id": 1675985940,
      "node_id": "PRRC_kwDOAP4Jqs5j5YQU",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 230,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675523065,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:08:54Z",
      "updated_at": "2024-07-12T14:08:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675985940",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675985940"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986081",
      "pull_request_review_id": 2174997382,
      "id": 1675986081,
      "node_id": "PRRC_kwDOAP4Jqs5j5YSh",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 25,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675526075,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:08:59Z",
      "updated_at": "2024-07-12T14:09:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675986081",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986081"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986582",
      "pull_request_review_id": 2174998300,
      "id": 1675986582,
      "node_id": "PRRC_kwDOAP4Jqs5j5YaW",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 147,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675549354,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:09:25Z",
      "updated_at": "2024-07-12T14:09:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675986582",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986582"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 146,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986806",
      "pull_request_review_id": 2174998701,
      "id": 1675986806,
      "node_id": "PRRC_kwDOAP4Jqs5j5Yd2",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 224,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675550482,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:09:36Z",
      "updated_at": "2024-07-12T14:09:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675986806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675986806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675987377",
      "pull_request_review_id": 2174999641,
      "id": 1675987377,
      "node_id": "PRRC_kwDOAP4Jqs5j5Ymx",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 182,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675559211,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:10:00Z",
      "updated_at": "2024-07-12T14:10:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675987377",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675987377"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675987860",
      "pull_request_review_id": 2175000479,
      "id": 1675987860,
      "node_id": "PRRC_kwDOAP4Jqs5j5YuU",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 293,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675565206,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Updated to use `unsigned char`, thanks for the suggestion!",
      "created_at": "2024-07-12T14:10:21Z",
      "updated_at": "2024-07-12T14:10:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675987860",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675987860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 290,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988045",
      "pull_request_review_id": 2175000724,
      "id": 1675988045,
      "node_id": "PRRC_kwDOAP4Jqs5j5YxN",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 2,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675573384,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:10:29Z",
      "updated_at": "2024-07-12T14:10:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675988045",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988045"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988188",
      "pull_request_review_id": 2175000958,
      "id": 1675988188,
      "node_id": "PRRC_kwDOAP4Jqs5j5Yzc",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 312,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675577891,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:10:36Z",
      "updated_at": "2024-07-12T14:10:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675988188",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988188"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988285",
      "pull_request_review_id": 2175001128,
      "id": 1675988285,
      "node_id": "PRRC_kwDOAP4Jqs5j5Y09",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 321,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675578061,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:10:42Z",
      "updated_at": "2024-07-12T14:10:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675988285",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988285"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 321,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988636",
      "pull_request_review_id": 2175001675,
      "id": 1675988636,
      "node_id": "PRRC_kwDOAP4Jqs5j5Y6c",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_TX_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL if scanning without labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &found_outputs[i].output);\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the transaction outputs. This\n+             * means she will need to first generate an output, check if it exists in the UTXO set (e.g.\n+             * BIP158 or some other means of querying) and only proceed to check the next output (by\n+             * incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the transaction inputs and prevout information,\n+             * so she uses the `public_data` object creatd by Bob's full node earlier. This serialized `public_data` object",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 358,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675567599,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:10:58Z",
      "updated_at": "2024-07-12T14:10:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675988636",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675988636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 358,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675989403",
      "pull_request_review_id": 2175002925,
      "id": 1675989403,
      "node_id": "PRRC_kwDOAP4Jqs5j5ZGb",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_TX_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL if scanning without labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &found_outputs[i].output);\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the transaction outputs. This\n+             * means she will need to first generate an output, check if it exists in the UTXO set (e.g.\n+             * BIP158 or some other means of querying) and only proceed to check the next output (by\n+             * incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the transaction inputs and prevout information,\n+             * so she uses the `public_data` object creatd by Bob's full node earlier. This serialized `public_data` object\n+             * contains everything she needs for generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of time but we are cheating here\n+             * to keep the example simple.\n+             */\n+            unsigned char ser_found_outputs[2][32];\n+            unsigned char shared_secret[33];\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_silentpayments_public_data public_data;\n+            size_t n_found_outputs;\n+\n+            /* Load Carol's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, carol_address[1], 33);\n+            assert(ret);\n+\n+            /* Scan one output at a time, using the serialized `public_data` created by Bob's full node */\n+            ret = secp256k1_silentpayments_recipient_public_data_parse(ctx, &public_data, light_client_data33);\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_create_shared_secret(ctx,\n+                shared_secret,\n+                carol_scan_key,\n+                &public_data\n+            );\n+            assert(ret);\n+            n_found_outputs = 0;\n+            {\n+                int found = 0;\n+                size_t k = 0;\n+                secp256k1_xonly_pubkey potential_output;\n+\n+                while(1) {\n+",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 390,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675563261,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Missed this but will address in the next round of review",
      "created_at": "2024-07-12T14:11:34Z",
      "updated_at": "2024-07-12T14:11:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675989403",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675989403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 389,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675990256",
      "pull_request_review_id": 2175004301,
      "id": 1675990256,
      "node_id": "PRRC_kwDOAP4Jqs5j5ZTw",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+#!/usr/bin/env python3\n+import hashlib\n+import json\n+import sys\n+\n+import bech32m\n+import ripemd160\n+\n+NUMS_H = bytes.fromhex(\"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\")\n+MAX_INPUTS_PER_TEST_CASE = 3\n+MAX_OUTPUTS_PER_TEST_CASE = 4\n+MAX_PERMUTATIONS_PER_SENDING_TEST_CASE = 12\n+\n+def sha256(s):\n+    return hashlib.sha256(s).digest()\n+\n+def hash160(s):\n+    return ripemd160.ripemd160(sha256(s))\n+\n+def smallest_outpoint(outpoints):\n+    serialized_outpoints = [bytes.fromhex(txid)[::-1] + n.to_bytes(4, 'little') for txid, n in outpoints]\n+    return sorted(serialized_outpoints)[0]\n+\n+def decode_silent_payments_address(address):\n+    _, data = bech32m.decode(\"sp\", address)\n+    data = bytes(data)  # convert from list to bytes\n+    assert len(data) == 66\n+    return data[:33], data[33:]\n+\n+def is_p2tr(s):  # OP_1 OP_PUSHBYTES_32 <32 bytes>\n+    return (len(s) == 34) and (s[0] == 0x51) and (s[1] == 0x20)\n+\n+def is_p2wpkh(s):  # OP_0 OP_PUSHBYTES_20 <20 bytes>\n+    return (len(s) == 22) and (s[0] == 0x00) and (s[1] == 0x14)\n+\n+def is_p2sh(s):  # OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUAL\n+    return (len(s) == 23) and (s[0] == 0xA9) and (s[1] == 0x14) and (s[-1] == 0x87)\n+\n+def is_p2pkh(s):  # OP_DUP OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUALVERIFY OP_CHECKSIG\n+    return (len(s) == 25) and (s[0] == 0x76) and (s[1] == 0xA9) and (s[2] == 0x14) and \\\n+        (s[-2] == 0x88) and (s[-1] == 0xAC)\n+\n+def get_pubkey_from_input(spk, script_sig, witness):\n+    # build witness stack from raw witness data\n+    witness_stack = []\n+    no_witness_items = 0\n+    if len(witness) > 0:\n+        no_witness_items = witness[0]\n+        witness = witness[1:]\n+    for i in range(no_witness_items):\n+        item_len = witness[0]\n+        witness_stack.append(witness[1:item_len+1])\n+        witness = witness[item_len+1:]\n+\n+    if is_p2pkh(spk):\n+        spk_pkh = spk[3:3 + 20]\n+        for i in range(len(script_sig), 0, -1):\n+            if i - 33 >= 0:\n+                pk = script_sig[i - 33:i]\n+                if hash160(pk) == spk_pkh:\n+                    return pk\n+    elif is_p2sh(spk) and is_p2wpkh(script_sig[1:]):\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2wpkh(spk):\n+        # the witness must contain two items and the second item is the pubkey\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2tr(spk):\n+        if len(witness_stack) > 1 and witness_stack[-1][0] == 0x50:\n+            witness_stack.pop()\n+        if len(witness_stack) > 1:  # script-path spend?\n+            control_block = witness_stack[-1]\n+            internal_key = control_block[1:33]\n+            if internal_key == NUMS_H:  # skip\n+                return b''\n+        return spk[2:]\n+\n+    return b''\n+\n+def to_c_array(x):\n+    if x == \"\":\n+        return \"\"\n+    s = ',0x'.join(a+b for a,b in zip(x[::2], x[1::2]))\n+    return \"0x\" + s\n+\n+def emit_key_material(comment, keys, include_count=False):\n+    global out\n+    if include_count:\n+        out += f\"        {len(keys)},\" + \"\\n\"\n+    out += f\"        {{ /* {comment} */\" + \"\\n\"\n+    for i in range(MAX_INPUTS_PER_TEST_CASE):\n+        out += \"            \"\n+        if i < len(keys):\n+            out += \"{\"\n+            out += to_c_array(keys[i])\n+            out += \"}\"\n+        else:\n+            out += '\"\"'\n+        if i != MAX_INPUTS_PER_TEST_CASE - 1:\n+            out += ','",
      "path": "tools/tests_silentpayments_generate.py",
      "position": null,
      "original_position": 103,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0b6827182d29c2ca78085f0c435a87eeb9d59501",
      "in_reply_to_id": 1675543067,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A rare instance where C89 is not evil :laughing: , will fix in the next round of review.",
      "created_at": "2024-07-12T14:12:13Z",
      "updated_at": "2024-07-12T14:12:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675990256",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675990256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 102,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675990671",
      "pull_request_review_id": 2175004870,
      "id": 1675990671,
      "node_id": "PRRC_kwDOAP4Jqs5j5ZaP",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 104,
      "original_position": 97,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674861098,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:12:29Z",
      "updated_at": "2024-07-12T14:12:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675990671",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675990671"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 104,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992250",
      "pull_request_review_id": 2175007435,
      "id": 1675992250,
      "node_id": "PRRC_kwDOAP4Jqs5j5Zy6",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    return ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);\n+\n+    /* This will fail if B_spend + t_k*G is the point at infinity */\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        /* TODO: in other places where _set_b32_seckey is called, its normally followed by a _cmov call\n+         * Do we need that here and if so, is it better to call it after the loop is finished?\n+         */\n+        ret &= secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        /* TODO: why don't we need _cmov here after calling keypair_load? Because the ret is declassified? */\n+        ret &= secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    if (!ret || secp256k1_scalar_is_zero(&a_sum_scalar)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    ret &= !overflow;\n+    /* TODO: any concerns here with multiplying a \"secret\" by a scalar here, i.e., input_hash * a_sum\n+     * Mostly concerned about cases where a_sum is a single key and leaking information about a_sum\n+     * since input_hash can be calculated by anyone\n+     */\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 209,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674851580,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Removed the comment. I left a few of the other TODO comments in regarding `_cmov` and loading unsigned char secret keys into scalars because that's something I'd appreciate some eyes on / feedback.",
      "created_at": "2024-07-12T14:13:39Z",
      "updated_at": "2024-07-12T14:13:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675992250",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992250"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 209,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992709",
      "pull_request_review_id": 2175008151,
      "id": 1675992709,
      "node_id": "PRRC_kwDOAP4Jqs5j5Z6F",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;\n+    int ret = 1;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 76,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674831667,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Updated, good call!",
      "created_at": "2024-07-12T14:14:01Z",
      "updated_at": "2024-07-12T14:14:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675992709",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992709"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992928",
      "pull_request_review_id": 2175008675,
      "id": 1675992928,
      "node_id": "PRRC_kwDOAP4Jqs5j5Z9g",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t ser_size;\n+    int ser_ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ser_ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &ser_size, 1);\n+    VERIFY_CHECK(ser_ret && ser_size == sizeof(pubkey_sum_ser));\n+    (void)ser_ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static int secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len = 33;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 68,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674829069,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-12T14:14:11Z",
      "updated_at": "2024-07-12T14:14:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675992928",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675992928"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675993175",
      "pull_request_review_id": 2175009158,
      "id": 1675993175,
      "node_id": "PRRC_kwDOAP4Jqs5j5aBX",
      "diff_hunk": "@@ -7,10 +7,233 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static int secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 18,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "605096d3f465a384e9ff5553822d3b06c8c5ddb5",
      "in_reply_to_id": 1674828546,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nice, fixed.",
      "created_at": "2024-07-12T14:14:24Z",
      "updated_at": "2024-07-12T14:14:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675993175",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675993175"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675995871",
      "pull_request_review_id": 2175013713,
      "id": 1675995871,
      "node_id": "PRRC_kwDOAP4Jqs5j5arf",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": 1581994645,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "_Actually_ fixed this time to take out the while loop and return if it fails to create the key. ",
      "created_at": "2024-07-12T14:16:28Z",
      "updated_at": "2024-07-12T14:16:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675995871",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1675995871"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676103693",
      "pull_request_review_id": 2175186854,
      "id": 1676103693,
      "node_id": "PRRC_kwDOAP4Jqs5j51AN",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 167,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "6704738b690c2e07e96ef6f5a4266bd617701e02",
      "in_reply_to_id": 1581994645,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "see https://github.com/bitcoin-core/secp256k1/pull/1570",
      "created_at": "2024-07-12T15:26:28Z",
      "updated_at": "2024-07-12T15:27:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1676103693",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676103693"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 164,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676183139",
      "pull_request_review_id": 2175311571,
      "id": 1676183139,
      "node_id": "PRRC_kwDOAP4Jqs5j6IZj",
      "diff_hunk": "@@ -157,6 +157,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data is can be used for scanning on the recipient side, or",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 36,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  The resulting data can be used for scanning on the recipient side, or\r\n```",
      "created_at": "2024-07-12T16:37:37Z",
      "updated_at": "2024-07-12T17:14:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1676183139",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676183139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676186434",
      "pull_request_review_id": 2175311571,
      "id": 1676186434,
      "node_id": "PRRC_kwDOAP4Jqs5j6JNC",
      "diff_hunk": "@@ -157,6 +157,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data is can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belong to",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 139,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  B_spend, and the relevant transaction outputs, scan for outputs belonging to\r\n```",
      "created_at": "2024-07-12T16:40:53Z",
      "updated_at": "2024-07-12T17:14:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1676186434",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676186434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676211210",
      "pull_request_review_id": 2175311571,
      "id": 1676211210,
      "node_id": "PRRC_kwDOAP4Jqs5j6PQK",
      "diff_hunk": "@@ -300,4 +300,304 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 60,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could use internal function `_eckey_pubkey_serialize` instead, which accepts a group element, so the pubkey object `A_sum` is not needed anymore (verified that the tests still pass):\r\n```diff\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\nindex a1d4e15..840c9b0 100644\r\n--- a/src/modules/silentpayments/main_impl.h\r\n+++ b/src/modules/silentpayments/main_impl.h\r\n@@ -311,7 +311,6 @@ int secp256k1_silentpayments_recipient_public_data_create(\r\n ) {\r\n     size_t i;\r\n     size_t pubkeylen = 65;\r\n-    secp256k1_pubkey A_sum;\r\n     secp256k1_ge A_sum_ge, addend;\r\n     secp256k1_gej A_sum_gej;\r\n     unsigned char input_hash_local[32];\r\n@@ -353,10 +352,9 @@ int secp256k1_silentpayments_recipient_public_data_create(\r\n     /* Compute input_hash = hash(outpoint_L || A_sum) */\r\n     secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\r\n     secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\r\n-    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\r\n     /* serialize the public_data struct */\r\n     public_data->data[0] = 0;\r\n-    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);\r\n+    secp256k1_eckey_pubkey_serialize(&A_sum_ge, &public_data->data[1], &pubkeylen, 0);\r\n     memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\r\n     return ret;\r\n }\r\n```\r\nMaybe there are other places as well where internal functions can be used to need less variables/code.",
      "created_at": "2024-07-12T17:05:26Z",
      "updated_at": "2024-07-12T17:14:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1676211210",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676211210"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676215290",
      "pull_request_review_id": 2175311571,
      "id": 1676215290,
      "node_id": "PRRC_kwDOAP4Jqs5j6QP6",
      "diff_hunk": "@@ -300,4 +300,304 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    /* If there is something wrong with the recipient scan key or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        /* TODO: any concerns with leaking the scan key when multiplying by a publicly known scalar? */\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 166,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "seems like this TODO can be removed as well (see https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1675769443).",
      "created_at": "2024-07-12T17:08:07Z",
      "updated_at": "2024-07-12T17:14:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1676215290",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1676215290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 464,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 462,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115169",
      "pull_request_review_id": 2176634470,
      "id": 1677115169,
      "node_id": "PRRC_kwDOAP4Jqs5j9r8h",
      "diff_hunk": "@@ -300,4 +300,304 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);\n+    memcpy(&public_data->data[1 + pubkeylen], input_hash_local, 32);\n+    return ret;\n+}\n+\n+static int secp256k1_silentpayments_recipient_public_data_load_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    return secp256k1_ec_pubkey_parse(ctx, pubkey, &public_data->data[1], pubkeylen);\n+}\n+\n+static void secp256k1_silentpayments_recipient_public_data_load_input_hash(unsigned char *input_hash, const secp256k1_silentpayments_public_data *public_data) {\n+    size_t pubkeylen = 65;\n+    memcpy(input_hash, &public_data->data[1 + pubkeylen], 32);\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_public_data *public_data) {\n+    secp256k1_pubkey pubkey;\n+    unsigned char input_hash[32];\n+    size_t pubkeylen = 33;\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serialiazing just a the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[0] == 0);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &pubkey, public_data);\n+    secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+    ret &= secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, input_hash);\n+    secp256k1_ec_pubkey_serialize(ctx, output33, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey pubkey;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_ec_pubkey_parse(ctx, &pubkey, input33, inputlen)) {\n+        return 0;\n+    }\n+    public_data->data[0] = 1;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n+    memset(&public_data->data[1 + pubkeylen], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key,\n+    const secp256k1_silentpayments_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    if (label_lookup != NULL) {\n+        ARG_CHECK(label_context != NULL);\n+    } else {\n+        ARG_CHECK(label_context == NULL);\n+    }\n+    /* TODO: do we need a _cmov call here to avoid leaking information about the scan key?\n+     * Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy\n+     * In this respect, a scan key is functionally equivalent to an xpub\n+     */\n+    ret &= secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key);\n+    ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_sum, public_data);\n+    /* If there is something wrong with the recipient scan key or the public data, return early */\n+    if (!ret) {\n+        return 0;\n+    }\n+    combined = (int)public_data->data[0];\n+    if (!combined) {\n+        unsigned char input_hash[32];\n+        secp256k1_scalar input_hash_scalar;\n+        int overflow = 0;\n+\n+        secp256k1_silentpayments_recipient_public_data_load_input_hash(input_hash, public_data);\n+        secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+        /* TODO: any concerns with leaking the scan key when multiplying by a publicly known scalar? */\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 166,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": 1676215290,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-14T11:33:42Z",
      "updated_at": "2024-07-14T11:33:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677115169",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 464,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 462,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115270",
      "pull_request_review_id": 2176634593,
      "id": 1677115270,
      "node_id": "PRRC_kwDOAP4Jqs5j9r-G",
      "diff_hunk": "@@ -300,4 +300,304 @@ int secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(const secp25\n     return 1;\n }\n \n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 65;\n+    secp256k1_pubkey A_sum;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash_local[32];\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+    memset(input_hash_local, 0, 32);\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     */\n+    if (secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_pubkey_save(&A_sum, &A_sum_ge);\n+    /* serialize the public_data struct */\n+    public_data->data[0] = 0;\n+    secp256k1_ec_pubkey_serialize(ctx, &public_data->data[1], &pubkeylen, &A_sum, SECP256K1_EC_UNCOMPRESSED);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 60,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": 1676211210,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch! Fixed.",
      "created_at": "2024-07-14T11:34:18Z",
      "updated_at": "2024-07-14T11:34:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677115270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115309",
      "pull_request_review_id": 2176634645,
      "id": 1677115309,
      "node_id": "PRRC_kwDOAP4Jqs5j9r-t",
      "diff_hunk": "@@ -157,6 +157,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data is can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g. wallet rescanning, vending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_public_data_serialize`.\n+ *\n+ *  Returns: 1 if tweak data creation was successful. 0 if an error occured.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_public_data\n+ *                     object\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silent_payments_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed. \n+ *           0 if the sequence is invalid (e.g. does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label value to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labelled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a input public sum, an input_hash, a recipient's spend public key\n+ *  B_spend, and the relevant transaction outputs, scan for outputs belong to",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 139,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": 1676186434,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-14T11:34:35Z",
      "updated_at": "2024-07-14T11:34:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677115309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115328",
      "pull_request_review_id": 2176634679,
      "id": 1677115328,
      "node_id": "PRRC_kwDOAP4Jqs5j9r_A",
      "diff_hunk": "@@ -157,6 +157,247 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 98 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_public_data_parse`.\n+ */\n+typedef struct {\n+    unsigned char data[98];\n+} secp256k1_silentpayments_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ * inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data is can be used for scanning on the recipient side, or",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 36,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0910032d92e839091c2a8ca713f35fa0af067ce0",
      "in_reply_to_id": 1676183139,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-14T11:34:45Z",
      "updated_at": "2024-07-14T11:34:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677115328",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115351",
      "pull_request_review_id": 2176634718,
      "id": 1677115351,
      "node_id": "PRRC_kwDOAP4Jqs5j9r_X",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+#!/usr/bin/env python3\n+import hashlib\n+import json\n+import sys\n+\n+import bech32m\n+import ripemd160\n+\n+NUMS_H = bytes.fromhex(\"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\")\n+MAX_INPUTS_PER_TEST_CASE = 3\n+MAX_OUTPUTS_PER_TEST_CASE = 4\n+MAX_PERMUTATIONS_PER_SENDING_TEST_CASE = 12\n+\n+def sha256(s):\n+    return hashlib.sha256(s).digest()\n+\n+def hash160(s):\n+    return ripemd160.ripemd160(sha256(s))\n+\n+def smallest_outpoint(outpoints):\n+    serialized_outpoints = [bytes.fromhex(txid)[::-1] + n.to_bytes(4, 'little') for txid, n in outpoints]\n+    return sorted(serialized_outpoints)[0]\n+\n+def decode_silent_payments_address(address):\n+    _, data = bech32m.decode(\"sp\", address)\n+    data = bytes(data)  # convert from list to bytes\n+    assert len(data) == 66\n+    return data[:33], data[33:]\n+\n+def is_p2tr(s):  # OP_1 OP_PUSHBYTES_32 <32 bytes>\n+    return (len(s) == 34) and (s[0] == 0x51) and (s[1] == 0x20)\n+\n+def is_p2wpkh(s):  # OP_0 OP_PUSHBYTES_20 <20 bytes>\n+    return (len(s) == 22) and (s[0] == 0x00) and (s[1] == 0x14)\n+\n+def is_p2sh(s):  # OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUAL\n+    return (len(s) == 23) and (s[0] == 0xA9) and (s[1] == 0x14) and (s[-1] == 0x87)\n+\n+def is_p2pkh(s):  # OP_DUP OP_HASH160 OP_PUSHBYTES_20 <20 bytes> OP_EQUALVERIFY OP_CHECKSIG\n+    return (len(s) == 25) and (s[0] == 0x76) and (s[1] == 0xA9) and (s[2] == 0x14) and \\\n+        (s[-2] == 0x88) and (s[-1] == 0xAC)\n+\n+def get_pubkey_from_input(spk, script_sig, witness):\n+    # build witness stack from raw witness data\n+    witness_stack = []\n+    no_witness_items = 0\n+    if len(witness) > 0:\n+        no_witness_items = witness[0]\n+        witness = witness[1:]\n+    for i in range(no_witness_items):\n+        item_len = witness[0]\n+        witness_stack.append(witness[1:item_len+1])\n+        witness = witness[item_len+1:]\n+\n+    if is_p2pkh(spk):\n+        spk_pkh = spk[3:3 + 20]\n+        for i in range(len(script_sig), 0, -1):\n+            if i - 33 >= 0:\n+                pk = script_sig[i - 33:i]\n+                if hash160(pk) == spk_pkh:\n+                    return pk\n+    elif is_p2sh(spk) and is_p2wpkh(script_sig[1:]):\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2wpkh(spk):\n+        # the witness must contain two items and the second item is the pubkey\n+        pubkey = witness_stack[-1]\n+        if len(pubkey) == 33:\n+            return pubkey\n+    elif is_p2tr(spk):\n+        if len(witness_stack) > 1 and witness_stack[-1][0] == 0x50:\n+            witness_stack.pop()\n+        if len(witness_stack) > 1:  # script-path spend?\n+            control_block = witness_stack[-1]\n+            internal_key = control_block[1:33]\n+            if internal_key == NUMS_H:  # skip\n+                return b''\n+        return spk[2:]\n+\n+    return b''\n+\n+def to_c_array(x):\n+    if x == \"\":\n+        return \"\"\n+    s = ',0x'.join(a+b for a,b in zip(x[::2], x[1::2]))\n+    return \"0x\" + s\n+\n+def emit_key_material(comment, keys, include_count=False):\n+    global out\n+    if include_count:\n+        out += f\"        {len(keys)},\" + \"\\n\"\n+    out += f\"        {{ /* {comment} */\" + \"\\n\"\n+    for i in range(MAX_INPUTS_PER_TEST_CASE):\n+        out += \"            \"\n+        if i < len(keys):\n+            out += \"{\"\n+            out += to_c_array(keys[i])\n+            out += \"}\"\n+        else:\n+            out += '\"\"'\n+        if i != MAX_INPUTS_PER_TEST_CASE - 1:\n+            out += ','",
      "path": "tools/tests_silentpayments_generate.py",
      "position": null,
      "original_position": 103,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "0b6827182d29c2ca78085f0c435a87eeb9d59501",
      "in_reply_to_id": 1675543067,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-14T11:35:00Z",
      "updated_at": "2024-07-14T11:35:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677115351",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677115351"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 102,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677116688",
      "pull_request_review_id": 2176635998,
      "id": 1677116688,
      "node_id": "PRRC_kwDOAP4Jqs5j9sUQ",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,",
      "path": "examples/silentpayments.c",
      "position": 223,
      "original_position": 200,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670566910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You would never include non-silent payment outputs when calling this module. These functions are not for general transaction construction and only for the silent payments specific logic needed during transaction construction.\r\n",
      "created_at": "2024-07-14T11:41:47Z",
      "updated_at": "2024-07-14T11:41:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677116688",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677116688"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677116792",
      "pull_request_review_id": 2176636098,
      "id": 1677116792,
      "node_id": "PRRC_kwDOAP4Jqs5j9sV4",
      "diff_hunk": "@@ -0,0 +1,432 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration of how\n+ *  the label lookup callback is meant to query a label cache and return the label\n+ *  tweak when a match is found. This is for demonstration purposes only and not optimized.\n+ *  In a production usecase, it is expected that the caller will be using a much more performant\n+ *  method for storing and querying labels.\n+ *\n+ *  Recipients not using labels can ignore this and simply pass `NULL` for the label_lookup\n+ *  and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extract from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 bitcoin)\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the original ordering (the ordering\n+             * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+             * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &generated_outputs[i]);\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The `tx_outputs` array is used\n+         * to represent the final transaction, which is what Bob and Carol would use for scanning.\n+         */\n+        for(i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using them.\n+         * This is done because some bugs can allow an attacker to leak memory, for\n+         * example through \"out of bounds\" array access (see Heartbleed), Or the OS\n+         * swapping them to disk. Hence, we overwrite the secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any good compiler\n+         * will remove any writes that aren't used. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        /*** Transaction data ***\n+         *\n+         * Here we create a few global variables to represent the transaction data:\n+         *\n+         *     1. The transaction inputs, `tx_input_ptrs`\n+         *     2. The transaction outputs, `tx_output_ptrs`\n+         *\n+         * These will be used to demonstrate scanning as a full node and scanning as a light client.\n+         */\n+        const secp256k1_xonly_pubkey *tx_input_ptrs[N_TX_INPUTS];\n+        const secp256k1_xonly_pubkey *tx_output_ptrs[N_TX_OUTPUTS];\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning with labels as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction inputs and call\n+             *        `secp256k1_silentpayments_recipient_public_data_create`\n+             *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\n+             *\n+             * Additionally, since Bob has access to the full transaction outputs when scanning its easy for him\n+             * to scan with labels, as demonstrated below. For efficient scanning, Bob keeps a cache of\n+             * every label he has previously used and uses a callback to check if a potential label exists\n+             * in his cache. Since the labels are created using an incremental integer `m`, if Bob ever\n+             * forgets how many labels he has previously used, he can pregenerate a large number of\n+             * labels e.g., 0..100_000.\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_TX_OUTPUTS];\n+            secp256k1_silentpayments_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            size_t n_found_outputs;\n+            unsigned int m = 1;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_TX_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+\n+            /* In this contrived example, our label context needs the secp256k1 context because our lookup function\n+             * is calling `secp256k1_ec_pubkey_cmp`. In practice, this context can be anything the lookup function needs.\n+             */\n+            labels_cache.ctx = ctx;\n+\n+            /* Load Bob's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, bob_spend_pubkey, 33);\n+\n+            /* Add an entry to the cache. This implies Bob has previously called `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey`\n+             * and is using the resulting labelled spend pubkey to encode a labelled silent payments address.\n+             */\n+            ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx,\n+                &labels_cache.entries[0].label,\n+                labels_cache.entries[0].label_tweak,\n+                bob_scan_key,\n+                m\n+            );\n+            assert(ret);\n+            labels_cache.entries_used = 1;\n+\n+            /* Bob collects the public data from the transaction inputs and creates a `secp256k1_silentpayments_public_data` object.\n+             * He uses this for his own scanning and also serializes the `public_data` object to send to light clients. We will\n+             * use this later for Carol, who is scanning as a light client. Note, anyone can create and vend these `public_data`\n+             * objecs, i.e. you don't need to be a silent payments wallet, just someone interested in vending this data to light\n+             * clients, e.g. a wallet service provider. In our example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_TX_INPUTS,\n+                NULL, 0 /* null because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            assert(ret);\n+            /* Save the `public_data` output. This combines the `input_hash` scalar and public key sum by multiplying `input_hash * A_sum`.\n+             * The output is then saved as a 33 byte compressed key.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx, light_client_data33, &public_data);\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                tx_output_ptrs, N_TX_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL if scanning without labels */\n+            );\n+            assert(n_found_outputs == 1);\n+            printf(\"\\n\");\n+            printf(\"Bob found the following outputs: \\n\");\n+            for (i = 0; i < n_found_outputs; i++) {\n+                printf(\"    \");\n+                secp256k1_xonly_pubkey_serialize(ctx, xonly_print, &found_outputs[i].output);\n+                print_hex(xonly_print, sizeof(xonly_print));\n+            }\n+        }\n+        {\n+            /*** Scanning as a light client (Carol) ***\n+             *\n+             * Being a light client, Carol likely does not have access to the transaction outputs. This\n+             * means she will need to first generate an output, check if it exists in the UTXO set (e.g.\n+             * BIP158 or some other means of querying) and only proceed to check the next output (by\n+             * incrementing `k`) if the first output exists.\n+             *\n+             * Additionally, Carol likely does not have access to the transaction inputs and prevout information,\n+             * so she uses the `public_data` object creatd by Bob's full node earlier. This serialized `public_data` object\n+             * contains everything she needs for generating the shared secret, i.e., `input_hash * A_sum`.\n+             *\n+             * In practice, Carol wouldn't know the number of outputs ahead of time but we are cheating here\n+             * to keep the example simple.\n+             */\n+            unsigned char ser_found_outputs[2][32];\n+            unsigned char shared_secret[33];\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_silentpayments_public_data public_data;\n+            size_t n_found_outputs;\n+\n+            /* Load Carol's spend public key */\n+            ret = secp256k1_ec_pubkey_parse(ctx, &spend_pubkey, carol_address[1], 33);\n+            assert(ret);\n+\n+            /* Scan one output at a time, using the serialized `public_data` created by Bob's full node */\n+            ret = secp256k1_silentpayments_recipient_public_data_parse(ctx, &public_data, light_client_data33);\n+            assert(ret);\n+            ret = secp256k1_silentpayments_recipient_create_shared_secret(ctx,\n+                shared_secret,\n+                carol_scan_key,\n+                &public_data\n+            );\n+            assert(ret);\n+            n_found_outputs = 0;\n+            {\n+                int found = 0;\n+                size_t k = 0;\n+                secp256k1_xonly_pubkey potential_output;\n+\n+                while(1) {\n+",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 390,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "816796300acc425003c6dec7015c1b9812137da9",
      "in_reply_to_id": 1675563261,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-14T11:42:25Z",
      "updated_at": "2024-07-14T11:42:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677116792",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677116792"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": 389,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677117635",
      "pull_request_review_id": 2176636938,
      "id": 1677117635,
      "node_id": "PRRC_kwDOAP4Jqs5j9sjD",
      "diff_hunk": "@@ -0,0 +1,417 @@\n+/*************************************************************************\n+ * Written in 2024 by josibake                                           *\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses.\n+ * This consists of a scan key for each and the addresse data for each\n+ */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+    0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+    0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+    0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+    0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+    0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+    0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04,0xb2,0xa4,0x11,0x63,0x5c,0x09,0x77,\n+    0x59,0xaa,0xcd,0x0f,0x00,0x5a,0x4c,0x82,\n+    0xc8,0xc9,0x28,0x62,0xc6,0xfc,0x28,0x4b,\n+    0x80,0xb8,0xef,0xeb,0xc2,0x0c,0x3d,0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+\n+/* Labels\n+ * The structs and call back function are for demonstration only and not optimized.\n+ * In a production usecase, it is expected that the caller will be using a much more performant\n+ * method for storing and querying labels.\n+ */\n+\n+struct label_cache_entry {\n+    secp256k1_pubkey label;\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    const secp256k1_context *ctx;\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(const secp256k1_pubkey* key, const void* cache_ptr) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_ec_pubkey_cmp(cache->ctx, &cache->entries[i].label, key) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+    /* Before we can call actual API functions, we need to create a \"context\". */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be called with\n+         * a mix of taproot seckeys and plain seckeys. Taproot seckeys are passed as keypairs\n+         * to allow the sending function to check if the private keys need to be negated without needing\n+         * to do an expensive pubkey generation. This is not needed for plain seckeys since there is no need\n+         * for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs` array. This array will be used\n+         * later in the example to represent the public keys the recipient will extracte from the\n+         * transaction inputs.\n+         */\n+\n+        for (i = 0; i < 2; i++) {\n+            /* If the secret key is zero or out of range (bigger than secp256k1's\n+             * order), we try to sample a new key. Note that the probability of this\n+             * happening is negligible. */\n+            while (1) {\n+                unsigned char seckey[32];\n+                if (!fill_random(seckey, sizeof(seckey))) {\n+                    printf(\"Failed to generate randomness\\n\");\n+                    return 1;\n+                }\n+                /* Try to create a keypair with a valid context, it should only fail if\n+                 * the secret key is zero or out of range. */\n+                if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                    sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                    ret = secp256k1_keypair_xonly_pub(ctx, &tx_inputs[i], NULL, &sender_seckeys[i]);\n+                    assert(ret);\n+                    break;\n+                } else {\n+                    printf(\"Failed to create keypair\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address\n+         *     2. Two outputs for Carol (1.0 and 3.0 bitcoin)\n+         *\n+         * Alice creates the recipient objects and adds the index of the original ordering (i.e. the ordering\n+         * of the `sp_addresses` array) to each object. This index is used to return the generated outputs in\n+         * the original ordering so that Alice can match up the generated outputs with the correct amounts.\n+         *\n+         * Note: to create multiple outputs for Carol, Alice simply passes her silent payment\n+         * address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].scan_pubkey, (*(sp_addresses[i]))[0], 33);\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx, &recipients[i].spend_pubkey, (*(sp_addresses[i]))[1], 33);\n+            assert(ret);\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,",
      "path": "examples/silentpayments.c",
      "position": 223,
      "original_position": 200,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "c71791c629ec88e2e253aae4157d7113b60bee60",
      "in_reply_to_id": 1670566910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps the confusion is coming from the fact these variables are named `N_TX_INPUTS` and `N_TX_OUTPUTS` ? Considering this example is \"hardcoded\" to a set number of inputs and outputs, might as well just use numbers here instead of variables. I'll update this if I end up touching the example again.",
      "created_at": "2024-07-14T11:47:23Z",
      "updated_at": "2024-07-14T11:47:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1677117635",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1677117635"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1678634760",
      "pull_request_review_id": 2179013693,
      "id": 1678634760,
      "node_id": "PRRC_kwDOAP4Jqs5kDe8I",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1.h>\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+#include \"src/util.h\"\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0xee, 0x97, 0xdf, 0x83, 0xb2, 0x54, 0x6a,\n+    0xf5, 0xa7, 0xd0, 0x62, 0x15, 0xd9, 0x8b, 0xcb,\n+    0x63, 0x7f, 0xe0, 0x5d, 0xd0, 0xfa, 0x37, 0x3b,\n+    0xd8, 0x20, 0xe6, 0x64, 0xd3, 0x72, 0xde, 0x9a, 0x01\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11, 0x8d\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (secp256k1_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_TX_INPUTS = 2, N_TX_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char xonly_print[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_TX_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_TX_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_seckeys[N_TX_INPUTS];\n+        const secp256k1_keypair *sender_seckey_ptrs[N_TX_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_TX_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey generated_outputs[N_TX_OUTPUTS];\n+        secp256k1_xonly_pubkey *generated_output_ptrs[N_TX_OUTPUTS];\n+        char* address_amounts[N_TX_OUTPUTS] = {\"1.0 BTC\", \"2.0 BTC\", \"3.0 BTC\"};\n+        unsigned char (*sp_addresses[N_TX_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return 1;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_seckeys[i], seckey)) {\n+                sender_seckey_ptrs[i] = &sender_seckeys[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_seckeys[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return 1;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labelled address (2.0 BTC)\n+         *     2. Two outputs for Carol (1.0 and 3.0 BTC)\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address; /* : 1.0 BTC */\n+        sp_addresses[1] = &bob_address;   /* : 2.0 BTC */\n+        sp_addresses[2] = &carol_address; /* : 3.0 BTC */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) { ret =\n+            secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            assert(ret);\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            assert(ret);\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            generated_output_ptrs[i] = &generated_outputs[i];\n+        }\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            generated_output_ptrs,\n+            recipient_ptrs, N_TX_OUTPUTS,\n+            smallest_outpoint,\n+            sender_seckey_ptrs, N_TX_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            printf(\"    \");\n+            printf(\"%s : \", address_amounts[i]);\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                xonly_print,\n+                &generated_outputs[i]\n+            );\n+            print_hex(xonly_print, sizeof(xonly_print));\n+        }\n+        /* Store the generated outputs in the `tx_outputs` array. The\n+         * `tx_outputs` array is used to represent the final transaction, which\n+         * is what Bob and Carol would use for scanning.\n+         */\n+        for (i = 0; i < N_TX_OUTPUTS; i++) {\n+            tx_outputs[i] = generated_outputs[i];\n+        }\n+\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_TX_INPUTS; i++) {\n+            secure_erase(&sender_seckeys[i], sizeof(sender_seckeys[i]));\n+        }\n+    }\n+",
      "path": "examples/silentpayments.c",
      "position": 260,
      "original_position": 260,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "in_reply_to_id": null,
      "user": {
        "login": "jlest01",
        "id": 174762002,
        "node_id": "U_kgDOCmqoEg",
        "avatar_url": "https://avatars.githubusercontent.com/u/174762002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jlest01",
        "html_url": "https://github.com/jlest01",
        "followers_url": "https://api.github.com/users/jlest01/followers",
        "following_url": "https://api.github.com/users/jlest01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jlest01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jlest01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jlest01/subscriptions",
        "organizations_url": "https://api.github.com/users/jlest01/orgs",
        "repos_url": "https://api.github.com/users/jlest01/repos",
        "events_url": "https://api.github.com/users/jlest01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jlest01/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The example file can also show how to use the `secp256k1_silentpayments_recipient_create_labelled_spend_pubkey` function.\r\nHere is a suggestion.\r\n\r\n```suggestion\r\n{\r\n        /*** Label ***/\r\n\r\n        unsigned char label_tweak[32];\r\n        secp256k1_pubkey label;\r\n        secp256k1_pubkey labelled_spend_pubkey;\r\n        secp256k1_pubkey bob_spend_ec_pubkey;\r\n        unsigned char labelled_spend_pubkey_print[33];\r\n        size_t outputlen = 33;\r\n\r\n        ret = secp256k1_ec_pubkey_parse(ctx, &bob_spend_ec_pubkey, bob_spend_pubkey, sizeof(bob_spend_pubkey));\r\n        assert(ret);\r\n\r\n        ret = secp256k1_silentpayments_recipient_create_label_tweak(ctx, &label, label_tweak, bob_scan_key, 1);\r\n        assert(ret);\r\n        ret = secp256k1_silentpayments_recipient_create_labelled_spend_pubkey(ctx, &labelled_spend_pubkey, &bob_spend_ec_pubkey, &label);\r\n        assert(ret);\r\n\r\n        ret = secp256k1_ec_pubkey_serialize(ctx, labelled_spend_pubkey_print, &outputlen, &labelled_spend_pubkey, SECP256K1_EC_COMPRESSED);\r\n        assert(ret);\r\n        printf(\"Labelled Bob Spend Pubkey: \");\r\n        print_hex(labelled_spend_pubkey_print, sizeof(labelled_spend_pubkey_print));\r\n        assert(memcmp(labelled_spend_pubkey_print, bob_address[1], 33) == 0);\r\n        printf(\"It is the same as bob_address[1]. This is how we derive labeled addresses.\\n\");\r\n    }\r\n    \r\n```",
      "created_at": "2024-07-16T01:24:53Z",
      "updated_at": "2024-07-16T01:26:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1678634760",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1678634760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 260,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698662623",
      "pull_request_review_id": 2210420185,
      "id": 1698662623,
      "node_id": "PRRC_kwDOAP4Jqs5lP4jf",
      "diff_hunk": "@@ -2,28 +2,111 @@\n #define SECP256K1_SILENTPAYMENTS_H\n \n #include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n-/* This module provides an implementation for Silent Payments, as specified in BIP352.\n- * This particularly involves the creation of input tweak data by summing up private\n- * or public keys and the derivation of a shared secret using Elliptic Curve Diffie-Hellman.\n- * Combined are either:\n- *   - spender's private keys and recipient's public key (a * B, sender side)\n- *   - spender's public keys and recipient's private key (A * b, recipient side)\n- * With this result, the necessary key material for ultimately creating/scanning\n- * or spending Silent Payment outputs can be determined.\n+/* This module provides an implementation for Silent Payments, as specified in\n+ * BIP352. This particularly involves the creation of input tweak data by\n+ * summing up private or public keys and the derivation of a shared secret\n+ * using Elliptic Curve Diffie-Hellman. Combined are either: - spender's\n+ * private keys and recipient's public key (a * B, sender side) - spender's\n+ * public keys and recipient's private key (A * b, recipient side) With this\n+ * result, the necessary key material for ultimately creating/scanning or\n+ * spending Silent Payment outputs can be determined.\n  *\n  * Note that this module is _not_ a full implementation of BIP352, as it\n  * inherently doesn't deal with higher-level concepts like addresses, output\n- * script types or transactions. The intent is to provide a module for abstracting away\n- * the elliptic-curve operations required for the protocol. For any wallet software already\n- * using libsecp256k1, this API should provide all the functions needed for a Silent Payments\n- * implementation without requiring any further elliptic-curve operations from the wallet.\n+ * script types or transactions. The intent is to provide a module for\n+ * abstracting away the elliptic-curve operations required for the protocol.\n+ * For any wallet software already using libsecp256k1, this API should provide\n+ * all the functions needed for a Silent Payments implementation without\n+ * requiring any further elliptic-curve operations from the wallet.\n  */\n \n+/* This struct serves as an In param for passing the silent payment address\n+ * data. The index field is for when more than one address is being sent to in\n+ * a transaction. Index is set based on the original ordering of the addresses\n+ * and used to return the generated outputs matching the original ordering.\n+ * When more than one recipient is used the recipient array will be sorted in\n+ * place as part of generating the outputs, but the generated outputs will be\n+ * returned in the original ordering specified by the index to ensure the\n+ * caller is able to match up the generated outputs to the correct silent\n+ * payment address (e.g. to be able to assign the correct amounts to the\n+ * correct generated outputs in the final transaction).\n+ */\n+typedef struct {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n private keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the the\n+ *  payment.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 56,
      "original_position": 67,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "79562d0cd116caaa160094e77245e0781b4342d7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n *  transaction inputs, otherwise the recipient will be unable to find the\r\n *  payment.\r\n```",
      "created_at": "2024-07-31T14:54:54Z",
      "updated_at": "2024-07-31T15:28:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1698662623",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698662623"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": 55,
      "original_start_line": 55,
      "start_side": "RIGHT",
      "line": 56,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698665482",
      "pull_request_review_id": 2210420185,
      "id": 1698665482,
      "node_id": "PRRC_kwDOAP4Jqs5lP5QK",
      "diff_hunk": "@@ -107,6 +107,56 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m) label = label_tweak * G",
      "path": "include/secp256k1_silentpayments.h",
      "position": 115,
      "original_position": 9,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "23c7aead6374af9e6ae9128209e77304acc833d4",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "seems like a newline got lost here:\r\n```suggestion\r\n *  label_tweak = hash(b_scan || m)\r\n *  label = label_tweak * G\r\n```",
      "created_at": "2024-07-31T14:56:38Z",
      "updated_at": "2024-07-31T15:28:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1698665482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698665482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 115,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698714811",
      "pull_request_review_id": 2210420185,
      "id": 1698714811,
      "node_id": "PRRC_kwDOAP4Jqs5lQFS7",
      "diff_hunk": "@@ -7,10 +7,237 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_pubkey *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss, pk;\n+    size_t len;\n+    int ret;\n+    memset(shared_secret33, 0, 33);\n+    secp256k1_pubkey_load(ctx, &pk, public_component);\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, &pk, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, unsigned int k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, NULL);\n+    /* While not technically \"secret\" data, explicitly clear hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    memset(hash_ser, 0, sizeof(hash_ser));\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, unsigned int k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    secp256k1_pubkey_load(ctx, &P_output_ge, recipient_spend_pubkey);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 128,
      "original_position": 124,
      "commit_id": "00b0cb19a97718dfaab70aa7505ff157f22a31bd",
      "original_commit_id": "79562d0cd116caaa160094e77245e0781b4342d7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we check the return value of `secp256k1_pubkey_load`, here and at other places? Note sure if there's a general guideline in this library whether passed in `secp256k1_pubkey` instance parameters can be just treated as valid due to its type (after all, they must have been created before with libsecp as well) or a check is preferred as belts-and-suspenders.\r\n\r\nFor example, the ellswift module does a verification check:\r\nhttps://github.com/bitcoin-core/secp256k1/blob/fded437c4cec1a29921c90be325d62ba866f44ce/src/modules/ellswift/main_impl.h#L406\r\nwhile the ECDH module doesn't:\r\nhttps://github.com/bitcoin-core/secp256k1/blob/fded437c4cec1a29921c90be325d62ba866f44ce/src/modules/ecdh/main_impl.h#L47\r\n\r\n(Probably it also depends on the code following, haven't gone deeper there yet...)",
      "created_at": "2024-07-31T15:28:55Z",
      "updated_at": "2024-07-31T15:28:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1698714811",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1698714811"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1519"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 128,
      "original_line": 128,
      "side": "RIGHT"
    }
  ]
}