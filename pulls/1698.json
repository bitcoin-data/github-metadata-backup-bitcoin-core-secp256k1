{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698",
    "id": 2655159183,
    "node_id": "PR_kwDOAP4Jqs6eQoOP",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1698.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1698.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/2948a9bf619ba97a0acf38056e6b27005448ebb6",
    "number": 1698,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add BIP352 module (take 3)",
    "user": {
      "login": "josibake",
      "id": 7444140,
      "node_id": "MDQ6VXNlcjc0NDQxNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/josibake",
      "html_url": "https://github.com/josibake",
      "followers_url": "https://api.github.com/users/josibake/followers",
      "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
      "organizations_url": "https://api.github.com/users/josibake/orgs",
      "repos_url": "https://api.github.com/users/josibake/repos",
      "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/josibake/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This PR implements [BIP352 - Silent payments](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki). It is recommended to read through the BIP before reviewing this PR.\r\n\r\nThis is a continuation of the work in https://github.com/bitcoin-core/secp256k1/pull/1519 and only opened as a new PR due to the comment history on #1519 becoming quite long and difficult to sift through. It is recommended reviewers go through #1519 for background context, if interested.",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "created_at": "2025-07-10T08:53:21Z",
    "updated_at": "2025-07-25T09:23:51Z",
    "mergeable": true,
    "mergeable_state": "unstable",
    "merged": false,
    "merge_commit_sha": "25f43440254d0384f01ff90d52733b4347c12557",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "josibake:bip352-silentpayments-module-2025",
      "ref": "bip352-silentpayments-module-2025",
      "sha": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 751433786,
        "node_id": "R_kgDOLMn4Og",
        "name": "secp256k1",
        "full_name": "josibake/secp256k1",
        "owner": {
          "login": "josibake",
          "id": 7444140,
          "node_id": "MDQ6VXNlcjc0NDQxNDA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/josibake",
          "html_url": "https://github.com/josibake",
          "followers_url": "https://api.github.com/users/josibake/followers",
          "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
          "organizations_url": "https://api.github.com/users/josibake/orgs",
          "repos_url": "https://api.github.com/users/josibake/repos",
          "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/josibake/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/josibake/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/josibake/secp256k1",
        "archive_url": "https://api.github.com/repos/josibake/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/josibake/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/josibake/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/josibake/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/josibake/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/josibake/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/josibake/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/josibake/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/josibake/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/josibake/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/josibake/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/josibake/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/josibake/secp256k1/events",
        "forks_url": "https://api.github.com/repos/josibake/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/josibake/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/josibake/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/josibake/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/josibake/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/josibake/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/josibake/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/josibake/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/josibake/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/josibake/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/josibake/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/josibake/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/josibake/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/josibake/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/josibake/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/josibake/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:josibake/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/josibake/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/josibake/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/josibake/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/josibake/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/josibake/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/josibake/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/josibake/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/josibake/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/josibake/secp256k1/hooks",
        "svn_url": "https://github.com/josibake/secp256k1",
        "language": "C",
        "forks_count": 1,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 13313,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-07-25T09:16:33Z",
        "created_at": "2024-02-01T15:52:50Z",
        "updated_at": "2025-07-22T08:03:12Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "b9313c6e1a6082a66b4c75777e18ca4b176fcf9d",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1071,
        "stargazers_count": 2280,
        "watchers_count": 2280,
        "size": 12585,
        "default_branch": "master",
        "open_issues_count": 148,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-07-21T18:57:07Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2025-07-25T06:48:25Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 10023,
    "deletions": 12,
    "changed_files": 24,
    "commits": 10,
    "review_comments": 21,
    "comments": 7
  },
  "events": [
    {
      "event": "reviewed",
      "id": 3005508488,
      "node_id": "PRR_kwDOAP4Jqs6zJGuI",
      "url": null,
      "actor": null,
      "commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3005508488",
      "submitted_at": "2025-07-10T16:26:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18619898506,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARV1RqK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18619898506",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9e85256bbe527bf084222ee08dade9ea497d5c99",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/9e85256bbe527bf084222ee08dade9ea497d5c99",
      "created_at": "2025-07-14T14:54:07Z"
    },
    {
      "event": "commented",
      "id": 3069942270,
      "node_id": "IC_kwDOAP4Jqs62-5n-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3069942270",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:20Z",
      "updated_at": "2025-07-14T15:04:20Z",
      "author_association": "MEMBER",
      "body": "Updated [6264c3d](https://github.com/bitcoin-core/secp256k1/commit/6264c3d0939f2ab11ba8c92f3cb521f9c89c8596) -> [9e85256](https://github.com/bitcoin-core/secp256k1/commit/9e85256bbe527bf084222ee08dade9ea497d5c99) ([2025_00](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_00) -> [2025_01](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_01), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_00..bip352-silentpayments-module-2025_01))\r\n\r\n* Added documentation for expectations around `label_lookup` pointer lifetimes (h/t @antonilol)\r\n* Update docs to accurately reflect that `label_context` is optional (h/t @antonilol)\r\n* Added a test case for passing a lookup callback with a null context (which required some small updates to the test label lookup function)",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3069942270",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18620089953,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARV2AZh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18620089953",
      "actor": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:20Z"
    },
    {
      "event": "subscribed",
      "id": 18620089990,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARV2AaG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18620089990",
      "actor": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:21Z"
    },
    {
      "event": "reviewed",
      "id": 3037944552,
      "node_id": "PRR_kwDOAP4Jqs61E1ro",
      "url": null,
      "actor": null,
      "commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3037944552",
      "submitted_at": "2025-07-21T12:45:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18729968570,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARcZKO6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18729968570",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a4db27946b6bdf165095348543e44d7cc4e45e1c",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/a4db27946b6bdf165095348543e44d7cc4e45e1c",
      "created_at": "2025-07-21T14:09:02Z"
    },
    {
      "event": "commented",
      "id": 3096975105,
      "node_id": "IC_kwDOAP4Jqs64mBcB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3096975105",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:15:58Z",
      "updated_at": "2025-07-21T14:15:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "Sorry, stopping CI here. We're about to make a release and need to the CI. :)\r\n\r\nWe'll restart the jobs here afterwards.  ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3096975105",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "commented",
      "id": 3096996582,
      "node_id": "IC_kwDOAP4Jqs64mGrm",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3096996582",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:51Z",
      "updated_at": "2025-07-21T14:21:51Z",
      "author_association": "MEMBER",
      "body": "Update [9e85256](https://github.com/bitcoin-core/secp256k1/commit/9e85256bbe527bf084222ee08dade9ea497d5c99) -> [a4db279](https://github.com/bitcoin-core/secp256k1/commit/a4db27946b6bdf165095348543e44d7cc4e45e1c) ([2025_01](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_01) -> [2025_02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_01..bip352-silentpayments-module-2025_02))\r\n\r\n* Update the constant time tests to cover the `_recipient_created_shared_secret` and `_recipient_created_output_pubkey` functions (h/t @theStack )\r\n* Remove no longer needed TODO comments and clarify why a constant time test without a label lookup function is sufficient for `_recipient_scan_outputs`",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3096996582",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18730266172,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARcaS48",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18730266172",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:52Z"
    },
    {
      "event": "subscribed",
      "id": 18730266200,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARcaS5Y",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18730266200",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:53Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDdjZWRiNmNkNWRhZDRkMGZiNDBiMzBjNDUyY2VmNTBiOTZmMzI1NDM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7cedb6cd5dad4d0fb40b30c452cef50b96f32543",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7cedb6cd5dad4d0fb40b30c452cef50b96f32543",
      "tree": {
        "sha": "412c684fb80cf297863ac26eafec73f52f9557c8",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/412c684fb80cf297863ac26eafec73f52f9557c8"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 412c684fb80cf297863ac26eafec73f52f9557c8\nparent b9313c6e1a6082a66b4c75777e18ca4b176fcf9d\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1695828134 +0200\ncommitter josibake <josibake@protonmail.com> 1753171465 +0100\n\nbuild: add skeleton for new silentpayments (BIP352) module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmh/RgoACgkQity1WMTz\nPWVBAQ//VsLBxWTGceJfThnAIvixzcSFB6V7C+7pKT1EZEDv7N6akVCxOKmR7SeY\nhNkwghooDmtS8/sh7HmUxoiMY68FMQ9QMAx15fwS+V1ISYWDSajJ0nSFAOKwM0uJ\nA12xAozbGjlB+g5D5FrD3qkyBiH+KEDQ3mpKFSXs60/ss1CRZC+KjZ1wjXPZeByL\nDEfveKMKzVCNPnGYOVUA+zur10nbDskT5KSnhW70SQIgExmB+v1wMQTWK9pKhusM\n4FIktTZrqigQnU6vsEgyCpQtL1oSo6PbQQrDe3pTKtWNf/LnkrbBWwnnnJA0fZHP\nvMO32BQhVPczHm/w0kDI2TT4QbkFG/VInGmbEqyZXe5xCacmUNw18BnfaMGRYU+A\n1TaW9Jn+IBVOCHs11JKCZgtwuw3gStorkZ3gbuee3MWNBfVD2ga9UUnz72Lyk8sJ\n5yumEXhgqEGuccxbCTdVYHYo/VVN0cR6t8UytYIi4I77oNvaro7pACtwXIq4CZXs\nvWSp1sVdd6hZbgtUXZdC/lqpG6gyNd98qflCeSg2gfId27B9uCSfuoUZ+91XsHoE\nt8ezeJm06Jc+vsAuJV5rSCxuVRIDO7mzavePH9kUiK2vowkChaN+HJ/iSq3Js6/N\nH86/x0s1CVL16+bS/cFff4evVEzDC5EUJFBJtA5yqVB6+JQ8Jds=\n=VD3U\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b9313c6e1a6082a66b4c75777e18ca4b176fcf9d",
          "sha": "b9313c6e1a6082a66b4c75777e18ca4b176fcf9d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b9313c6e1a6082a66b4c75777e18ca4b176fcf9d"
        }
      ],
      "message": "build: add skeleton for new silentpayments (BIP352) module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-07-22T08:04:25Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2023-09-27T15:22:14Z"
      },
      "sha": "7cedb6cd5dad4d0fb40b30c452cef50b96f32543"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18749002077,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARdhxFd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18749002077",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e35bedeca6318011afbd59bba6f412a85c33e134",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/e35bedeca6318011afbd59bba6f412a85c33e134",
      "created_at": "2025-07-22T10:27:59Z"
    },
    {
      "event": "commented",
      "id": 3102130501,
      "node_id": "IC_kwDOAP4Jqs645sFF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3102130501",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-22T10:29:47Z",
      "updated_at": "2025-07-22T10:29:47Z",
      "author_association": "MEMBER",
      "body": "Rebased on top of 0.7.0 release :tada: [a4db279](https://github.com/bitcoin-core/secp256k1/commit/a4db27946b6bdf165095348543e44d7cc4e45e1c) -> [e35bede](https://github.com/bitcoin-core/secp256k1/commit/e35bedeca6318011afbd59bba6f412a85c33e134) ([2025_02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02) -> [2025_02_rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02_rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_02..bip352-silentpayments-module-2025_02_rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3102130501",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "commented",
      "id": 3102274260,
      "node_id": "IC_kwDOAP4Jqs646PLU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3102274260",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-22T11:13:33Z",
      "updated_at": "2025-07-22T11:13:33Z",
      "author_association": "MEMBER",
      "body": "I did a deep dive on using `(*arg)[size]` in this PR and opened https://github.com/bitcoin-core/secp256k1/issues/1710 for discussion, since this is a broader topic than just this PR. The relevant changes for here and the downstream Bitcoin Core PRs are https://github.com/josibake/secp256k1/commit/5a1088066b2ce5e2e77b4e4bc190575d1171c374 and https://github.com/josibake/bitcoin/commit/5835d987477fc8eae391e4d1cc5033d921925ea1",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3102274260",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "labeled",
      "id": 18768558526,
      "node_id": "LE_lADOAP4Jqs6_1gh3zwAAAAResXm-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18768558526",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-23T08:17:16Z",
      "label": {
        "name": "feature",
        "color": "731E95"
      }
    },
    {
      "event": "reviewed",
      "id": 3047815175,
      "node_id": "PRR_kwDOAP4Jqs61qfgH",
      "url": null,
      "actor": null,
      "commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3047815175",
      "submitted_at": "2025-07-23T14:51:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18794190282,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARgOJXK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794190282",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "created_at": "2025-07-24T12:18:04Z"
    },
    {
      "event": "commented",
      "id": 3113267037,
      "node_id": "IC_kwDOAP4Jqs65kK9d",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3113267037",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:16Z",
      "updated_at": "2025-07-24T12:23:16Z",
      "author_association": "MEMBER",
      "body": "Updated [e35bede](https://github.com/bitcoin-core/secp256k1/commit/e35bedeca6318011afbd59bba6f412a85c33e134) -> [1a84908](https://github.com/bitcoin-core/secp256k1/commit/1a84908cdac60d7313a8d5faee470ce8e2c1c763) ([2025_02_rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02_rebase) -> [2025_03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_03), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_02_rebase..bip352-silentpayments-module-2025_03))\r\n\r\n* Added a test case for the `_recipient_create_output_pubkey` corner case (h/t @theStack)\r\n* Removed the `VERIFY_CHECK` in favour of returning an error",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3113267037",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18794275408,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARgOeJQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794275408",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:17Z"
    },
    {
      "event": "subscribed",
      "id": 18794275428,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARgOeJk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794275428",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:17Z"
    },
    {
      "event": "reviewed",
      "id": 3053302400,
      "node_id": "PRR_kwDOAP4Jqs61_bKA",
      "url": null,
      "actor": null,
      "commit_id": "1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3053302400",
      "submitted_at": "2025-07-24T21:35:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDg0ZDdiOWU3NjMxNWYzNmIzM2NjY2JlNDQ0NjhmYjA5NjA1YmY1YzM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/84d7b9e76315f36b33cccbe44468fb09605bf5c3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/84d7b9e76315f36b33cccbe44468fb09605bf5c3",
      "tree": {
        "sha": "015f5f98b6248f796ebfda27174f6b2604acdd8a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/015f5f98b6248f796ebfda27174f6b2604acdd8a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 015f5f98b6248f796ebfda27174f6b2604acdd8a\nparent 7cedb6cd5dad4d0fb40b30c452cef50b96f32543\nauthor josibake <josibake@protonmail.com> 1711383817 +0100\ncommitter josibake <josibake@protonmail.com> 1753434504 +0100\n\nsilentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiDSdAACgkQity1WMTz\nPWUxsA//b1n7/fA3LhDCv1DqPWrPYP7Ogi/BQ6Kw3iZwc/811iCGapoPVhHvli+u\n7RR8LLTW7+I4fzSAqFfVPmXJuaYznPa5L1KMu/ZlVo6gc6ucPVDayiqp8BlWQTs9\n129XXovh6s2Cn4DAfUPlNfi2Bv1v/YU7jyeRJzE+ZCWld3lFZgV/eFT3W/eqQRB6\nZp7iix+bAZGikqsXP5FXzbGWSUYLUnhGKv3wZP+lotv5DpVV4NlcEBLth42BEWXK\nqUf6V0tkrVLU84zTTn3Ia26pozk9QDlxwvkaYE/lpLXuj07TGosoMbGWHmn9NBZH\ntfjsN+NxuP1qgZmcsLTq/Fk/OxVjo9PAXUlsVRNK7C9i44sH+JRJoJfZgXd3w8J0\nf94NxauSINDUIbYDBF+VRJpJQ5z0E1g/lk/cU1B+I/Mp0LFQ/CWPf7tEKPie3ZQx\nf/4578sz5HFcPtIjX+wYdno8yZT2hcvB0rVIvPMuTTBWdRaD1fKDe+grp6DjcPb3\nMIwjnZvPiBGmKc2HNwMutDO45nG3coj43vJsZmgh6skVbkcwoHLUdwx6/tM3nIDa\nWg9RvpXt8TOUbZc7zAQhJZ93n1SVojobuM3qy23myeiB/6qr8XWlld7erviAqhap\n0KO6Rvg0+rchaDAreaU9Cq3gKoG123KvWXios364gKnRt5hDmNk=\n=i5go\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7cedb6cd5dad4d0fb40b30c452cef50b96f32543",
          "sha": "7cedb6cd5dad4d0fb40b30c452cef50b96f32543",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7cedb6cd5dad4d0fb40b30c452cef50b96f32543"
        }
      ],
      "message": "silentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-07-25T09:08:24Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-03-25T16:23:37Z"
      },
      "sha": "84d7b9e76315f36b33cccbe44468fb09605bf5c3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDdjYzk1MGJiMmFkZjdhNWVjN2M4YzhjNmRiMGE5MTBmYzY1OGE5NGE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7cc950bb2adf7a5ec7c8c8c6db0a910fc658a94a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7cc950bb2adf7a5ec7c8c8c6db0a910fc658a94a",
      "tree": {
        "sha": "96874abcdc0d9858a5fed2a7215ac4c40c0633e6",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/96874abcdc0d9858a5fed2a7215ac4c40c0633e6"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 96874abcdc0d9858a5fed2a7215ac4c40c0633e6\nparent 84d7b9e76315f36b33cccbe44468fb09605bf5c3\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1705946165 +0100\ncommitter josibake <josibake@protonmail.com> 1753434577 +0100\n\nsilentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiDSdIACgkQity1WMTz\nPWVP/Q/+Or057IaAtK8BDUd0QDrG9e/LaVbgCQ+qzdfrNxT9JqUfi9smIDcjYS3Q\nE0YJWil5lkGcuYvs43cq7MPEJxG18CixEqSizIX8S5Mvw+HW6iRDTOm77TJ3X7K7\nuilQLaB6Ub0Dsmf1IwOs9fZiJE1txH4GZYRTYjy/dngfQv1LWVlrPf38CuuaqPxu\nv9MghSGwn3wO58QtQyJK+STOVxhjV6ffVz5STdtrYiDZDbX5/U7Dk9ydxGsa2zaB\nCRIYc1oBzKjOof2saLMQAgrg2By0iJb4IhDCAOIBKzmLPRySPOU4ayh6AmSlZZDL\n01OlYu386aATrRXfxbeZybkt8rS0R0YM33Mfmn9lygJmbw78vsRRKjoCUR0fhSE4\nsPBulnzKguQxv4TlMGRvoG5dNfB9//HgGZyqzZ1iDasKjDAmzeoAJ3ORHxktJkBf\n1KdgMJawrmvMrBltqiGRg+qzcc+f+YW3Ulygi+ul+rhubea0p0RsoOvTYQFIBIyT\n+6cuPDqVSxf2u81+5MlNT/2CwVXfu2AEvcwya0YEgsqiYDcWKTf6AopoaHTca2GR\nHTAKN6XnDv9lttYDAbs+U7/BhGMXURMHHauHx7XjRjg3p98S7pmIZ9WsIJ+7dgm/\nZ83U76QUxUNW5gLPBFIv2WxL18gosLI9xa4/n1r9n0LydNjJwqA=\n=maK3\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/84d7b9e76315f36b33cccbe44468fb09605bf5c3",
          "sha": "84d7b9e76315f36b33cccbe44468fb09605bf5c3",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/84d7b9e76315f36b33cccbe44468fb09605bf5c3"
        }
      ],
      "message": "silentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-07-25T09:09:37Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-01-22T17:56:05Z"
      },
      "sha": "7cc950bb2adf7a5ec7c8c8c6db0a910fc658a94a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDNjNzVmMWE0MzY5MTJkYjQxMTM5OTVlMzVjYjdiNTU2Y2JlOTIzM2I",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3c75f1a436912db4113995e35cb7b556cbe9233b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3c75f1a436912db4113995e35cb7b556cbe9233b",
      "tree": {
        "sha": "2f60da4e5fa18a36dcf65c1c16bedce0b99bc727",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/2f60da4e5fa18a36dcf65c1c16bedce0b99bc727"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 2f60da4e5fa18a36dcf65c1c16bedce0b99bc727\nparent 7cc950bb2adf7a5ec7c8c8c6db0a910fc658a94a\nauthor josibake <josibake@protonmail.com> 1719660810 +0200\ncommitter josibake <josibake@protonmail.com> 1753434579 +0100\n\nsilentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the summed input public key (A_sum)\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply b_scan * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a public_data object to\nand from a public key. When serializing a public_data object, the\ninput_hash is multplied into A_sum. This is so the object can be stored\nas public key for wallet rescanning later, or to vend to light clients.\nFor the light client, a `_parse` function is added which parses the\ncompressed public key serialization into a `public_data` object.\n\nFinally, add test coverage for the receiving API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiDSgwACgkQity1WMTz\nPWWsehAAy9VLEGSKESpvbGHdNGCT8p1BjPICpNmowZJa5MsqMXof3LJ79pJCcVXB\nCut4933XFLkrA5fsKt0PHkHT15aOU6EwvAbOBiR3BSOt+kUoef1JY0Diqm0pizN1\nLcGz4r7zVaYJHA9fMBjH82PTF7oss47IiaueeuFFqsKppSQxC/1VgnekRMc8Lwwc\nZpMSebDuq+xGyiPGVjUWIjPpflni9gP+zMwprS6X/DE/2tquP+I3HNVInHGqY0RY\ntQntuOcwm/SD7kDCR4kOeCze7u5u2rR1aTF2sIZW5n2T7dpWd7zTZyskpd6a+RZZ\nw7Qq1UZwXukhaIoARL1RLzfOB8TggBEMh4zIbWSeGip8NSkRPlKz6QQAjo90fMfF\nmB1r/4jeChkHn/Raxp0aDYZFBLG8msO5+wen/O6MPx6Nf4XN8J/TY1TYODCHPwyM\nqo/G3QavaLVYUGuoiKewX6ItKB4ayHHpmdyyTM2sKkERiNhQ9RkTeH7QJecx1zDN\nm2qXyV7fkQ0tgEajrsBPPwLsfDevUsq+vWvu3D4bDw33B+ilOdTBRE1avmF60GG6\nBBwN4//obi22BRkzNi0wvt4hUVr8MnUXSicZ0eJfO8mnzbb8XIyRdz0xDsySxV2T\nM5Qe/LaxGNdeG6tNxX6O8aS/NbZyOgScrnTUovbDZb28Y7lT3Zc=\n=MwYR\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7cc950bb2adf7a5ec7c8c8c6db0a910fc658a94a",
          "sha": "7cc950bb2adf7a5ec7c8c8c6db0a910fc658a94a",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7cc950bb2adf7a5ec7c8c8c6db0a910fc658a94a"
        }
      ],
      "message": "silentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the summed input public key (A_sum)\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply b_scan * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a public_data object to\nand from a public key. When serializing a public_data object, the\ninput_hash is multplied into A_sum. This is so the object can be stored\nas public key for wallet rescanning later, or to vend to light clients.\nFor the light client, a `_parse` function is added which parses the\ncompressed public key serialization into a `public_data` object.\n\nFinally, add test coverage for the receiving API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-07-25T09:09:39Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-06-29T11:33:30Z"
      },
      "sha": "3c75f1a436912db4113995e35cb7b556cbe9233b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDc0MjQ2YzRhMGJjNjZhM2Y2Yjk4MTI5MmQwODQzYjM0N2Q0ZmQwZjI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/74246c4a0bc66a3f6b981292d0843b347d4fd0f2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/74246c4a0bc66a3f6b981292d0843b347d4fd0f2",
      "tree": {
        "sha": "3ce1d1e15778ba3b9ab8e04cd3a779edc9f9ef35",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/3ce1d1e15778ba3b9ab8e04cd3a779edc9f9ef35"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 3ce1d1e15778ba3b9ab8e04cd3a779edc9f9ef35\nparent 3c75f1a436912db4113995e35cb7b556cbe9233b\nauthor josibake <josibake@protonmail.com> 1713202589 +0200\ncommitter josibake <josibake@protonmail.com> 1753434768 +0100\n\nsilentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiDSpMACgkQity1WMTz\nPWU6Hg/8C/vFKYD6lVZPl/DryHjfOAoRjaZI/lIwzXIpJNh0/P+qxu3P0o+YA4Ay\n6NOj3z/vR1LBc5dOWc5yWOVuhdBiNpDYsf3HVPHZjugrS+GYh8i+y2i63qYYrzdr\nUUQ+XOBe0eVF524iMqz55vMTcTyl2wzF5BQwuRlyVv3z4mrKoXXwwk14ONGZ/yCJ\nCntBxT1F7f6Wm5AiusbClshqEmcQ5DR1bzWel6AMSjIdcctWznp+PE19pU+QPz0s\nPwZ7LES0jzlo+3cTwAPydWopqVHy2lsfnD5ZAGJib2H0TrY9hpPSEbdfGaew05rS\nH8Ace3U7pzhwyxM0uRBSz9vI8PVvEYaCUPu+fvNCd0uzAadHKuS0yUXFp67wEAAM\nmXu1JMkRRvnV/6yiSP11l7ihEeVkzre5yb9nuylxPXBsk/mLzJCQ3QIsImvbzH9t\nrT1zaQU2P35N8358rI/bku0IJ2pwC/gA5sWX3QRW0SPoNJKUJm5je3QlxS2RCcFq\n138m7IjKsXHcRxZ3BDg3K5AlKjrLfDtb0hhQdTvUStnlQBhsZiRBMHYA2r/zNBGB\ndQtMxc7Io8ZSh2PRgs1g7o3l6NizU4LlU2g8cPkWnPJITHmGfZDlKotHN+PVeN7H\nuKQbUga/j1DWlUruOAMdCfo8Hyc2bMsLBs7BxGN0Q95Pixf5xV4=\n=h4sI\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3c75f1a436912db4113995e35cb7b556cbe9233b",
          "sha": "3c75f1a436912db4113995e35cb7b556cbe9233b",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3c75f1a436912db4113995e35cb7b556cbe9233b"
        }
      ],
      "message": "silentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-07-25T09:12:48Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-15T17:36:29Z"
      },
      "sha": "74246c4a0bc66a3f6b981292d0843b347d4fd0f2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDAzNjJjZTNiZGY1YTM1Y2I1NTk3ZWQwZjY1OGU0YTMwOTRlNTdhOWQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0362ce3bdf5a35cb5597ed0f658e4a3094e57a9d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0362ce3bdf5a35cb5597ed0f658e4a3094e57a9d",
      "tree": {
        "sha": "ac2816d55a310cd6b3b06bf91a183fc3dc232d23",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ac2816d55a310cd6b3b06bf91a183fc3dc232d23"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ac2816d55a310cd6b3b06bf91a183fc3dc232d23\nparent 74246c4a0bc66a3f6b981292d0843b347d4fd0f2\nauthor josibake <josibake@protonmail.com> 1714066415 +0200\ncommitter josibake <josibake@protonmail.com> 1753434791 +0100\n\nsilentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan and for scanning a single\noutput. Only benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiDSqcACgkQity1WMTz\nPWUDPQ/+Pkz8/T9wisccj1R+63TNqIWWPaPElovhhB/dNYQ7eEzouC8+X4iizK3/\nQeTBimA4F5Y5YZSCGbmhfZ7w8VukbKui4FHjuNB/RM5ySR31hbXo6GdeE1H1NHvT\n5/Cv+gjyPX+1xtgHxdwj1II3WFRh+l90AaYoR2DzvyQvsRzxtTyOiTH9nnUCEoW7\nOBehy3XjmK/eTm0WV95fzubXDh2U3S1d5yGiQdfGz7SrcifqvsU0tOvKZpNWNQgm\ntc5OQRZ9VgitXaK12/h/ybY8A0iXxgDia1eOIFJi15Y2QCSEKCcOjZ1ghqvmJ6ge\nrZOnTMye3p3mp0+g+0XdT2CKEmp8ROxlhLgnDZ87naRo5xN+hlxDhCuCnVzgMAau\n2fKUY+/GKn5VIh6XBirDwfvRq27nAJg6XSt5Ao8nC+HgyU4+EEtdETik8ol+k7Mb\nDqh0H4DSlV9PA9wvMxY2OOFwrSvJtwF25OFURZz8fE7rzkiXT2JrihyRpfPgenbj\ns8ogZrvjyiOvPaGJxhteb1judU1cU7SPpkgqVsnCT+U47Cv9kw2BVQgKsSmQ+va+\nHwf4t36jXUIRKC3TB8T87J/meXp1Upa69fXhS+0sOP++x/E0FfHS3vI5V8BHAUI0\njAZPerfQW+9CFsy4HWYOSWpV31jnACUjMKz6+5utLw0eFXScsLw=\n=V6L8\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/74246c4a0bc66a3f6b981292d0843b347d4fd0f2",
          "sha": "74246c4a0bc66a3f6b981292d0843b347d4fd0f2",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/74246c4a0bc66a3f6b981292d0843b347d4fd0f2"
        }
      ],
      "message": "silentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan and for scanning a single\noutput. Only benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-07-25T09:13:11Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-25T17:33:35Z"
      },
      "sha": "0362ce3bdf5a35cb5597ed0f658e4a3094e57a9d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGFhMTVmMzdmZTVlYmM2NDRlZDczOTcxMjliODAxNDA1NmFhN2UyMTY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/aa15f37fe5ebc644ed7397129b8014056aa7e216",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/aa15f37fe5ebc644ed7397129b8014056aa7e216",
      "tree": {
        "sha": "61c6c6ada3e34bd4341b0ae1b4fd3d30b7a4eb7d",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/61c6c6ada3e34bd4341b0ae1b4fd3d30b7a4eb7d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 61c6c6ada3e34bd4341b0ae1b4fd3d30b7a4eb7d\nparent 0362ce3bdf5a35cb5597ed0f658e4a3094e57a9d\nauthor josibake <josibake@protonmail.com> 1719942343 +0200\ncommitter josibake <josibake@protonmail.com> 1753434792 +0100\n\ntests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiDSqgACgkQity1WMTz\nPWUSqw/+PlwuSc6ulRQhDy3O2BMpFH2yRbCmNd2Tg5quq+WQLuVyqE6JMSigfRNg\nV/SfL/O9DHL6bHRG79HaUEPx9XfRIuiO9d5GR9eRXtfC1n+txwneITZDiB9lLt8V\nSzP7Y+X1QCMDt1v7Q6aYbX285XQtlPsEX8t2zBZHL7ZvAbOtek9DRBqnEpgFIoKu\nciMzH+RB6GfTVTpqpoS4ivhms0Imvsxq0t4y9J46bLtCWCvAgWw5gDXVzCjzzj8D\na2JgBJ8+NGeWC16Jg7aWu4DIoYy0bUWeTEVQpGHpSYIzayqx52qQKOK9MURaxidX\nA6vRnQg39pTbc6F84nTRZxgvmCJVg8IgNNZl3VdbAL27FACOYTdoshu/DD19ghg4\nmEHEKlmSKch1P/Y+lJYU4yyB/BOvMJAz4SDb4EWhRjRyA5fvfmbuHhA4Z1pzM4ul\ndOfnGZr1fnAymdF+3JhvsW5Mhrtkdl4PSUVMZWaIVoiGpuUUo4IpFI3gUK9fVyGh\n9KRwXgZy/ztT3PC5ONg81ozAbu0OIY+O7uVWN6omi3Tc2p3K4HlBNOAp0Sf1xFUg\n6XqAsdAt/ogolSgIPIqcscpW5sLX4hzv0qzvksrg+ygavtLA8wMte+x5XD2XFlnw\n4Jle4+cwCHwsi1XnUwiprRrry0w49TPk4vQUVgO91u/O7evoT2Y=\n=If9k\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0362ce3bdf5a35cb5597ed0f658e4a3094e57a9d",
          "sha": "0362ce3bdf5a35cb5597ed0f658e4a3094e57a9d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0362ce3bdf5a35cb5597ed0f658e4a3094e57a9d"
        }
      ],
      "message": "tests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-07-25T09:13:12Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-02T17:45:43Z"
      },
      "sha": "aa15f37fe5ebc644ed7397129b8014056aa7e216"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDJmNTU0ZTQ1NmE2ODE1YWM1NjE4ZDIwOGIzOThlNDU4ZDViNDY3NmY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/2f554e456a6815ac5618d208b398e458d5b4676f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/2f554e456a6815ac5618d208b398e458d5b4676f",
      "tree": {
        "sha": "14351106be36a7abadc380bb07e815f2e9ef3254",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/14351106be36a7abadc380bb07e815f2e9ef3254"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 14351106be36a7abadc380bb07e815f2e9ef3254\nparent aa15f37fe5ebc644ed7397129b8014056aa7e216\nauthor josibake <josibake@protonmail.com> 1730981939 +0100\ncommitter josibake <josibake@protonmail.com> 1753434793 +0100\n\ntests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiDSqkACgkQity1WMTz\nPWW2xxAAyJ1PITZmCLhM3GRK63xNc7mTui0WAaHJ+XVCvqlRV4wLuMtNJQpRV4sz\nez+WbmNnnAq0MF2bGE7+L4uxXXi/OcOuCrk+GWYtXKzgBzFJ2LFkxTOGWgc+XAi+\nvbUrlJPvHfktB1ANPVyqP1jhj+picEn7O1v+4jQt6YxVIyMqJ2ZZ0e9n3SNtOEmg\nj1NXSYgIFtXNcgaW0xuY5DCwrMau5UcEjnxQ4mTtoCtFM9GzERD0FGYja3OPUGxv\nfXt3xLjKhTLGVnWOCfXfPzx19dPbNrIh0aYEdK7EBm+QzV4gyNdcPKJYCRwvqLDa\nGHmRR4M8Pz6qH+peks9FS02yqExv1bmMjo9maHD/9CNr6wJuj+Wvh+S9uKLcijOl\nfBpdb50i9qwDhMCFBPJM3x/lU+zudnw3i34dzqnfQtytjMGMuGy4//dHBGMGKSXc\nY+veoqPlODMZ1+4yBqU9Y3tuTDTo1lRQYmzyWMFmmuwTSR6mviB91umqEoW5pFz6\nhRIqqYdo4tYr6raWA50ogiM+S/cyaJ1qCpiZh62jr48xQV4fum2movQkla7ipByC\n+r+sslHc4BV212nbNknpOur4KIXzT1142TEXQf2AY+77EfvZPg9imGVnTa2S1ZXg\nmrEmkh+UvXC9x6SQz7VqNlpxWfU09q4t1eIx6JtBzpgx9JqUQ00=\n=brXm\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/aa15f37fe5ebc644ed7397129b8014056aa7e216",
          "sha": "aa15f37fe5ebc644ed7397129b8014056aa7e216",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/aa15f37fe5ebc644ed7397129b8014056aa7e216"
        }
      ],
      "message": "tests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-07-25T09:13:13Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-11-07T12:18:59Z"
      },
      "sha": "2f554e456a6815ac5618d208b398e458d5b4676f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDcxMDBiMTg2NTVkZWZjY2RhMDczMDUyNzQwYmMwNmE1NTg5Nzg5ZDU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7100b18655defccda073052740bc06a5589789d5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7100b18655defccda073052740bc06a5589789d5",
      "tree": {
        "sha": "3b8b0544942403f45e267ff2b97d76b117b7c251",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/3b8b0544942403f45e267ff2b97d76b117b7c251"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 3b8b0544942403f45e267ff2b97d76b117b7c251\nparent 2f554e456a6815ac5618d208b398e458d5b4676f\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1708644341 +0100\ncommitter josibake <josibake@protonmail.com> 1753434794 +0100\n\nci: enable silentpayments module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiDSqoACgkQity1WMTz\nPWXgfxAAwOlVIz2XTcvTxbruyKznupnSUHuppJsA6kYI+QfTz5B757nEUX5LHfxt\nzNhaxonDV0+5tpgJqkDeLRZmIC6lG4yxdbHSSYfgAKu1Z1mP7f4bdJCS44qi+qfH\nP2qa87le92+OXg/bT6g5FZWWeZnNv1daLb10COUk/zSW9H64MD36HVV0x9fXqmom\n7OPOCHQZwmUvwORFI1hFErtnH/h5Zfye1sQd2UNA2i/Lkxoa/mV4Oz9iRfYDMZtc\n66534qKvzpe4NRSbEK4r1U7HSmG/5O5Ryny5ujmYaCPZHM5o43fzuPTNClvnN6Ly\ndZm1vjQ5T9XVYXeTGfbp97lMiF19YhRXPg4/uKVCGJP/INqA3C5k5Ydars3MwMlr\nUbS5QWEM+Nu4wORSQomd936mTtO3KP9F24oFSvDDE+P8zDxF6/m6f24joFBu7Ice\nTEBPb6ezDIf47tvjROQ1rem7EmmpiahXyMv9AfILdu7EvJ0Riya4cx1TG6C/Zb6h\nU5Gg1GzHDDmuLlXmShPwJnPG2YGKAflpPbVc/BgHGBsdB7N8zaUtfazAdCSUen9U\ncvePcFUeTXmTkt6AFFOrvqCWjVqMjEAY8oSpA+0t67BPX5QSdWNFs38Z2r+DMOQ7\noV65SKD5sSfAls+oS2+Hfl4f+lR45xZF9/f0KC0+YJAMCv0yP1U=\n=/jMx\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/2f554e456a6815ac5618d208b398e458d5b4676f",
          "sha": "2f554e456a6815ac5618d208b398e458d5b4676f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/2f554e456a6815ac5618d208b398e458d5b4676f"
        }
      ],
      "message": "ci: enable silentpayments module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-07-25T09:13:14Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-02-22T23:25:41Z"
      },
      "sha": "7100b18655defccda073052740bc06a5589789d5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDI5NDhhOWJmNjE5YmE5N2EwYWNmMzgwNTZlNmIyNzAwNTQ0OGViYjY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "tree": {
        "sha": "976e2748b31811a91ce3623c81f2e3b7b3eb91a1",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/976e2748b31811a91ce3623c81f2e3b7b3eb91a1"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 976e2748b31811a91ce3623c81f2e3b7b3eb91a1\nparent 7100b18655defccda073052740bc06a5589789d5\nauthor josibake <josibake@protonmail.com> 1720789074 +0200\ncommitter josibake <josibake@protonmail.com> 1753434794 +0100\n\ndocs: update README\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiDSqsACgkQity1WMTz\nPWVJYBAAi8oVOUCHSI/VkBOfKR//y/eNkzHGf3gLsfxp6fBNtTGR8pEKtqqnAoc5\nb7iaxe++TEniAIdK0+cyWuEydMxXBQi/A+GYylcwuIroiDm5lJL6XeyG86RGuwyc\nVoWeAlFPwc6qaUoBV0Wnpd7DQEjthyTtExs22JElrUt+T+fiaMyyDyFS8Urght+z\nd83vSlbzHQbs8QQs63fyr7bvRqm1JDPGT43Qgki5lx5gO5WvAk+wsvSNp0ow2s3I\nM2VIqjxkfQgmOE9i9fkH7UPRLvJii3NCKnAsIPe3iBS+vC3qFGW9lxOcc6xb+z8k\nou9EUG/myftEM3JU2c8qYmBGT/FNvAB2wiKbYoBHvenm+cOvRSX2Td3XUFuxK8ad\nqO/B636MaqLIDOjbYE5d2vna5Hit/8Nbm2drl7Jhb+JOe8Fo7blsUAmrMd0vEuU/\nJ2tT/JHebPcxdqZwTizImH4pluFq0iBmWCsXZm+OqwgnNGx4ADRJVgDuCI+4z5l2\npqN65Q/qSwtrw/na/ZvlxNmagoWVZqJS3Dl0rJ4NLli1yOtiHpmo53bir0NNs94O\n6zH23eJLv98Fz0N470VXjFUts9LaWXt6AR5MVaEiZC77Iyd+SM8eTw6XxHtZD7F3\nMWGF7180UDYJvDJxYpokY0xdmDvX+KIWC2JclvxsGteajTu8jYI=\n=qsKZ\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7100b18655defccda073052740bc06a5589789d5",
          "sha": "7100b18655defccda073052740bc06a5589789d5",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7100b18655defccda073052740bc06a5589789d5"
        }
      ],
      "message": "docs: update README",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-07-25T09:13:14Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-12T12:57:54Z"
      },
      "sha": "2948a9bf619ba97a0acf38056e6b27005448ebb6"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18811001330,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARhORny",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811001330",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "created_at": "2025-07-25T09:16:34Z"
    },
    {
      "event": "commented",
      "id": 3117040572,
      "node_id": "IC_kwDOAP4Jqs65ykO8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3117040572",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:23Z",
      "updated_at": "2025-07-25T09:20:23Z",
      "author_association": "MEMBER",
      "body": "Update [1a84908](https://github.com/bitcoin-core/secp256k1/commit/1a84908cdac60d7313a8d5faee470ce8e2c1c763) -> [2948a9b](https://github.com/bitcoin-core/secp256k1/commit/2948a9bf619ba97a0acf38056e6b27005448ebb6) ([2025_03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_03) -> [2025_04](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_04), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_03..bip352-silentpayments-module-2025_04))\r\n\r\n* Fixed valgrind error in test\r\n* Update the example to use `EXIT_SUCCESS`/`EXIT_FAILURE` (h/t @theStack)\r\n* Clear shared secret variable consistently (and update comment) (h/t @theStack)\r\n* Add comment explaining why we declassify the pubkey sum (h/t @theStack)\r\n\r\nThanks for the thorough review, @theStack !",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3117040572",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18811062137,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARhOgd5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811062137",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:24Z"
    },
    {
      "event": "subscribed",
      "id": 18811062166,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARhOgeW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811062166",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:24Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2197616199",
      "pull_request_review_id": 3005508488,
      "id": 2197616199,
      "node_id": "PRRC_kwDOAP4Jqs6C_PZH",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 342,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": null,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *                label_context: pointer to a label context object (NULL if\r\n *                               labels are not used or context is not needed)\r\n```\r\n\r\n(was changed after https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832632525)",
      "created_at": "2025-07-10T12:37:09Z",
      "updated_at": "2025-07-10T16:26:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2197616199",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2197616199"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2198191851",
      "pull_request_review_id": 3005508488,
      "id": 2198191851,
      "node_id": "PRRC_kwDOAP4Jqs6DBb7r",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 345,
      "original_position": 340,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": null,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think it should be documented for how long the returned pointer from `label_lookup` should be valid. I think it is obvious it should be valid until the next call of `label_lookup`, but it is currently not clear (from the docs) whether it should remain valid until `secp256k1_silentpayments_recipient_scan_outputs` returns.\r\nThe current implementation of `secp256k1_silentpayments_recipient_scan_outputs` does not need this (from looking at the code) and in a safe Rust abstraction for this function ([code](https://github.com/antonilol/rust-secp256k1/commit/2b3f63399df449d39d90cd2292a913d2a20136cb), does contain some outdated comments) suggested for https://github.com/rust-bitcoin/rust-secp256k1/pull/721 (WIP bindings to this pull request's code) I relied on this **not** being a requirement (though that can be changed).\r\n",
      "created_at": "2025-07-10T16:26:31Z",
      "updated_at": "2025-07-10T16:26:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2198191851",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2198191851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 340,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 345,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204412350",
      "pull_request_review_id": 3015616207,
      "id": 2204412350,
      "node_id": "PRRC_kwDOAP4Jqs6DZKm-",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 345,
      "original_position": 340,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hi @antonilol , thanks for the review and bindings code! Agreed that this should be documented. How about something like:\r\n\r\n```diff\r\ndiff --git a/include/secp256k1_silentpayments.h b/include/secp256k1_silentpayments.h\r\nindex 2e71405..11fa596 100644\r\n--- a/include/secp256k1_silentpayments.h\r\n+++ b/include/secp256k1_silentpayments.h\r\n@@ -311,6 +311,11 @@ typedef struct secp256k1_silentpayments_found_output {\r\n  *  the recipient uses labels. This allows for checking if a label exists in\r\n  *  the recipients label cache and retrieving the label tweak during scanning.\r\n  *\r\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\r\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\r\n+ *  valid until the next call to `label_lookup` or until the function returns,\r\n+ *  whichever comes first. It is not retained beyond that.\r\n+ *\r\n  *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\r\n  *  can be used.\r\n  *\r\n  ```\r\n  \r\n  I think the above is the most precise requirement, but perhaps a simpler alternative would be to require that the returned pointer (and labels cache, if used) be valid until `_scan_outputs` returns? You mention you rely on this _not_ being the case today, but does this make a material difference if we _do_ require that the returned pointer and labels cache be valid for the lifetime of the `_scan_outputs` function?",
      "created_at": "2025-07-14T09:53:56Z",
      "updated_at": "2025-07-14T09:53:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204412350",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204412350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 340,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 345,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204418847",
      "pull_request_review_id": 3015624158,
      "id": 2204418847,
      "node_id": "PRRC_kwDOAP4Jqs6DZMMf",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 342,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2197616199,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, I've updated the comment and added a test case for the `(lookup, NULL)` argument combination.",
      "created_at": "2025-07-14T09:55:25Z",
      "updated_at": "2025-07-14T09:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204418847",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204418847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204890211",
      "pull_request_review_id": 3016293957,
      "id": 2204890211,
      "node_id": "PRRC_kwDOAP4Jqs6Da_Rj",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 345,
      "original_position": 340,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Looks good!\r\n\r\n> I think the above is the most precise requirement, but perhaps a simpler alternative would be to require that the returned pointer (and labels cache, if used) be valid until `_scan_outputs` returns? You mention you rely on this _not_ being the case today, but does this make a material difference if we _do_ require that the returned pointer and labels cache be valid for the lifetime of the `_scan_outputs` function?\r\n\r\nThis depends on the function signature on the Rust side, I have considered 2 cases. The difference is in what the user has to return from `label_lookup`.\r\n\r\nFirst, there is the one in the proof of concept binding I mentioned here, the user has to return any byte array of length 32 or nothing (translates to NULL pointer).\r\nThe C side accepts a pointer so the Rust side stores this byte array on the stack and gives the C side a pointer to that. This place on the stack is reused, so requiring that the pointer lives for longer than until the next call of `label_lookup` means that previous return values need to be kept and some dynamic allocation would be needed.\r\nI see this as the easiest for user to use. As far as I can tell no borrow checker issues can arise from this design.\r\n\r\nSecond, the user has to return a reference to a byte array of length 32 or nothing. The reference is required to live for as long as the function runs. This is because in Rust it is not (yet) possible to declare the reference is only required to live until the next call of `label_lookup`.\r\nThis is simple to implement because it is basically a pointer cast and is compatible with `_scan_outputs` needing pointers to be valid for the lifetime of the function.\r\nThis one is harder to use, especially for `label_lookup`s that are not simply looking up in a data structure. Returning a reference to any byte array that is not stored outside the function's stack frame is not allowed and storing it on the fly like the first case here probably requires the user to use unsafe code (needs a data structure that allows adding elements while there exist references to its existing elements because the reference is required to live for as long as the function runs) and has the same need for dynamic allocation like the first case can have.\r\n\r\nThe validity of the context pointer should be completely up to the users of the C library (I consider the Rust binding to also be a user of the C library).\r\n\r\nI will also link this discussion in the Rust bindings pull request.",
      "created_at": "2025-07-14T13:00:14Z",
      "updated_at": "2025-07-14T13:00:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204890211",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204890211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 340,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 345,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2205138710",
      "pull_request_review_id": 3016682153,
      "id": 2205138710,
      "node_id": "PRRC_kwDOAP4Jqs6Db78W",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 345,
      "original_position": 340,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for the detailed explanation! As I was thinking through this, it also occurred to me requiring the pointers to be valid for the lifetime of `_scan_outputs` would require keeping around pointers to every label found, even after they had been used by `_scan_outputs`. This seems undesirable, e.g., imagine a transaction with ~15k labeled outputs all paying to a single recipient. Your explanation seems to confirm my understanding.",
      "created_at": "2025-07-14T14:50:29Z",
      "updated_at": "2025-07-14T14:50:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2205138710",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2205138710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 340,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 345,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219105417",
      "pull_request_review_id": 3037944552,
      "id": 2219105417,
      "node_id": "PRRC_kwDOAP4Jqs6ERNyJ",
      "diff_hunk": "@@ -263,5 +286,61 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n         CHECK(ret == 1);\n     }\n \n+#endif\n+\n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    SECP256K1_CHECKMEM_DEFINE(key, 32);\n+\n+    generated_outputs[0] = &generated_output;\n+\n+    /* Initialize recipient */\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.scan_pubkey, key));\n+    key[31] ^= 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.labeled_spend_pubkey, key));\n+    key[31] ^= (1 << 1);\n+    recipient.index = 0;\n+    recipients[0] = &recipient;\n+\n+    /* Set up secret keys */\n+    SECP256K1_CHECKMEM_UNDEFINE(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &taproot_seckey, key);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret);\n+    key[31] ^= (1 << 2);\n+    taproot_seckeys[0] = &taproot_seckey;\n+    plain_seckeys[0] = key;\n+\n+    ret = secp256k1_silentpayments_sender_create_outputs(ctx, generated_outputs, recipients, 1, outpoint_smallest, taproot_seckeys, 1, plain_seckeys, 1);\n+    CHECK(ret == 1);\n+\n+    /* TODO: use non-confusing public key */\n+    ret = secp256k1_silentpayments_recipient_create_label(ctx, &recipient.labeled_spend_pubkey, label_tweak, key, 0);\n+    key[31] ^= (1 << 3);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey, NULL, &taproot_seckey));\n+    SECP256K1_CHECKMEM_DEFINE(&xonly_pubkey, sizeof(xonly_pubkey));\n+    xonly_pubkeys[0] = &xonly_pubkey;\n+    ret = secp256k1_ec_pubkey_create(ctx, &plain_pubkey, plain_seckeys[0]);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+    SECP256K1_CHECKMEM_DEFINE(&plain_pubkey, sizeof(plain_pubkey));\n+    plain_pubkeys[0] = &plain_pubkey;\n+\n+    ret = secp256k1_silentpayments_recipient_public_data_create(ctx, &public_data, outpoint_smallest, xonly_pubkeys, 1, plain_pubkeys, 1);\n+    CHECK(ret == 1);\n+\n+    tx_outputs[0] = generated_outputs[0];\n+    n_found_outputs = 1;\n+    SECP256K1_CHECKMEM_DEFINE(&recipient.labeled_spend_pubkey, sizeof(recipient.labeled_spend_pubkey));\n+    /* TODO: make sure we're actually go through all relevant code paths */\n+    ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\n+    CHECK(ret == 1);\n+\n+    /* TODO: this fails */\n+    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\n+    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */",
      "path": "src/ctime_tests.c",
      "position": null,
      "original_position": 95,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit de508a78ac66b93b0ff83b419cc6e149950ecc25: took a look into these TODOs, I think the following patch would tackle them (note that the serialize/parse-roundtrip looks superfluous at first sight, but it is needed to set the \"combined\" flag in the public data, which is ARG_CHECKEDed for 1 in _recipient_create_shared_secret):\r\n```diff\r\ndiff --git a/src/ctime_tests.c b/src/ctime_tests.c\r\nindex 17964b9..83596a3 100644\r\n--- a/src/ctime_tests.c\r\n+++ b/src/ctime_tests.c\r\n@@ -116,6 +116,8 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\r\n     const secp256k1_xonly_pubkey *xonly_pubkeys[1];\r\n     secp256k1_pubkey plain_pubkey;\r\n     const secp256k1_pubkey *plain_pubkeys[1];\r\n+    unsigned char public_data_ser[33] = { 0 };\r\n+    unsigned char shared_secret[33] = { 0 };\r\n #endif\r\n \r\n     for (i = 0; i < 32; i++) {\r\n@@ -338,9 +340,10 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\r\n     ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\r\n     CHECK(ret == 1);\r\n \r\n-    /* TODO: this fails */\r\n-    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\r\n-    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */\r\n+    CHECK(secp256k1_silentpayments_recipient_public_data_serialize(ctx, public_data_ser, &public_data));\r\n+    CHECK(secp256k1_silentpayments_recipient_public_data_parse(ctx, &public_data, public_data_ser));\r\n+    CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data));\r\n+    CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(ctx, &xonly_pubkey, shared_secret, &recipient.labeled_spend_pubkey, 0));\r\n \r\n #endif\r\n }\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\nindex 3fc42f5..7d3ad41 100644\r\n--- a/src/modules/silentpayments/main_impl.h\r\n+++ b/src/modules/silentpayments/main_impl.h\r\n@@ -708,6 +708,7 @@ int secp256k1_silentpayments_recipient_create_shared_secret(const secp256k1_cont\r\n     ret &= secp256k1_scalar_set_b32_seckey(&rsk, recipient_scan_key32);\r\n     ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_tweaked_ge, public_data);\r\n     /* If there are any issues with the recipient scan key or public data, return early */\r\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\r\n     if (!ret) {\r\n         return 0;\r\n     }\r\n```",
      "created_at": "2025-07-21T12:45:14Z",
      "updated_at": "2025-07-21T12:45:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2219105417",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219105417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219368126",
      "pull_request_review_id": 3038350839,
      "id": 2219368126,
      "node_id": "PRRC_kwDOAP4Jqs6ESN6-",
      "diff_hunk": "@@ -263,5 +286,61 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n         CHECK(ret == 1);\n     }\n \n+#endif\n+\n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    SECP256K1_CHECKMEM_DEFINE(key, 32);\n+\n+    generated_outputs[0] = &generated_output;\n+\n+    /* Initialize recipient */\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.scan_pubkey, key));\n+    key[31] ^= 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.labeled_spend_pubkey, key));\n+    key[31] ^= (1 << 1);\n+    recipient.index = 0;\n+    recipients[0] = &recipient;\n+\n+    /* Set up secret keys */\n+    SECP256K1_CHECKMEM_UNDEFINE(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &taproot_seckey, key);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret);\n+    key[31] ^= (1 << 2);\n+    taproot_seckeys[0] = &taproot_seckey;\n+    plain_seckeys[0] = key;\n+\n+    ret = secp256k1_silentpayments_sender_create_outputs(ctx, generated_outputs, recipients, 1, outpoint_smallest, taproot_seckeys, 1, plain_seckeys, 1);\n+    CHECK(ret == 1);\n+\n+    /* TODO: use non-confusing public key */\n+    ret = secp256k1_silentpayments_recipient_create_label(ctx, &recipient.labeled_spend_pubkey, label_tweak, key, 0);\n+    key[31] ^= (1 << 3);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey, NULL, &taproot_seckey));\n+    SECP256K1_CHECKMEM_DEFINE(&xonly_pubkey, sizeof(xonly_pubkey));\n+    xonly_pubkeys[0] = &xonly_pubkey;\n+    ret = secp256k1_ec_pubkey_create(ctx, &plain_pubkey, plain_seckeys[0]);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+    SECP256K1_CHECKMEM_DEFINE(&plain_pubkey, sizeof(plain_pubkey));\n+    plain_pubkeys[0] = &plain_pubkey;\n+\n+    ret = secp256k1_silentpayments_recipient_public_data_create(ctx, &public_data, outpoint_smallest, xonly_pubkeys, 1, plain_pubkeys, 1);\n+    CHECK(ret == 1);\n+\n+    tx_outputs[0] = generated_outputs[0];\n+    n_found_outputs = 1;\n+    SECP256K1_CHECKMEM_DEFINE(&recipient.labeled_spend_pubkey, sizeof(recipient.labeled_spend_pubkey));\n+    /* TODO: make sure we're actually go through all relevant code paths */\n+    ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\n+    CHECK(ret == 1);\n+\n+    /* TODO: this fails */\n+    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\n+    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */",
      "path": "src/ctime_tests.c",
      "position": null,
      "original_position": 95,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "in_reply_to_id": 2219105417,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for the patch! I've updated the ctime tests to use this, and also removed the remaining TODOs from the test file (with comments where appropriate).",
      "created_at": "2025-07-21T14:18:16Z",
      "updated_at": "2025-07-21T14:18:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2219368126",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219368126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2225857523",
      "pull_request_review_id": 3047815175,
      "id": 2225857523,
      "node_id": "PRRC_kwDOAP4Jqs6Eq-Pz",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 896e0af2f883d21ba3540290f176dcaa7f57272d: As for those TODOs, probably the safest option is to return an error if `_pubkey_tweak_add` indeed fails? Initially I assumed that doing that would introduce a branch that can't be tested in practice, but I think it is: by picking arbitrary `shared_secret33` and `k` values, and calculating `recipient_labeled_spend_pubkey` as `-G^(_create_t_k(shared_secret33, k))` the tweaking should fail with these three values. Will try to come up with some test code later to verify.",
      "created_at": "2025-07-23T14:51:40Z",
      "updated_at": "2025-07-23T14:51:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2225857523",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2225857523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2226200883",
      "pull_request_review_id": 3048350883,
      "id": 2226200883,
      "node_id": "PRRC_kwDOAP4Jqs6EsSEz",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, managed to come up with a test that makes the VERIFY_CHECK on the `_pubkey_tweak_add` return value fail:\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/tests_impl.h b/src/modules/silentpayments/tests_impl.h\r\nindex a1acab7..2a10791 100644\r\n--- a/src/modules/silentpayments/tests_impl.h\r\n+++ b/src/modules/silentpayments/tests_impl.h\r\n@@ -367,6 +367,23 @@ static void test_recipient_api(void) {\r\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_output_pubkey(CTX, &t, NULL, &p, 0));\r\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_output_pubkey(CTX, &t, o, NULL, 0));\r\n \r\n+    /* check the _recipient_create_output_pubkey cornercase where internal tweaking would fail;\r\n+       this is the case if the recipient spend public key is P = -(create_t_k(shared_secret, k))*G */\r\n+    {\r\n+        const unsigned char *shared_secret = o;\r\n+        const uint32_t k = 0;\r\n+        secp256k1_scalar t_k;\r\n+        unsigned char t_k_ser[32];\r\n+        secp256k1_pubkey fake_spend_pubkey;\r\n+        secp256k1_xonly_pubkey output_xonly;\r\n+\r\n+        secp256k1_silentpayments_create_t_k(&t_k, shared_secret, k);\r\n+        secp256k1_scalar_get_b32(t_k_ser, &t_k);\r\n+        CHECK(secp256k1_ec_pubkey_create(CTX, &fake_spend_pubkey, t_k_ser));\r\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &fake_spend_pubkey));\r\n+        CHECK(secp256k1_silentpayments_create_output_pubkey(CTX, &output_xonly, shared_secret, &fake_spend_pubkey, k) == 0);\r\n+    }\r\n+\r\n     n_f = 0;\r\n     labels_cache.entries_used = 0;\r\n     CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, &labels_cache));\r\n```\r\n</details>\r\n\r\nI assume that in practice a user can't be tricked into such a scenario though, as the recipient spend public key is known/generated before the shared secret is.",
      "created_at": "2025-07-23T17:14:12Z",
      "updated_at": "2025-07-23T17:14:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2226200883",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2226200883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2228336402",
      "pull_request_review_id": 3051391771,
      "id": 2228336402,
      "node_id": "PRRC_kwDOAP4Jqs6E0bcS",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Awesome! IIRC, the initial hesitance to returning a value was adding an untestable branch in the code. But considering this can be exercised in a test (which indicates its not inconceivable that someone could be tricked into calling this function with a maliciously crafted spend pubkey), I removed the VERIFY_CHECK in favour of returning the value and added your test case. Thanks for working on this!",
      "created_at": "2025-07-24T12:10:33Z",
      "updated_at": "2025-07-24T12:10:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2228336402",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2228336402"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229570600",
      "pull_request_review_id": 3053302400,
      "id": 2229570600,
      "node_id": "PRRC_kwDOAP4Jqs6E5Iwo",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 246,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Suggestion for the comment to tackle another TODO 🔫  (IIUC, the non-constant timing of group element serialization seems to ultimately be caused by [variable-time normalization of field elements](https://github.com/bitcoin-core/secp256k1/blob/b9313c6e1a6082a66b4c75777e18ca4b176fcf9d/src/eckey_impl.h#L44-L45)):\r\n```suggestion\r\n    /* Need to declassify the pubkey sum because serializing a group element (done in the\r\n       `_calculate_input_hash` call following) is not a constant-time operation */\r\n    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\r\n```",
      "created_at": "2025-07-24T21:04:03Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229570600",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229570600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 249,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229577936",
      "pull_request_review_id": 3053302400,
      "id": 2229577936,
      "node_id": "PRRC_kwDOAP4Jqs6E5KjQ",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 141,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "only noticing now that in one of my [earlier comments](https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2225857523) I was using multiplicative notation (cryptocamp leaving its marks already I guess 😁)\r\n```suggestion\r\n     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\r\n```",
      "created_at": "2025-07-24T21:07:46Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229577936",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229577936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229609301",
      "pull_request_review_id": 3053302400,
      "id": 2229609301,
      "node_id": "PRRC_kwDOAP4Jqs6E5SNV",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 282,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should also memclear the shared secret here and in the error path a few lines above (admitedly a bit annoying though that this leads to so much code duplication :/)",
      "created_at": "2025-07-24T21:22:37Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229609301",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229609301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 285,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229624153",
      "pull_request_review_id": 3053302400,
      "id": 2229624153,
      "node_id": "PRRC_kwDOAP4Jqs6E5V1Z",
      "diff_hunk": "@@ -0,0 +1,618 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 151,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "72489a733c81153782eba2e4dded316dccc55c99",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could update the `main` return values in the example to use `EXIT_FAILURE`/`EXIT_SUCCESS` (done for other examples in #1654)",
      "created_at": "2025-07-24T21:32:44Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229624153",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229624153"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230327932",
      "pull_request_review_id": 3054340559,
      "id": 2230327932,
      "node_id": "PRRC_kwDOAP4Jqs6E8Bp8",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 141,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229577936,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was about to ask what this strange \"`-`\" symbol in `-G^(_create_t_k(shared_secret33, k))` is supposed to mean. :stuck_out_tongue:  ",
      "created_at": "2025-07-25T07:04:44Z",
      "updated_at": "2025-07-25T07:04:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230327932",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230327932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230609936",
      "pull_request_review_id": 3054721891,
      "id": 2230609936,
      "node_id": "PRRC_kwDOAP4Jqs6E9GgQ",
      "diff_hunk": "@@ -0,0 +1,618 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 151,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "72489a733c81153782eba2e4dded316dccc55c99",
      "in_reply_to_id": 2229624153,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-07-25T09:20:32Z",
      "updated_at": "2025-07-25T09:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230609936",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230609936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230612333",
      "pull_request_review_id": 3054725418,
      "id": 2230612333,
      "node_id": "PRRC_kwDOAP4Jqs6E9HFt",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 282,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229609301,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, also slightly reworded the comment. Overall, while slightly annoying, the code duplication doesn't seem too bad to me and I don't see a clever way to DRY it up.",
      "created_at": "2025-07-25T09:21:26Z",
      "updated_at": "2025-07-25T09:21:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230612333",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230612333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 285,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230613364",
      "pull_request_review_id": 3054726664,
      "id": 2230613364,
      "node_id": "PRRC_kwDOAP4Jqs6E9HV0",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 141,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229577936,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Team additive 💪 ",
      "created_at": "2025-07-25T09:21:56Z",
      "updated_at": "2025-07-25T09:21:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230613364",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230613364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230614608",
      "pull_request_review_id": 3054728553,
      "id": 2230614608,
      "node_id": "PRRC_kwDOAP4Jqs6E9HpQ",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 246,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229570600,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for digging into this! Added the comment with some slight formatting changes.",
      "created_at": "2025-07-25T09:22:25Z",
      "updated_at": "2025-07-25T09:22:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230614608",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230614608"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 249,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230617988",
      "pull_request_review_id": 3054733915,
      "id": 2230617988,
      "node_id": "PRRC_kwDOAP4Jqs6E9IeE",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated this to actually calculate the shared secret from the public data object, to make valgrind happy.",
      "created_at": "2025-07-25T09:23:51Z",
      "updated_at": "2025-07-25T09:23:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230617988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230617988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    }
  ]
}