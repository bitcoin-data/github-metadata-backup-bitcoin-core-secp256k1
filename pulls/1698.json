{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698",
    "id": 2655159183,
    "node_id": "PR_kwDOAP4Jqs6eQoOP",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1698.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1698.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/99aef9204636f04cf689d13eeb365f4f2e3a1568",
    "number": 1698,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add BIP352 module (take 3)",
    "user": {
      "login": "josibake",
      "id": 7444140,
      "node_id": "MDQ6VXNlcjc0NDQxNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/josibake",
      "html_url": "https://github.com/josibake",
      "followers_url": "https://api.github.com/users/josibake/followers",
      "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
      "organizations_url": "https://api.github.com/users/josibake/orgs",
      "repos_url": "https://api.github.com/users/josibake/repos",
      "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/josibake/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This PR implements [BIP352 - Silent payments](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki). It is recommended to read through the BIP before reviewing this PR.\r\n\r\nThis is a continuation of the work in https://github.com/bitcoin-core/secp256k1/pull/1519 and only opened as a new PR due to the comment history on #1519 becoming quite long and difficult to sift through. It is recommended reviewers go through #1519 for background context, if interested.",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "created_at": "2025-07-10T08:53:21Z",
    "updated_at": "2025-08-20T08:54:41Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merged": false,
    "merge_commit_sha": "c1748a42de0490d606f97331b5aa0736eb7e3331",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "josibake:bip352-silentpayments-module-2025",
      "ref": "bip352-silentpayments-module-2025",
      "sha": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 751433786,
        "node_id": "R_kgDOLMn4Og",
        "name": "secp256k1",
        "full_name": "josibake/secp256k1",
        "owner": {
          "login": "josibake",
          "id": 7444140,
          "node_id": "MDQ6VXNlcjc0NDQxNDA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/josibake",
          "html_url": "https://github.com/josibake",
          "followers_url": "https://api.github.com/users/josibake/followers",
          "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
          "organizations_url": "https://api.github.com/users/josibake/orgs",
          "repos_url": "https://api.github.com/users/josibake/repos",
          "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/josibake/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/josibake/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/josibake/secp256k1",
        "archive_url": "https://api.github.com/repos/josibake/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/josibake/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/josibake/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/josibake/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/josibake/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/josibake/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/josibake/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/josibake/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/josibake/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/josibake/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/josibake/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/josibake/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/josibake/secp256k1/events",
        "forks_url": "https://api.github.com/repos/josibake/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/josibake/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/josibake/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/josibake/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/josibake/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/josibake/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/josibake/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/josibake/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/josibake/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/josibake/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/josibake/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/josibake/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/josibake/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/josibake/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/josibake/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/josibake/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:josibake/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/josibake/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/josibake/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/josibake/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/josibake/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/josibake/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/josibake/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/josibake/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/josibake/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/josibake/secp256k1/hooks",
        "svn_url": "https://github.com/josibake/secp256k1",
        "language": "C",
        "forks_count": 1,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 13508,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-08-20T08:15:56Z",
        "created_at": "2024-02-01T15:52:50Z",
        "updated_at": "2025-08-15T08:25:19Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "d599714147b20dda092ec4af44ef4174d584bb7d",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1075,
        "stargazers_count": 2291,
        "watchers_count": 2291,
        "size": 12615,
        "default_branch": "master",
        "open_issues_count": 154,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-08-18T13:28:34Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2025-08-18T16:20:24Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 10130,
    "deletions": 41,
    "changed_files": 26,
    "commits": 12,
    "review_comments": 100,
    "comments": 19
  },
  "events": [
    {
      "event": "reviewed",
      "id": 3005508488,
      "node_id": "PRR_kwDOAP4Jqs6zJGuI",
      "url": null,
      "actor": null,
      "commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-10T16:26:57Z",
      "author_association": "NONE",
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3005508488",
      "submitted_at": "2025-07-10T16:26:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18619898506,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARV1RqK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18619898506",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9e85256bbe527bf084222ee08dade9ea497d5c99",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/9e85256bbe527bf084222ee08dade9ea497d5c99",
      "created_at": "2025-07-14T14:54:07Z"
    },
    {
      "event": "commented",
      "id": 3069942270,
      "node_id": "IC_kwDOAP4Jqs62-5n-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3069942270",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:20Z",
      "updated_at": "2025-07-14T15:04:20Z",
      "author_association": "MEMBER",
      "body": "Updated [6264c3d](https://github.com/bitcoin-core/secp256k1/commit/6264c3d0939f2ab11ba8c92f3cb521f9c89c8596) -> [9e85256](https://github.com/bitcoin-core/secp256k1/commit/9e85256bbe527bf084222ee08dade9ea497d5c99) ([2025_00](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_00) -> [2025_01](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_01), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_00..bip352-silentpayments-module-2025_01))\r\n\r\n* Added documentation for expectations around `label_lookup` pointer lifetimes (h/t @antonilol)\r\n* Update docs to accurately reflect that `label_context` is optional (h/t @antonilol)\r\n* Added a test case for passing a lookup callback with a null context (which required some small updates to the test label lookup function)",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3069942270",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18620089953,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARV2AZh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18620089953",
      "actor": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:20Z"
    },
    {
      "event": "subscribed",
      "id": 18620089990,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARV2AaG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18620089990",
      "actor": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:21Z"
    },
    {
      "event": "reviewed",
      "id": 3037944552,
      "node_id": "PRR_kwDOAP4Jqs61E1ro",
      "url": null,
      "actor": null,
      "commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-21T12:45:15Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3037944552",
      "submitted_at": "2025-07-21T12:45:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18729968570,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARcZKO6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18729968570",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a4db27946b6bdf165095348543e44d7cc4e45e1c",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/a4db27946b6bdf165095348543e44d7cc4e45e1c",
      "created_at": "2025-07-21T14:09:02Z"
    },
    {
      "event": "commented",
      "id": 3096975105,
      "node_id": "IC_kwDOAP4Jqs64mBcB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3096975105",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:15:58Z",
      "updated_at": "2025-07-21T14:15:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "Sorry, stopping CI here. We're about to make a release and need to the CI. :)\r\n\r\nWe'll restart the jobs here afterwards.  ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3096975105",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "commented",
      "id": 3096996582,
      "node_id": "IC_kwDOAP4Jqs64mGrm",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3096996582",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:51Z",
      "updated_at": "2025-07-21T14:21:51Z",
      "author_association": "MEMBER",
      "body": "Update [9e85256](https://github.com/bitcoin-core/secp256k1/commit/9e85256bbe527bf084222ee08dade9ea497d5c99) -> [a4db279](https://github.com/bitcoin-core/secp256k1/commit/a4db27946b6bdf165095348543e44d7cc4e45e1c) ([2025_01](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_01) -> [2025_02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_01..bip352-silentpayments-module-2025_02))\r\n\r\n* Update the constant time tests to cover the `_recipient_created_shared_secret` and `_recipient_created_output_pubkey` functions (h/t @theStack )\r\n* Remove no longer needed TODO comments and clarify why a constant time test without a label lookup function is sufficient for `_recipient_scan_outputs`",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3096996582",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18730266172,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARcaS48",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18730266172",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:52Z"
    },
    {
      "event": "subscribed",
      "id": 18730266200,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARcaS5Y",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18730266200",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18749002077,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARdhxFd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18749002077",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e35bedeca6318011afbd59bba6f412a85c33e134",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/e35bedeca6318011afbd59bba6f412a85c33e134",
      "created_at": "2025-07-22T10:27:59Z"
    },
    {
      "event": "commented",
      "id": 3102130501,
      "node_id": "IC_kwDOAP4Jqs645sFF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3102130501",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-22T10:29:47Z",
      "updated_at": "2025-07-22T10:29:47Z",
      "author_association": "MEMBER",
      "body": "Rebased on top of 0.7.0 release :tada: [a4db279](https://github.com/bitcoin-core/secp256k1/commit/a4db27946b6bdf165095348543e44d7cc4e45e1c) -> [e35bede](https://github.com/bitcoin-core/secp256k1/commit/e35bedeca6318011afbd59bba6f412a85c33e134) ([2025_02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02) -> [2025_02_rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02_rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_02..bip352-silentpayments-module-2025_02_rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3102130501",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "commented",
      "id": 3102274260,
      "node_id": "IC_kwDOAP4Jqs646PLU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3102274260",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-22T11:13:33Z",
      "updated_at": "2025-07-22T11:13:33Z",
      "author_association": "MEMBER",
      "body": "I did a deep dive on using `(*arg)[size]` in this PR and opened https://github.com/bitcoin-core/secp256k1/issues/1710 for discussion, since this is a broader topic than just this PR. The relevant changes for here and the downstream Bitcoin Core PRs are https://github.com/josibake/secp256k1/commit/5a1088066b2ce5e2e77b4e4bc190575d1171c374 and https://github.com/josibake/bitcoin/commit/5835d987477fc8eae391e4d1cc5033d921925ea1",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3102274260",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "labeled",
      "id": 18768558526,
      "node_id": "LE_lADOAP4Jqs6_1gh3zwAAAAResXm-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18768558526",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-23T08:17:16Z",
      "label": {
        "name": "feature",
        "color": "731E95"
      }
    },
    {
      "event": "reviewed",
      "id": 3047815175,
      "node_id": "PRR_kwDOAP4Jqs61qfgH",
      "url": null,
      "actor": null,
      "commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-23T14:51:40Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3047815175",
      "submitted_at": "2025-07-23T14:51:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18794190282,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARgOJXK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794190282",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "created_at": "2025-07-24T12:18:04Z"
    },
    {
      "event": "commented",
      "id": 3113267037,
      "node_id": "IC_kwDOAP4Jqs65kK9d",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3113267037",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:16Z",
      "updated_at": "2025-07-24T12:23:16Z",
      "author_association": "MEMBER",
      "body": "Updated [e35bede](https://github.com/bitcoin-core/secp256k1/commit/e35bedeca6318011afbd59bba6f412a85c33e134) -> [1a84908](https://github.com/bitcoin-core/secp256k1/commit/1a84908cdac60d7313a8d5faee470ce8e2c1c763) ([2025_02_rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02_rebase) -> [2025_03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_03), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_02_rebase..bip352-silentpayments-module-2025_03))\r\n\r\n* Added a test case for the `_recipient_create_output_pubkey` corner case (h/t @theStack)\r\n* Removed the `VERIFY_CHECK` in favour of returning an error",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3113267037",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18794275408,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARgOeJQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794275408",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:17Z"
    },
    {
      "event": "subscribed",
      "id": 18794275428,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARgOeJk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794275428",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:17Z"
    },
    {
      "event": "reviewed",
      "id": 3053302400,
      "node_id": "PRR_kwDOAP4Jqs61_bKA",
      "url": null,
      "actor": null,
      "commit_id": "1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-24T21:35:51Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3053302400",
      "submitted_at": "2025-07-24T21:35:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18811001330,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARhORny",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811001330",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "created_at": "2025-07-25T09:16:34Z"
    },
    {
      "event": "commented",
      "id": 3117040572,
      "node_id": "IC_kwDOAP4Jqs65ykO8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3117040572",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:23Z",
      "updated_at": "2025-07-25T09:20:23Z",
      "author_association": "MEMBER",
      "body": "Update [1a84908](https://github.com/bitcoin-core/secp256k1/commit/1a84908cdac60d7313a8d5faee470ce8e2c1c763) -> [2948a9b](https://github.com/bitcoin-core/secp256k1/commit/2948a9bf619ba97a0acf38056e6b27005448ebb6) ([2025_03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_03) -> [2025_04](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_04), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_03..bip352-silentpayments-module-2025_04))\r\n\r\n* Fixed valgrind error in test\r\n* Update the example to use `EXIT_SUCCESS`/`EXIT_FAILURE` (h/t @theStack)\r\n* Clear shared secret variable consistently (and update comment) (h/t @theStack)\r\n* Add comment explaining why we declassify the pubkey sum (h/t @theStack)\r\n\r\nThanks for the thorough review, @theStack !",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3117040572",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18811062137,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARhOgd5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811062137",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:24Z"
    },
    {
      "event": "subscribed",
      "id": 18811062166,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARhOgeW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811062166",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18815902894,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARhg-Su",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18815902894",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "64ecd6c01d394fbdd8902a5d7f3f297a76d5f570",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/64ecd6c01d394fbdd8902a5d7f3f297a76d5f570",
      "created_at": "2025-07-25T14:25:54Z"
    },
    {
      "event": "commented",
      "id": 3118116695,
      "node_id": "IC_kwDOAP4Jqs652q9X",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3118116695",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:30Z",
      "updated_at": "2025-07-25T14:33:30Z",
      "author_association": "MEMBER",
      "body": "Update [2948a9b](https://github.com/bitcoin-core/secp256k1/commit/2948a9bf619ba97a0acf38056e6b27005448ebb6) -> [64ecd6c](https://github.com/bitcoin-core/secp256k1/commit/64ecd6c01d394fbdd8902a5d7f3f297a76d5f570) ([2025_04](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_04) -> [2025_05](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_05), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_04..bip352-silentpayments-module-2025_05))\r\n* Remove no longer needed TODO comment regarding `_cmov`\r\n* Remove todo comment regarding `input_hash`, now that this is [properly specified](https://github.com/bitcoin/bips/pull/1902) in the BIP\r\n\r\ncc @jonasnick and @real-or-random regarding the use of a `VERIFY_CHECK` in favour of returning an error, when returning an error results in an untestable branch. I'm happy with the approach here were we use a `VERIFY_CHECK` for `input_hash` and `t_k` to check for an overflow of the curve order. However, given this is something we've discussed a few times in the post, would be great to hear your thoughts on this and I'm happy to defer to whatever you both think is best.\r\n\r\nThis should address all of the outstanding TODOs (at least the ones we left comments for  )",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3118116695",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18816034806,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARhhef2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034806",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "subscribed",
      "id": 18816034824,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARhhegI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034824",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "mentioned",
      "id": 18816034846,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARhhege",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034846",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "subscribed",
      "id": 18816034872,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARhheg4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034872",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "reviewed",
      "id": 3062729343,
      "node_id": "PRR_kwDOAP4Jqs62jYp_",
      "url": null,
      "actor": null,
      "commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-28T13:27:28Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3062729343",
      "submitted_at": "2025-07-28T13:27:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18861898456,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARkQbrY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18861898456",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3c4af8fee015bb8b10f53ae560d83ab51738b838",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/3c4af8fee015bb8b10f53ae560d83ab51738b838",
      "created_at": "2025-07-28T18:01:49Z"
    },
    {
      "event": "commented",
      "id": 3128406259,
      "node_id": "IC_kwDOAP4Jqs66d7Dz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3128406259",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T18:06:21Z",
      "updated_at": "2025-07-28T18:06:21Z",
      "author_association": "MEMBER",
      "body": "Updated [64ecd6c](https://github.com/bitcoin-core/secp256k1/commit/64ecd6c01d394fbdd8902a5d7f3f297a76d5f570) -> [3c4af8f](https://github.com/bitcoin-core/secp256k1/commit/3c4af8fee015bb8b10f53ae560d83ab51738b838) ([2025_05](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_05) -> [2025_06](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_06), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_05..bip352-silentpayments-module-2025_06))\r\n\r\n* Updates the benchmarks per @theStack 's suggestion to have separate benchmarks for `_full_scan` and `full_scan_with_labels`\r\n* Leave a TODO comment for a follow-up to make the labels benchmark more representative of real world usage\r\n* Cleans up the benchmark arguments and formatting",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3128406259",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18861996956,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARkQzuc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18861996956",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T18:06:22Z"
    },
    {
      "event": "subscribed",
      "id": 18861996990,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARkQzu-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18861996990",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T18:06:22Z"
    },
    {
      "event": "reviewed",
      "id": 3073577403,
      "node_id": "PRR_kwDOAP4Jqs63MxG7",
      "url": null,
      "actor": null,
      "commit_id": "3c4af8fee015bb8b10f53ae560d83ab51738b838",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-30T23:49:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "In the CI commit, could add the silent payments module also to the native macOS arm64 job (as done for musig recently in #1699), e.g.\r\n\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml\r\nindex 8ee13ce..f612a84 100644\r\n--- a/.github/workflows/ci.yml\r\n+++ b/.github/workflows/ci.yml\r\n@@ -583,13 +583,13 @@ jobs:\r\n       fail-fast: false\r\n       matrix:\r\n         env_vars:\r\n-          - { WIDEMUL: 'int64',  RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes' }\r\n+          - { WIDEMUL: 'int64',  RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes' }\r\n           - { WIDEMUL: 'int128_struct', ECMULTGENPRECISION: 2, ECMULTWINDOW: 4 }\r\n-          - { WIDEMUL: 'int128',                  ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes' }\r\n+          - { WIDEMUL: 'int128',                  ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes' }\r\n           - { WIDEMUL: 'int128', RECOVERY: 'yes' }\r\n-          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes' }\r\n-          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', CC: 'gcc' }\r\n-          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', CPPFLAGS: '-DVERIFY' }\r\n+          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes' }\r\n+          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes', CC: 'gcc' }\r\n+          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes', CPPFLAGS: '-DVERIFY' }\r\n           - BUILD: 'distcheck'\r\n \r\n     steps:\r\n\r\n```\r\n</details>\r\n(untested)",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3073577403",
      "submitted_at": "2025-07-30T23:49:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18915784215,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARnd_YX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18915784215",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "eb32d06a936307fcce649cf8002e49e6f8730948",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/eb32d06a936307fcce649cf8002e49e6f8730948",
      "created_at": "2025-07-31T09:51:58Z"
    },
    {
      "event": "commented",
      "id": 3139313124,
      "node_id": "IC_kwDOAP4Jqs67Hh3k",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3139313124",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-31T10:04:11Z",
      "updated_at": "2025-07-31T10:04:11Z",
      "author_association": "MEMBER",
      "body": "Updated [3c4af8f](https://github.com/bitcoin-core/secp256k1/commit/3c4af8fee015bb8b10f53ae560d83ab51738b838) -> [eb32d06](https://github.com/bitcoin-core/secp256k1/commit/eb32d06a936307fcce649cf8002e49e6f8730948) ([2025_06](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_06) -> [2025_07](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_07), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_06..bip352-silentpayments-module-2025_07))\r\n\r\n* Enable macOS arm64 jobs in the CI (h/t @theStack)\r\n* Fix return value in the example (h/t @theStack)\r\n* Improve test coverage (100% function and branch coverage )\r\n* Simplify public data functions\r\n\r\nWhile working through the test coverage, I realised the two public data internal functions `public_data_load_pubkey` and `public_data_load_input_hash` are unnecessary, as they were just thin wrappers around secp256k1 function calls that never return an error.\r\n\r\nI've removed those functions and instead ensured we always check a public data object for correctness before accessing the internals.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3139313124",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18915995135,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARney3_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18915995135",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-31T10:04:12Z"
    },
    {
      "event": "subscribed",
      "id": 18915995173,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARney4l",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18915995173",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-31T10:04:13Z"
    },
    {
      "event": "reviewed",
      "id": 3075428613,
      "node_id": "PRR_kwDOAP4Jqs63T1EF",
      "url": null,
      "actor": null,
      "commit_id": "eb32d06a936307fcce649cf8002e49e6f8730948",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-31T15:31:13Z",
      "author_association": "MEMBER",
      "body": "Reviewed eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_ again and it looks good to me (not a C expert). Comments mainly about documentation and one variable name suggestion.\r\n\r\nIt could make sense to split  993d34b7ae3d4a8b6d3a8957b309b38e7e50e796 _tests: add BIP-352 test vectors_ and move the send-side tests directly after this commit. Ditto for the send example in ce7cb982d4aceefd8bb8591fd069c3a0b81d1ef2 _silentpayments: add examples/silentpayments.c_.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3075428613",
      "submitted_at": "2025-07-31T15:24:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18936863463,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARouZrn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18936863463",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "created_at": "2025-08-01T10:29:26Z"
    },
    {
      "event": "commented",
      "id": 3144097162,
      "node_id": "IC_kwDOAP4Jqs67Zx2K",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3144097162",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:34:46Z",
      "updated_at": "2025-08-01T10:34:46Z",
      "author_association": "MEMBER",
      "body": "Updated [eb32d06](https://github.com/bitcoin-core/secp256k1/commit/eb32d06a936307fcce649cf8002e49e6f8730948) -> [b26c87d](https://github.com/bitcoin-core/secp256k1/commit/b26c87d5c09ddefe764a9cad6a8612e34ccd13de) ([2025_07](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_07) -> [2025_08](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_08), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_07..bip352-silentpayments-module-2025_08))\r\n\r\n* Updated sending API docs (h/t @Sjors)\r\n* Updated comments and improved variable naming for sending (h/t @Sjors)\r\n\r\nThanks for the review, @Sjors !",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3144097162",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18936947911,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARouuTH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18936947911",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:34:47Z"
    },
    {
      "event": "subscribed",
      "id": 18936947932,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARouuTc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18936947932",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:34:47Z"
    },
    {
      "event": "unsubscribed",
      "id": 18937315173,
      "node_id": "UE_lADOAP4Jqs6_1gh3zwAAAARowH9l",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18937315173",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:55:46Z"
    },
    {
      "event": "commented",
      "id": 3144198707,
      "node_id": "IC_kwDOAP4Jqs67aKoz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3144198707",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T11:10:03Z",
      "updated_at": "2025-08-01T11:10:03Z",
      "author_association": "MEMBER",
      "body": "> It could make sense to split https://github.com/bitcoin-core/secp256k1/commit/993d34b7ae3d4a8b6d3a8957b309b38e7e50e796 tests: add BIP-352 test vectors and move the send-side tests directly after this commit. Ditto for the send example in https://github.com/bitcoin-core/secp256k1/commit/ce7cb982d4aceefd8bb8591fd069c3a0b81d1ef2 silentpayments: add examples/silentpayments.c.\r\n\r\nBy splitting the test vectors commit into sending and receiving commits, it would be possible to break out just sending into its own PR (recall that sending can be implemented without implementing receiving). If this makes it easier to review and merge sending, I'm open to it. This would allow downstream work on the Bitcoin Core sending PR to proceed, while continued review on receiving happens here.\r\n\r\nOn the flipside, I do feel like the module in its current state is close to finished so I'm not sure how much benefit splitting at this stage would bring. I dropped a note in the `#secp256k1` IRC; will wait to hear from other reviewers/maintainers before making a decision here.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3144198707",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "reviewed",
      "id": 3087942073,
      "node_id": "PRR_kwDOAP4Jqs64DkG5",
      "url": null,
      "actor": null,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-05T13:33:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "Left some comments with minor suggestions regarding API header and the example, I'm planning to finish the full review this week.\r\n\r\nNo strong opinion on whether a split-up into sending/receiving PRs makes sense, from a reviewing point of view it likely doesn't make a difference for me at this point. I could imagine it's potentially brittle to only release the sending part if there is no strong test coverage provided that the generated outputs can also be found by receivers, so I'd slightly lean to keep as-is, I guess.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3087942073",
      "submitted_at": "2025-08-05T13:33:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19008541221,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARs_1Il",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19008541221",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "393a2a28c52274ae99fa2271116df2c7b2e4e4b8",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/393a2a28c52274ae99fa2271116df2c7b2e4e4b8",
      "created_at": "2025-08-06T09:06:40Z"
    },
    {
      "event": "commented",
      "id": 3158508760,
      "node_id": "IC_kwDOAP4Jqs68QwTY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3158508760",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T09:15:30Z",
      "updated_at": "2025-08-06T09:15:30Z",
      "author_association": "MEMBER",
      "body": "Updated [b26c87d](https://github.com/bitcoin-core/secp256k1/commit/b26c87d5c09ddefe764a9cad6a8612e34ccd13de) -> [393a2a2](https://github.com/bitcoin-core/secp256k1/commit/393a2a28c52274ae99fa2271116df2c7b2e4e4b8) ([2025_08](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_08) -> [2025_09](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_09), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_08..bip352-silentpayments-module-2025_09))\r\n\r\n* Various `example` fix-ups (h/t @theStack)\r\n* `s/outpoint_smallest/outpoint_smallest36/` (h/t @theStack )\r\n* `s/P_output_xonly/output_xonly/` (h/t @theStack )\r\n\r\n@theStack thanks for the continued review!\r\n\r\n> I could imagine it's potentially brittle to only release the sending part if there is no strong test coverage provided that the generated outputs can also be found by receivers\r\n\r\nFor this, I think it would be sufficient to show that the same inputs/outputs from the test vectors used in the sending PR are the same ones used in the receiving PR. But overall, I'm also leaning towards keeping everything together unless its expected that the sending commit is largely good to go but more review is required for the benchmarks, example, and receiving commits.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3158508760",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19008766208,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARtAsEA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19008766208",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T09:15:31Z"
    },
    {
      "event": "subscribed",
      "id": 19008766248,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARtAsEo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19008766248",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T09:15:32Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19011036759,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARtJWZX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011036759",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "96b2362337c4203fad9ef1690c8e60b7db2aa571",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/96b2362337c4203fad9ef1690c8e60b7db2aa571",
      "created_at": "2025-08-06T11:21:46Z"
    },
    {
      "event": "commented",
      "id": 3159769239,
      "node_id": "IC_kwDOAP4Jqs68VkCX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3159769239",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:01Z",
      "updated_at": "2025-08-06T11:27:01Z",
      "author_association": "MEMBER",
      "body": "Updated [393a2a2](https://github.com/bitcoin-core/secp256k1/commit/393a2a28c52274ae99fa2271116df2c7b2e4e4b8) -> [96b2362](https://github.com/bitcoin-core/secp256k1/commit/96b2362337c4203fad9ef1690c8e60b7db2aa571) ([2025_09](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_09) -> [2025_10](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_10), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_09..bip352-silentpayments-module-2025_10))\r\n\r\n* Add asserts in example (h/t @theStack )\r\n* Update header to better document how functions can fail\r\n\r\ncc @real-or-random @jonasnick on the header documentation. A majority of the error cases are can only happen if the user provides malformed inputs, or the output of a hash function results in something greater than the curve order. I opted to document these, but wanted to confirm to make sure I am doing something consistent with the rest of the library.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3159769239",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19011125434,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARtJsC6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125434",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:02Z"
    },
    {
      "event": "subscribed",
      "id": 19011125453,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARtJsDN",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125453",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:03Z"
    },
    {
      "event": "mentioned",
      "id": 19011125470,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARtJsDe",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125470",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:03Z"
    },
    {
      "event": "subscribed",
      "id": 19011125488,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARtJsDw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125488",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:03Z"
    },
    {
      "event": "mentioned",
      "id": 19011125511,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARtJsEH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125511",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:03Z"
    },
    {
      "event": "subscribed",
      "id": 19011125538,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARtJsEi",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19011125538",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T11:27:03Z"
    },
    {
      "event": "reviewed",
      "id": 3101192531,
      "node_id": "PRR_kwDOAP4Jqs642HFT",
      "url": null,
      "actor": null,
      "commit_id": "96b2362337c4203fad9ef1690c8e60b7db2aa571",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-08T15:58:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've convinced myself that the implementation in this PR matches the BIP352 specification and the usual quality requirements, especially regarding treatment of secret data (constant-time ops, clearing out the memory) are met from what I can tell.\r\n\r\nThe remaining comments are just nits for typos/minimizing-diff and a general question about the detail level of header API documentation. Other than that, I think I'd be ready to give a \"take it with a grain of salt, i'm not a cryptographer\"-ACK at this point :detective: ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3101192531",
      "submitted_at": "2025-08-08T15:58:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19082797827,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARxbGMD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19082797827",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "142f07bf6bacee1a695c2bb21f0a2cf77eaa96cd",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/142f07bf6bacee1a695c2bb21f0a2cf77eaa96cd",
      "created_at": "2025-08-11T08:28:15Z"
    },
    {
      "event": "commented",
      "id": 3173754156,
      "node_id": "IC_kwDOAP4Jqs69K6Us",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3173754156",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T08:31:56Z",
      "updated_at": "2025-08-11T08:31:56Z",
      "author_association": "MEMBER",
      "body": "Updated [96b2362](https://github.com/bitcoin-core/secp256k1/commit/96b2362337c4203fad9ef1690c8e60b7db2aa571) -> [142f07b](https://github.com/bitcoin-core/secp256k1/commit/142f07bf6bacee1a695c2bb21f0a2cf77eaa96cd) ([2025_10](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_10) -> [2025_11](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_11), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_10..bip352-silentpayments-module-2025_11))\r\n\r\n* Spelling and documentation fixes, (h/t @theStack)\r\n\r\nThanks again, @theStack, for the thorough review! Much appreciated.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3173754156",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19082863576,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARxbWPY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19082863576",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T08:31:57Z"
    },
    {
      "event": "subscribed",
      "id": 19082863602,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARxbWPy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19082863602",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T08:31:58Z"
    },
    {
      "event": "reviewed",
      "id": 3107973701,
      "node_id": "PRR_kwDOAP4Jqs65P-pF",
      "url": null,
      "actor": null,
      "commit_id": "142f07bf6bacee1a695c2bb21f0a2cf77eaa96cd",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-12T00:32:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "Left some more nitty findings below.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3107973701",
      "submitted_at": "2025-08-12T00:32:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19107953674,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARy7DwK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19107953674",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "created_at": "2025-08-12T09:36:53Z"
    },
    {
      "event": "commented",
      "id": 3178575124,
      "node_id": "IC_kwDOAP4Jqs69dTUU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3178575124",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T09:40:47Z",
      "updated_at": "2025-08-12T09:40:47Z",
      "author_association": "MEMBER",
      "body": "Updated [142f07b](https://github.com/bitcoin-core/secp256k1/commit/142f07bf6bacee1a695c2bb21f0a2cf77eaa96cd) -> [2b57d2a](https://github.com/bitcoin-core/secp256k1/commit/2b57d2ad8964e536508fae0b6ab1331396fe0308) ([2025_11](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_11) -> [2025_12](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_12), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_11..bip352-silentpayments-module-2025_12))\r\n\r\n* Documentation fixes (h/t @theStack)\r\n* Added `VERIFY_CHECK` and more consistent `ret` (h/t @theStack)\r\n* Removed dead code from tests and improved legibility (h/t @theStack)",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3178575124",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19108044316,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARy7Z4c",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19108044316",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T09:40:49Z"
    },
    {
      "event": "subscribed",
      "id": 19108044368,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARy7Z5Q",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19108044368",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T09:40:49Z"
    },
    {
      "event": "reviewed",
      "id": 3109600166,
      "node_id": "PRR_kwDOAP4Jqs65WLum",
      "url": null,
      "actor": null,
      "commit_id": "2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-12T10:52:00Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3109600166",
      "submitted_at": "2025-08-12T10:52:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3109923614,
      "node_id": "PRR_kwDOAP4Jqs65Xase",
      "url": null,
      "actor": null,
      "commit_id": "2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-12T11:01:38Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3109923614",
      "submitted_at": "2025-08-12T11:01:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "reviewed",
      "id": 3111636132,
      "node_id": "PRR_kwDOAP4Jqs65d8yk",
      "url": null,
      "actor": null,
      "commit_id": "2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-12T15:59:43Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3111636132",
      "submitted_at": "2025-08-12T15:59:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19158775745,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAAR187fB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19158775745",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a428424b3ec43ae46d30191e35d8a0b719a78298",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/a428424b3ec43ae46d30191e35d8a0b719a78298",
      "created_at": "2025-08-14T12:45:15Z"
    },
    {
      "event": "commented",
      "id": 3188346146,
      "node_id": "IC_kwDOAP4Jqs6-Ck0i",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3188346146",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-14T12:51:44Z",
      "updated_at": "2025-08-14T12:51:44Z",
      "author_association": "MEMBER",
      "body": "Updated [2b57d2a](https://github.com/bitcoin-core/secp256k1/commit/2b57d2ad8964e536508fae0b6ab1331396fe0308) -> [a428424](https://github.com/bitcoin-core/secp256k1/commit/a428424b3ec43ae46d30191e35d8a0b719a78298) ([2025_12](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_12) -> [2025_13](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_13), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_12..bip352-silentpayments-module-2025_13))\r\n\r\n* Remove extra check to make the autotools build system consistent with other modules (h/t @real-or-random )\r\n* Various wording fix-ups (h/t @real-or-random)\r\n* Use `spend_pubkey` to indicate a spend public key that might also have a tweak and `unlabeled_spend_pubkey` we mean to refer the unlabeled spend public key (vs `labeled_spend_pubkey` and `spend_pubkey`) (h/t @real-or-random )\r\n* Reword the sending API docs to avoid mentioning \"sorting\"\r\n\r\nThanks for the review @real-or-random , much prefer your wording suggestions. I pushed a version of the docs that I think helps minimise confusion about sorting, but curious to hear your thoughts as I imagine these docs will still need a bit of refining.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3188346146",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19158899014,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAAR19ZlG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19158899014",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-14T12:51:45Z"
    },
    {
      "event": "subscribed",
      "id": 19158899043,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAAR19Zlj",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19158899043",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-14T12:51:46Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGFhY2UyYWEyZTdlNjdmYzI4YzdmYzQxODljYWYwNTdkZmRmYTkzM2M",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/aace2aa2e7e67fc28c7fc4189caf057dfdfa933c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/aace2aa2e7e67fc28c7fc4189caf057dfdfa933c",
      "tree": {
        "sha": "8d33569b8edfd7324f030ab0e5dd5908796ad4ac",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/8d33569b8edfd7324f030ab0e5dd5908796ad4ac"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 8d33569b8edfd7324f030ab0e5dd5908796ad4ac\nparent b9313c6e1a6082a66b4c75777e18ca4b176fcf9d\nauthor josibake <josibake@protonmail.com> 1755247049 +0100\ncommitter josibake <josibake@protonmail.com> 1755252829 +0100\n\ntests: moved tagged hash util to tests.c\n\nMove the sha256_tag_test_internal function out of the musig module and into\ntests.c. This makes it available to other modules wishing to verify tagged hashesh\nwithout needing to duplicate the function.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCF4ACgkQity1WMTz\nPWWAjg/+OYc/7FwzwpHR4X9Dn5AB1yZ3ulDpLmONzPnqlCDgh7hoRZ14WtlUo6G4\nwF8rTk/gLQAfhuOkQ2PWsvqlZ2tMnz5s0+eRetx6OVMJX0y+OGZp4JzAUScR48pN\nxozqPBlT0eVeSV4I/BB7pZsQFw/+D0pIjMdv837mul4/+cKLG6Js+Jl7TLAlbHkb\n+Y5Gv2+gXHIyBuFrqlrR9Ix+bGVptE4udONE/WPy/PrDBy2IxGOnXmfcvRx03NAD\n0qLpUFLDAFUf7dBhSZKzoLt2U+EUKZrlRkD/snqjjcebUMzmDPnyp0966goWxuxx\nE8LZBO5ieHvaojzrMjdCAfTyvLVEqlTdOIeeK4wCY3KaZ0b8CSu3C+2Q2bwomseV\ngV5lE3mSJ0zJ0rK2Db9Zp++0Vj89Jr82lTZXn9gJyyH1WYSFN+5xmf1TKfb37ctK\nHmmaykjdfum9Htd8o1Az9MFM8hyGoV31EbnXP6emS5Uy8ciCvOjRjumbXOce2DwA\n/gCIoAi5Wta6WPtr1TdqyC4UTuJFaIjx/RhHgvprvH2EzGi/PLFYreb2FBIQRBi1\n00fnmFhyhJL30IKBAEjQkwkP/jV8FD7KQtwFAMc/6wlXgh21jfDPszbZlX9eMVwF\n/LAaRs6EiI3vZoNMxpoquvmSkXLlt3yDzWsfsyM45gzu9Fv0MbQ=\n=rvsU\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b9313c6e1a6082a66b4c75777e18ca4b176fcf9d",
          "sha": "b9313c6e1a6082a66b4c75777e18ca4b176fcf9d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b9313c6e1a6082a66b4c75777e18ca4b176fcf9d"
        }
      ],
      "message": "tests: moved tagged hash util to tests.c\n\nMove the sha256_tag_test_internal function out of the musig module and into\ntests.c. This makes it available to other modules wishing to verify tagged hashesh\nwithout needing to duplicate the function.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:13:49Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T08:37:29Z"
      },
      "sha": "aace2aa2e7e67fc28c7fc4189caf057dfdfa933c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGYyOTgyNWMyNTlhYzk4NDI1MDI3MjQ4MjdjNjBjOTI0YjdkYjk4MmQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f29825c259ac9842502724827c60c924b7db982d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f29825c259ac9842502724827c60c924b7db982d",
      "tree": {
        "sha": "65cf151f4a81cd8cc4f47d74bbb5d7edaae1a63e",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/65cf151f4a81cd8cc4f47d74bbb5d7edaae1a63e"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 65cf151f4a81cd8cc4f47d74bbb5d7edaae1a63e\nparent aace2aa2e7e67fc28c7fc4189caf057dfdfa933c\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1695828134 +0200\ncommitter josibake <josibake@protonmail.com> 1755252831 +0100\n\nbuild: add skeleton for new silentpayments (BIP352) module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIyBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCF8ACgkQity1WMTz\nPWUjiw/3fcJuFkzECYCyXvP+FccassnnSoloM7vJCiHXwaWJkqPbFZx2CNmQchvh\n8sC4BftLVv73hLK6f0iyAZf7CLpYY0scoVC4/t2acUf4d1+HltJVwj5ca0vvgQTr\nBHbzXaHzQi/SgAZO7Xh4go05/pWRxc8tk1QwqXn+iTpDisu2Qz63fK+7k50biogH\nbL8ev5mwLTf2JDWQJsSMgb/BIwReW/jCL6f0EVdFM+eFHiYa89Mn3DQNYTAK4in8\nB1xY1WFCkjMHnVzqPaQ8kVgjDl++30PNT72kbLPaqraesXHOw5CzeVnIv/zbunzF\nLLJDi2y6BpH5GLSOTqrQpQIrxBpf5RmiOSwA88EBSSCuZZJi0wxo3Owkx8VAa4yG\nzumnmeiiGX8sV0IyKwHPDmzp8yUv6YnR+clhTl51x2m7uRgWnnun8kDU98syjDYd\nXSuvcVcfnLfFhv/jrwKU8rosvB78s0eEW0WFkMpbJ/di2puE2m8i72FnwrLp0Ghg\nr/hDYGss/DLUsVOoSkGcH/TBJF3uJYXXCMRamlbcYnz1smgtLX3qAyRbFFIBFHCv\nGOhy/eRXg6foOayII9d4g0Pbw/IlrZjLe8I224SE6ojohdKCnHAjMvseK576RWMZ\nwTGG3v07CVek5wnPgOlRKTt+aXYZuete5BKLC4aenEjco/uHCw==\n=aIHi\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/aace2aa2e7e67fc28c7fc4189caf057dfdfa933c",
          "sha": "aace2aa2e7e67fc28c7fc4189caf057dfdfa933c",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/aace2aa2e7e67fc28c7fc4189caf057dfdfa933c"
        }
      ],
      "message": "build: add skeleton for new silentpayments (BIP352) module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:13:51Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2023-09-27T15:22:14Z"
      },
      "sha": "f29825c259ac9842502724827c60c924b7db982d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGE0NjAxYWYyY2U5NDI5MzI5NGNiY2YyMzlhNDU1ZjcwZGQzMjliODM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a4601af2ce94293294cbcf239a455f70dd329b83",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a4601af2ce94293294cbcf239a455f70dd329b83",
      "tree": {
        "sha": "b7395840f116f305b37191cff77d5fa5acc4f1e4",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/b7395840f116f305b37191cff77d5fa5acc4f1e4"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree b7395840f116f305b37191cff77d5fa5acc4f1e4\nparent f29825c259ac9842502724827c60c924b7db982d\nauthor josibake <josibake@protonmail.com> 1711383817 +0100\ncommitter josibake <josibake@protonmail.com> 1755252832 +0100\n\nsilentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCGAACgkQity1WMTz\nPWXlHw//ZT8xJfdX0Qdu8PjTuraypQjMd9lDwpLVan+aJgHtx6S2LKHM6nHzHwtE\n36tuYRZYebqPfiiCA4kscV5Xkk3bjd1XxCrcExoHsz0yEK4ut1WdIJAlj+GHWQNn\nh84reaYBJvWMaEBHOvJ+GNR17MimW/J5echvmG+F/PxjkSGNySSyFnyzG9BlC6pV\nlCSZ5CmJNf3DBORwzopr1yKr7VPEVlbqflUSAtUUJljkjzt4WLxPnJOWVyM/8erv\n3K7B/cqd6yqgDgzXfdYOVCjVEV90oE8uXBLXGyylLlcz0GQoCq8ZrVNeW7YgWy7E\nzwwtX0YTJD5uoNG7AK85Q3KLcVuX3l2DV+g2t6/cyIwKbmLzmDInJbysgOCgXMRu\nPkbRLfr7/FNmV6C5AJh/TFm8Q73C/HcRlOetVkr1nlckvE/IRt7cn+f4ICtgCKNU\n3FM78aLo6jTK2I/SNPAmNLcEY3oIAXIcHrqhXxLEJqlBdp5lQx+kqFAiopuxHc5W\nvf5S5BMT6XgTeAmJraP3CVcRj4/g0DCFf8TTfrwr0zmxHcwitEq6d1folFSe6hTI\nC0ALtUW5FNcKgYngPEX0joR7XuAa2zCQomIjCiKpMlZAOvbP6d6ht4K+t2CnzJSQ\n0mpB7zKAHcoK2qImv3fpXUDQEGSOhEMaaJ4sMIfFUUazo8nthTw=\n=psa/\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f29825c259ac9842502724827c60c924b7db982d",
          "sha": "f29825c259ac9842502724827c60c924b7db982d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f29825c259ac9842502724827c60c924b7db982d"
        }
      ],
      "message": "silentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:13:52Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-03-25T16:23:37Z"
      },
      "sha": "a4601af2ce94293294cbcf239a455f70dd329b83"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDA5MGYzODM5NjM3YzJiZTk5MGUyODMzNjBhYWE2MzljMDAxOGUyODg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/090f3839637c2be990e283360aaa639c0018e288",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/090f3839637c2be990e283360aaa639c0018e288",
      "tree": {
        "sha": "79d1324f56d562b2f5ac13e89f1ddd5ef98dc7c0",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/79d1324f56d562b2f5ac13e89f1ddd5ef98dc7c0"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 79d1324f56d562b2f5ac13e89f1ddd5ef98dc7c0\nparent a4601af2ce94293294cbcf239a455f70dd329b83\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1705946165 +0100\ncommitter josibake <josibake@protonmail.com> 1755252833 +0100\n\nsilentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCGEACgkQity1WMTz\nPWXILg//aC+wQl9dFLj1vHhmcS+CJ3Q9SfaKFvtEuTsOFy5R08GS8FKCaCWblTPV\nbDyPf+aXK6V+eFbYzg3MamW+sZo4Fk1ioyEDdju8XLm+yRjLpn/3fy2WNrVVqWr1\nrDQl3OhuDKhmeOE+Pbw8SiHOks4EnF1a4CZZEQIpVSVcFpWDxX8YQaukyYJYwvpX\n+PSVAQUhH+vfnb9Kh2H172dRAPr+UM3JVSj4gF/2mQIU1o3OSQtKdQP8NAeskQTU\nWLmvdFqkwN8Nbhoj4xTD2zgtPpo1YJO57JDHOw6a2P5Bxy2xdvkh6ASU7vHGVYWY\nvRoKB7JsabA7bZtLKEGkxN/TuCykkr9QSP43mIqbkSbupvDAtBSSPy13CNyDEu7Q\n81gEDATpyhP8pBnO8VRxbow2RXpxz4CC+78RnMZGaH5KKwqCxv3aOLxkSYQGxCGY\nT4NXF051ZgiRHae9wdZF2tkHzPF9dAIFo27TOkUz/3P/QL2nQ12jl1aAj2lEza4Z\nr1IRyLB/tIZNR00EsfRW7uYUG4+5gqEJAK+KWCrytGRwihvYG4qwH9kWhABX3/4j\nDULbaH1zXU2INhEO6wsxu1rQh2JnNhKQNM00M67GTqWCxqKtx5nAdd2Y4R3DVG+O\nV8kkaADuAAiD2Hb2K+xXZgyaV0SLx8YckNTqw0T+LqsBwR4DMDY=\n=FNuh\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a4601af2ce94293294cbcf239a455f70dd329b83",
          "sha": "a4601af2ce94293294cbcf239a455f70dd329b83",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a4601af2ce94293294cbcf239a455f70dd329b83"
        }
      ],
      "message": "silentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:13:53Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-01-22T17:56:05Z"
      },
      "sha": "090f3839637c2be990e283360aaa639c0018e288"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGY1NzE1MDFlYjZjMDk2YTI4MzgwZjAxYzM1NTk0YzU0NDAwNzc0NDI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f571501eb6c096a28380f01c35594c5440077442",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f571501eb6c096a28380f01c35594c5440077442",
      "tree": {
        "sha": "3e816c0ba1f7d2e31945b148319f2c35d803140c",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/3e816c0ba1f7d2e31945b148319f2c35d803140c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 3e816c0ba1f7d2e31945b148319f2c35d803140c\nparent 090f3839637c2be990e283360aaa639c0018e288\nauthor josibake <josibake@protonmail.com> 1719660810 +0200\ncommitter josibake <josibake@protonmail.com> 1755252834 +0100\n\nsilentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the summed input public key (A_sum)\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply b_scan * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a public_data object to\nand from a public key. When serializing a public_data object, the\ninput_hash is multplied into A_sum. This is so the object can be stored\nas public key for wallet rescanning later, or to vend to light clients.\nFor the light client, a `_parse` function is added which parses the\ncompressed public key serialization into a `public_data` object.\n\nFinally, add test coverage for the receiving API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCGIACgkQity1WMTz\nPWVxjhAArvdZUv0kQr6X+rqyhm2gvRUE2Ozuym09raZb2SjPSaO9IVr/I3Ih8Me3\nRCNSiPiOsftyVPEbJj/OIg6eh/MiOk0yw37TU/8BXkwv8/Xf19Tw5c/4fCCnyA+P\nSACsRJp0F6agIlCjgAkwhHusPMTWj6SuOr+s279s/+TTPBQt+gpK5/aDPFqJFUwN\nGwElVMJHAPUZALcm8cg//iIzngKUlmrkQgeYC9LEQ24E+2aBLxSytDWI/08xPbwT\nmeagfR5Gj01K+F3hNZjKM/l+r014RlPJkDUZ4fe7ita0rTQFgJtbn/xQ3gJCj6ld\nvW0re6nF/Z08ZisFVoRINFDCAZJsY/c+EHPqN+vJhv9s/k3Cmpe/rGgTjwtU7epG\nIzruo8l1EvdJLCxaJQyMG/CpBWsXpoaApnJtuhrzYd6urhUlSRGx4lQOZ4IbADap\nBYJuI8nP2WtEnFOIrIi4j8GgCdSDdEhlii1vTnmAiRm4CacY5aCShLjPZMx79CFv\n01tSHD3CcML77WHQVTIl7CEo8rmeOAohCqq2JtLdZS4DFhb1eWfCz6f0jIBpdIKL\nXYmX9lek2n03TNDUgxlYF8cSZKeTafjjmrfaMf7VvEC8h0/5nn7ruHFHblwO1GJB\nbr8yc7YL4134X6EQPRfCCQBh13zeBV30Az4WHLenac1iXlj/KZ8=\n=wS73\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/090f3839637c2be990e283360aaa639c0018e288",
          "sha": "090f3839637c2be990e283360aaa639c0018e288",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/090f3839637c2be990e283360aaa639c0018e288"
        }
      ],
      "message": "silentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the summed input public key (A_sum)\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply b_scan * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a public_data object to\nand from a public key. When serializing a public_data object, the\ninput_hash is multplied into A_sum. This is so the object can be stored\nas public key for wallet rescanning later, or to vend to light clients.\nFor the light client, a `_parse` function is added which parses the\ncompressed public key serialization into a `public_data` object.\n\nFinally, add test coverage for the receiving API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:13:54Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-06-29T11:33:30Z"
      },
      "sha": "f571501eb6c096a28380f01c35594c5440077442"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDg0NWFlNWVmMDYxNjQzYjRkMTc0ZTljZmQzOTI0ZGNkODIwNmJkZjc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/845ae5ef061643b4d174e9cfd3924dcd8206bdf7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/845ae5ef061643b4d174e9cfd3924dcd8206bdf7",
      "tree": {
        "sha": "98130c005c33701134c625afc1d199f813d93f02",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/98130c005c33701134c625afc1d199f813d93f02"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 98130c005c33701134c625afc1d199f813d93f02\nparent f571501eb6c096a28380f01c35594c5440077442\nauthor josibake <josibake@protonmail.com> 1713202589 +0200\ncommitter josibake <josibake@protonmail.com> 1755252835 +0100\n\nsilentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCGMACgkQity1WMTz\nPWVykQ//eT2ITJO6uNJhkdAM71Qsw6bSqA/eJ896UfoVzL6prjpp5sCxiyIQvqQW\nwrpNYWXlsFaUv/BMdWX0fbAezjFyWva/7AIjnwp0a+MhB/sT2vfBZxKJfRpJ84NJ\nKdo4KMbhtaeveOakSG6x2SBenVoa2HgF3ZChndG13qZcKj71OPu+xWk8H0/yryzx\nftQSDev8wBp/Bsw9Sf8QZgG3hNvlSZQmPvh5G5XqJyLZDI2vBPCtwr5KEBB6OxwV\n1xF6QnTn3BroKpZhi+sPW8sg35+Ri0fdOgjBchdUjMV/lxIjptqBDL7NonK2k3jc\nZA9DBnUZTORmUI2Ev8G05bhLZOUdb9oHmvrmk83maE5V4+1W0zIYnsqDO12OhPYs\nVmlsFAFlTMKY8vPfALXstGfy8NRpl7h0QYaCp+sz98WBpOisfIOE2aUayYCVHXWo\nw9CWGnn+lsIGZWXsSCu57UgM2L7fxpT0HMYpfVLQtUWJOk8d4E040ztWWL2/6ST5\nbEWYgoVKI/aGHegRxUTposLoDTW9oM6wXe+XF/7DwYdMkt4VjLNUVtVJ7i+uGFqd\niNCeWmebVUyFK8raYggXwfg0iaUuQ/xkMMxs9nIWmXxIyOEJmjSlCQ01d8ISLzlY\niRwYkOMrG8G000xR9/68afWacEuVEQ5QKuHfGGeG/H0P0CoFNps=\n=aoC1\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f571501eb6c096a28380f01c35594c5440077442",
          "sha": "f571501eb6c096a28380f01c35594c5440077442",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f571501eb6c096a28380f01c35594c5440077442"
        }
      ],
      "message": "silentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:13:55Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-15T17:36:29Z"
      },
      "sha": "845ae5ef061643b4d174e9cfd3924dcd8206bdf7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDU0YzM4NDM1ZjBlYzQ2M2I1Yzk3YjBhOGIyNTg0ZTkwZjM4OTgwOWE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/54c38435f0ec463b5c97b0a8b2584e90f389809a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/54c38435f0ec463b5c97b0a8b2584e90f389809a",
      "tree": {
        "sha": "be6268d8f6cdfc48d378b4c0db354d89902b12f1",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/be6268d8f6cdfc48d378b4c0db354d89902b12f1"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree be6268d8f6cdfc48d378b4c0db354d89902b12f1\nparent 845ae5ef061643b4d174e9cfd3924dcd8206bdf7\nauthor josibake <josibake@protonmail.com> 1714066415 +0200\ncommitter josibake <josibake@protonmail.com> 1755252836 +0100\n\nsilentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan and for scanning a single\noutput. Only benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCGQACgkQity1WMTz\nPWUh7xAAjrCW7CZdG/2MoRGNl2HOCAxrZNSvYoyRLxQ2OmzP7S63TdvJkpET3IIv\n/FS474NzvOmX68wYgXAV/D3yjLaMWYiCUqfnm/px8LvYPLxKIRbetA5+lHtSQ9lX\nrAQJbZy/BdxVfqDc3D1Z1BUMdm5NgSl/rIVnMkJLTmAxDYkelAbMA2LHwJQksihb\nTJhMGMuGYQmgVE/j7uLEdW4CFalh+DJKzRrERrZL9tM45WPj3g4ouX7okhmhgQvq\nZ4JxAW3YGpnlMCdaoN7pOcolKgjl7+/nD5NpUVla9XVt5naZx1FVTSnngkvJyUgo\nemcQvkUp6FYJA0cVObW0D8njn4NVyktpsD+7UtOOEcOryIgQtTCA0EmPlxjJEz7J\nLzuQkRw68RM+MU88H3Lh1reHOeIRnqD4o1lkvRTyPG7CMo5i+OZbqFlxCegmvOzo\ntgmIaIPWiRrMAzi9wbtzTecDKF9T7sMUjtrIflZ4tWG5DI3dmNWJDsVtAjbE6hoN\nemO5YCGbYDmXfbWVpXzESgNJ1tGzT9lZumpFZ8KgMP26q0WP1/pR0+BuaEnbkvqE\nX8QkYC5z245SrilhkmW7w9G2Y4x7SVSXAKlcZ95Q+iqaNwRVpa4pOX4+tOMi3t7j\nyovQBEp3tjo6JF2VGnz16SSE4lyhB5Udr9z7leygKu13Z0ZjxKU=\n=ofOv\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/845ae5ef061643b4d174e9cfd3924dcd8206bdf7",
          "sha": "845ae5ef061643b4d174e9cfd3924dcd8206bdf7",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/845ae5ef061643b4d174e9cfd3924dcd8206bdf7"
        }
      ],
      "message": "silentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan and for scanning a single\noutput. Only benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:13:56Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-25T17:33:35Z"
      },
      "sha": "54c38435f0ec463b5c97b0a8b2584e90f389809a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGQ3MGE0MjQwZDY4NDVhNzk5OTkxOGMxZmZiNDExOGQ3N2Y1ZDE5Yjc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/d70a4240d6845a7999918c1ffb4118d77f5d19b7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/d70a4240d6845a7999918c1ffb4118d77f5d19b7",
      "tree": {
        "sha": "6db1a07cc0dfc99aecf38fb90734ca7a277cb52d",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/6db1a07cc0dfc99aecf38fb90734ca7a277cb52d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 6db1a07cc0dfc99aecf38fb90734ca7a277cb52d\nparent 54c38435f0ec463b5c97b0a8b2584e90f389809a\nauthor josibake <josibake@protonmail.com> 1719942343 +0200\ncommitter josibake <josibake@protonmail.com> 1755252837 +0100\n\ntests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCGUACgkQity1WMTz\nPWVZtxAAyHw6UFs6lZrazUGO136q18ASuRdtHY0QeL9BopbwVqTMjpyC+hs0K26n\nzAO0AB62KLqInNJm3yRByy2r/kor4znohUkQ5zboLMDW3Z71vyNGQPRwnEORFLFN\n7dQKc90fknPyMp99l22M0dDyhc+r0IxdJRqHVvudSpohwRfOW4eZ3mX6frgxbZXL\nk/Ah0Go4c2U+E51ghpK8EwJMD+8Hvx5jO82jw0xDWDm8GUK9+9vkuz/xX0ZL98w/\nHyF5nVWeMRcybNVZkYiKUL76h+EwxPdwsBu7WRxiXKyicSpPQM2PniMdIbbf7RSR\nCBQSRi3cMN9aIWNzL8O+JUDytU/LvYVWrpt//SGlbudX1Hm5T5kQDwZjRxO1YNVG\nphEHA6I0ndLDyM7fb8+jqyU5UT+O3L+Jt17W+j88ZXoA4d0hgBgNuY2D+nq6d5Ne\n9/tlE/ZDnjonYTRtXij92wnwp+mTj9+sylA8cuyzs2pNqL3az9r+T2TE3h34Qe5q\nzJE1aBbamFMN0g7HqOh9r8uGQ2lekc6/K3K2MWtj0lozd00J5D8UCHVWUVT9n+7U\ngKAZBEazL5oKrCOGkitv1sW8ZQvwh7R7UFJUU0BgQiukrHEHv3MYy16x3hbYayv+\n1rvOSJDcddJpCNywdQxAhgznXR8gz2UWOYmjvb0zqrXMAGIyzlE=\n=+CUJ\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/54c38435f0ec463b5c97b0a8b2584e90f389809a",
          "sha": "54c38435f0ec463b5c97b0a8b2584e90f389809a",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/54c38435f0ec463b5c97b0a8b2584e90f389809a"
        }
      ],
      "message": "tests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:13:57Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-02T17:45:43Z"
      },
      "sha": "d70a4240d6845a7999918c1ffb4118d77f5d19b7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDc1OGFmNmI3YTMzMGFiMmYyMjA5MWViNzBiOWY0ODQwYjJiMTlhYTU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/758af6b7a330ab2f22091eb70b9f4840b2b19aa5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/758af6b7a330ab2f22091eb70b9f4840b2b19aa5",
      "tree": {
        "sha": "7aeaaa100e5d88d7daece023cf027085e8d2c152",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/7aeaaa100e5d88d7daece023cf027085e8d2c152"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 7aeaaa100e5d88d7daece023cf027085e8d2c152\nparent d70a4240d6845a7999918c1ffb4118d77f5d19b7\nauthor josibake <josibake@protonmail.com> 1730981939 +0100\ncommitter josibake <josibake@protonmail.com> 1755252838 +0100\n\ntests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCGYACgkQity1WMTz\nPWXLtxAAmy2lFFPCVuzs8nvVaqypkFQsHAjeNsAN/cI0wfUyrMLRWu4nwMlaVAKX\nwOMH/rj2SUmIe4hvdr8IV4x42NEj2gZNqJXuo4suTNXKwjnN2Ep4s3D2n0nFN/eR\n9hHRmTrfS5JUJ+kDw6csY+G1H6CZycJxspXZdE9LT5iJbresh9iyIkOMR9u9dJC6\nTqU3qHb1AtNBdmUVJk+51NYyBV2vyyF1amNPuVDWf/b8eAMqEpkKoohismC0OOfJ\nWm2/BAlTaL4WvgVyJUJrLMpT7biGE7KJPo+CnF/N+nu897JDNQiPT3FZ0bZOgD4h\nI4uNsSL0PHBUAB6kwH2yJuwIGPDeqKNYHYETSe5WNYtrn0g5Dzh6YuL5CL65YaT8\nyWaHHdFEg2Z/TBMVra0Bj2Yu8FAZTI3ppcJNiGPsCHYODhBCnuXqB8/Ie5BPIQRd\n8RxmZEMl0JQxpv6+SA9bEfdh+lAZJQyoodG2O6MgzeGWJSnme9w4MI3FEp02dTME\nfh0ry1ApG/yiruuhvC/09d37YY4Uqhy1wmfgygq/mKfeJpJC+FZgr7ATOV1UB38o\n1DJthqYNcdvmkkh9kdz6ruSTWwZ5VQJ0E5bPUG7lx34cSFw2VgZ+A4pcjUmYroah\noCuAON283chFXyCe+AwMq80WcDf+qZqDqfTeoYrCfpIc8fxbER0=\n=O4wx\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/d70a4240d6845a7999918c1ffb4118d77f5d19b7",
          "sha": "d70a4240d6845a7999918c1ffb4118d77f5d19b7",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/d70a4240d6845a7999918c1ffb4118d77f5d19b7"
        }
      ],
      "message": "tests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:13:58Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-11-07T12:18:59Z"
      },
      "sha": "758af6b7a330ab2f22091eb70b9f4840b2b19aa5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDc1Y2FmMjQ5MTg0ZmFlZjM0MmVjMmM2ZWRhMjcyY2U1NzU4NmJhODQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/75caf249184faef342ec2c6eda272ce57586ba84",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/75caf249184faef342ec2c6eda272ce57586ba84",
      "tree": {
        "sha": "e30a6c5bc2d802e33db2a6be8f7811a187011e07",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e30a6c5bc2d802e33db2a6be8f7811a187011e07"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e30a6c5bc2d802e33db2a6be8f7811a187011e07\nparent 758af6b7a330ab2f22091eb70b9f4840b2b19aa5\nauthor josibake <josibake@protonmail.com> 1755247606 +0100\ncommitter josibake <josibake@protonmail.com> 1755253159 +0100\n\ntests: add sha256 tag test\n\nTest midstate tags used in silent payments.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCboACgkQity1WMTz\nPWVqPw//UeZic3gnvMtcT7amKmY8HA0w/eQ7rpIzyTH5c5D1Muz9LNYrqYjMp9Ld\nRxEx93l5bkMOL+5nhSbOPyOqWlSrUJYCqbnHgowHdyq9PVMLIHKsywzYHaUBIZZk\ntv4JZyZTn4fZpUXUaLx2ULrWHYEb6bz/MxtOhixypLjOYCqNwZumMheNGtn2NiNv\nL0XUfrMS9fWHPINsv1a1664lhbbSoUsuqPWoodBYBpeBC92lSTTwulBkKGDkG4Hk\nyJR1sAtwbVkJ6Ji91ldsBhb3Mza4A6C4gmDq/rYKCAczWSA396cklEvgsROKy/2i\nsNtzC5u5aSksRHhuoX3RICWU7R+18vMimTg+a/LG3YfuynzVkLAb+o/1LWHeGwgD\nc3vFEB/BNlnXNVzfQmCk7+0xKVgtP8wf2B80qoPofDaKPniE480YYocVyiWkP6fW\nYsbKEMRJ4XJ8UU8HMTNbAM5iLIJUQHwRD6FqJicvpC0Iui/xf8LKfNsts4cRYtVs\nAjLAjbG6KWMK2DzKw9ZmjcUifrsJbOJx0t/JgqVaqr1IVB6KHspBg+hC/pOQo3UA\nqA1Ajw1xYeKG/L2CDDqE5DfJQsPk6VPlml0l416z9NpEyXTb88UkBYkD/smqK9Dc\nANDQpFCDSFdQd3IUhOVvHTHuV1FsvlTJzutVlzf5STAgOaypwr8=\n=4Gk0\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/758af6b7a330ab2f22091eb70b9f4840b2b19aa5",
          "sha": "758af6b7a330ab2f22091eb70b9f4840b2b19aa5",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/758af6b7a330ab2f22091eb70b9f4840b2b19aa5"
        }
      ],
      "message": "tests: add sha256 tag test\n\nTest midstate tags used in silent payments.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:19:19Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T08:46:46Z"
      },
      "sha": "75caf249184faef342ec2c6eda272ce57586ba84"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGM0ZWFkNzk0Zjk1NTYyNjQ3ZTFhY2E0NGI2NDkzMDA2YTc4YzFkOTY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c4ead794f95562647e1aca44b6493006a78c1d96",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c4ead794f95562647e1aca44b6493006a78c1d96",
      "tree": {
        "sha": "0632c6ecc356cf12acd3b2a901b3620cddf84069",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/0632c6ecc356cf12acd3b2a901b3620cddf84069"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 0632c6ecc356cf12acd3b2a901b3620cddf84069\nparent 75caf249184faef342ec2c6eda272ce57586ba84\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1708644341 +0100\ncommitter josibake <josibake@protonmail.com> 1755253184 +0100\n\nci: enable silentpayments module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCcEACgkQity1WMTz\nPWXrkhAAw595KIX4KGADRQWTEdd/1OR9k0zaggd2EMtg1urMteelPcfGO62CJ+hY\nuBIgsJvKk5PYnze5/itemGD/p5CoUU9lcnkpc+IXj5e4gvgQX+KG5mUd37Bbg7MX\n6XDv0IdncfGFmx83XHkZztfqfNUEzIwVsNSgy5f200rKjMnNg9zkGbcYEwL16Q/B\nY7kBICGdMw9HhfIkz1GsxCWlhRAjOtklRb26r9EO75vaBkswkLe6nsCgrj+AwK6J\ngpO0epQy9SQK3O1Fr0fPRfNzD2n7O2UM/5WHbQRy+Bux4SLXoMiFublQMZbqcbfg\n1vTi7Q2gUA/lcyTzvjccTzFtjFFUIz4b4DwmdtJV6sp3Wc+dDyU1NMyjFndeSNSm\n5V1dbwi7ZZknuO/OfDlBCnCOerG3V52IYBiIlqvfQx1R1WUjgD7mOb+NHl7szhYe\nAYdUI0RKFlOLDnMk2Ym6EL22VZon9ZxaYPUOdc56qq/K6Qs1b7YODM2hfvMR0D3W\nMhLgJXu7JXDNF3n7LLtuD91UizbE1kb/WAQj7EzH+a3eY1MQMcYo+1XaADnF9TNZ\nTc+Z8jKLTIBvA/6iU3rYBzq6yRG0Pcc6FzR143/3kxTqo4pO5w1XacMXBOhr8sFz\nqrN3HdQanyE9hjuGxdWv/FGqVHR74z5lDsdJp6Myzo5TPqoFGEU=\n=iMwE\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/75caf249184faef342ec2c6eda272ce57586ba84",
          "sha": "75caf249184faef342ec2c6eda272ce57586ba84",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/75caf249184faef342ec2c6eda272ce57586ba84"
        }
      ],
      "message": "ci: enable silentpayments module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:19:44Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-02-22T23:25:41Z"
      },
      "sha": "c4ead794f95562647e1aca44b6493006a78c1d96"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDk5YWVmOTIwNDYzNmYwNGNmNjg5ZDEzZWViMzY1ZjRmMmUzYTE1Njg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "tree": {
        "sha": "2040e645de7a711344bfefcd236296136359ce55",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/2040e645de7a711344bfefcd236296136359ce55"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 2040e645de7a711344bfefcd236296136359ce55\nparent c4ead794f95562647e1aca44b6493006a78c1d96\nauthor josibake <josibake@protonmail.com> 1720789074 +0200\ncommitter josibake <josibake@protonmail.com> 1755253185 +0100\n\ndocs: update README\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmifCcIACgkQity1WMTz\nPWUrQBAAoc/YDjgVEn5TYv/VyIdNzNJEb32qZj0b4QsA++4aMj/4/Wa4/3otNucf\nd2lJjt/5+pVJhB661841jg3MgVKyRAYOCG+fQG/7U2N3gz18ixahLvriQbPso65g\n/rA7NcdNM2/M6enSuVaaKnvQBRDvHziYBCu6mzGhfGh4zI750MthXPV0YA1QX+3K\nYj0Q9bb7R9wjXCxyN8fnvmy2Ux0yzS1v9rhCfr04sgnxjm8j8WIeCIZ4AM1fVoXo\nIkwBo/qnI68cGYi3Jlu9V/YfkY94soMfzLJLT2bK9g0UfURUAYavHNi9hKdga664\nH2Oyl4AaoEpmD0Z6+ZER0FCvlgNHSyWzBe7hyWZDcPYswoZzoa1OivGvGDe+O+tV\nrkAyxCG1u1YNTbKObjsV9NL80XMMRDBcnEiYV+yI/TXizWZ7vKuKcKozMXlt3a4P\nIIYdri8Q/m5ygoBU49IahH6oEln1lEq/5UB7/kU4nKiZ4gS09lY466ubYYHWi06a\nZwtJ6vzssUyKr19Mimhll9BPDIYDwhplmB/2VOWwf0Sxp/fMuPxkNTk59aQrhOho\nDVGcQ2vgn2yN1E1GljouenjZdwf6QGNKdE7RmQQPrsSrjyA+/N/58JdsDuTCmkL/\nrWENzZa09M4+t+pQublOILnLG61VRzBKVtOXCCFUOgXQDr2Llzc=\n=jspI\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c4ead794f95562647e1aca44b6493006a78c1d96",
          "sha": "c4ead794f95562647e1aca44b6493006a78c1d96",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c4ead794f95562647e1aca44b6493006a78c1d96"
        }
      ],
      "message": "docs: update README",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T10:19:45Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-12T12:57:54Z"
      },
      "sha": "99aef9204636f04cf689d13eeb365f4f2e3a1568"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19174245343,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAAR238Pf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19174245343",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "created_at": "2025-08-15T10:21:13Z"
    },
    {
      "event": "commented",
      "id": 3191203100,
      "node_id": "IC_kwDOAP4Jqs6-NeUc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3191203100",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-15T10:26:27Z",
      "updated_at": "2025-08-15T10:26:27Z",
      "author_association": "MEMBER",
      "body": "Updated [a428424](https://github.com/bitcoin-core/secp256k1/commit/a428424b3ec43ae46d30191e35d8a0b719a78298) -> [99aef92](https://github.com/bitcoin-core/secp256k1/commit/99aef9204636f04cf689d13eeb365f4f2e3a1568) ([2025_13](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_13) -> [2025_14](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_14), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_13..bip352-silentpayments-module-2025_14))\r\n\r\n* Add tests for the tagged hash midstates used in silent payments (h/t @real-or-random )\r\n\r\nThe first commit moves the convenience function for verifying tagged hashes out of the musig module and is pulled in from https://github.com/bitcoin-core/secp256k1/pull/1725. ",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3191203100",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 19174314490,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAAR24NH6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19174314490",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-15T10:26:29Z"
    },
    {
      "event": "subscribed",
      "id": 19174314504,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAAR24NII",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/19174314504",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-15T10:26:29Z"
    },
    {
      "event": "commented",
      "id": 3199776826,
      "node_id": "IC_kwDOAP4Jqs6-uLg6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3199776826",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-19T08:32:41Z",
      "updated_at": "2025-08-19T08:33:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've made my way through sending (ignoring the public header for now) and I pushed some suggestions for fixups here: https://github.com/bitcoin-core/secp256k1/compare/master...real-or-random:secp256k1:bip352-silentpayments-module-2025-sending-fixups (and some fixups also to receiving, I hope I always picked the right commit to fixup). See commit messages for rationale. Some of these may be opinionated, so feel free to reject, disagree, or adjust.  ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3199776826",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "reviewed",
      "id": 3131312139,
      "node_id": "PRR_kwDOAP4Jqs66pAgL",
      "url": null,
      "actor": null,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-19T08:35:52Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3131312139",
      "submitted_at": "2025-08-19T08:35:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2197616199",
      "pull_request_review_id": 3005508488,
      "id": 2197616199,
      "node_id": "PRRC_kwDOAP4Jqs6C_PZH",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 342,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": null,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *                label_context: pointer to a label context object (NULL if\r\n *                               labels are not used or context is not needed)\r\n```\r\n\r\n(was changed after https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832632525)",
      "created_at": "2025-07-10T12:37:09Z",
      "updated_at": "2025-07-10T16:26:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2197616199",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2197616199"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2198191851",
      "pull_request_review_id": 3005508488,
      "id": 2198191851,
      "node_id": "PRRC_kwDOAP4Jqs6DBb7r",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 354,
      "original_position": 340,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": null,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think it should be documented for how long the returned pointer from `label_lookup` should be valid. I think it is obvious it should be valid until the next call of `label_lookup`, but it is currently not clear (from the docs) whether it should remain valid until `secp256k1_silentpayments_recipient_scan_outputs` returns.\r\nThe current implementation of `secp256k1_silentpayments_recipient_scan_outputs` does not need this (from looking at the code) and in a safe Rust abstraction for this function ([code](https://github.com/antonilol/rust-secp256k1/commit/2b3f63399df449d39d90cd2292a913d2a20136cb), does contain some outdated comments) suggested for https://github.com/rust-bitcoin/rust-secp256k1/pull/721 (WIP bindings to this pull request's code) I relied on this **not** being a requirement (though that can be changed).\r\n",
      "created_at": "2025-07-10T16:26:31Z",
      "updated_at": "2025-07-10T16:26:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2198191851",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2198191851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 349,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 354,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204412350",
      "pull_request_review_id": 3015616207,
      "id": 2204412350,
      "node_id": "PRRC_kwDOAP4Jqs6DZKm-",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 354,
      "original_position": 340,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hi @antonilol , thanks for the review and bindings code! Agreed that this should be documented. How about something like:\r\n\r\n```diff\r\ndiff --git a/include/secp256k1_silentpayments.h b/include/secp256k1_silentpayments.h\r\nindex 2e71405..11fa596 100644\r\n--- a/include/secp256k1_silentpayments.h\r\n+++ b/include/secp256k1_silentpayments.h\r\n@@ -311,6 +311,11 @@ typedef struct secp256k1_silentpayments_found_output {\r\n  *  the recipient uses labels. This allows for checking if a label exists in\r\n  *  the recipients label cache and retrieving the label tweak during scanning.\r\n  *\r\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\r\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\r\n+ *  valid until the next call to `label_lookup` or until the function returns,\r\n+ *  whichever comes first. It is not retained beyond that.\r\n+ *\r\n  *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\r\n  *  can be used.\r\n  *\r\n  ```\r\n  \r\n  I think the above is the most precise requirement, but perhaps a simpler alternative would be to require that the returned pointer (and labels cache, if used) be valid until `_scan_outputs` returns? You mention you rely on this _not_ being the case today, but does this make a material difference if we _do_ require that the returned pointer and labels cache be valid for the lifetime of the `_scan_outputs` function?",
      "created_at": "2025-07-14T09:53:56Z",
      "updated_at": "2025-07-14T09:53:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204412350",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204412350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 349,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 354,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204418847",
      "pull_request_review_id": 3015624158,
      "id": 2204418847,
      "node_id": "PRRC_kwDOAP4Jqs6DZMMf",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 342,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2197616199,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, I've updated the comment and added a test case for the `(lookup, NULL)` argument combination.",
      "created_at": "2025-07-14T09:55:25Z",
      "updated_at": "2025-07-14T09:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204418847",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204418847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204890211",
      "pull_request_review_id": 3016293957,
      "id": 2204890211,
      "node_id": "PRRC_kwDOAP4Jqs6Da_Rj",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 354,
      "original_position": 340,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Looks good!\r\n\r\n> I think the above is the most precise requirement, but perhaps a simpler alternative would be to require that the returned pointer (and labels cache, if used) be valid until `_scan_outputs` returns? You mention you rely on this _not_ being the case today, but does this make a material difference if we _do_ require that the returned pointer and labels cache be valid for the lifetime of the `_scan_outputs` function?\r\n\r\nThis depends on the function signature on the Rust side, I have considered 2 cases. The difference is in what the user has to return from `label_lookup`.\r\n\r\nFirst, there is the one in the proof of concept binding I mentioned here, the user has to return any byte array of length 32 or nothing (translates to NULL pointer).\r\nThe C side accepts a pointer so the Rust side stores this byte array on the stack and gives the C side a pointer to that. This place on the stack is reused, so requiring that the pointer lives for longer than until the next call of `label_lookup` means that previous return values need to be kept and some dynamic allocation would be needed.\r\nI see this as the easiest for user to use. As far as I can tell no borrow checker issues can arise from this design.\r\n\r\nSecond, the user has to return a reference to a byte array of length 32 or nothing. The reference is required to live for as long as the function runs. This is because in Rust it is not (yet) possible to declare the reference is only required to live until the next call of `label_lookup`.\r\nThis is simple to implement because it is basically a pointer cast and is compatible with `_scan_outputs` needing pointers to be valid for the lifetime of the function.\r\nThis one is harder to use, especially for `label_lookup`s that are not simply looking up in a data structure. Returning a reference to any byte array that is not stored outside the function's stack frame is not allowed and storing it on the fly like the first case here probably requires the user to use unsafe code (needs a data structure that allows adding elements while there exist references to its existing elements because the reference is required to live for as long as the function runs) and has the same need for dynamic allocation like the first case can have.\r\n\r\nThe validity of the context pointer should be completely up to the users of the C library (I consider the Rust binding to also be a user of the C library).\r\n\r\nI will also link this discussion in the Rust bindings pull request.",
      "created_at": "2025-07-14T13:00:14Z",
      "updated_at": "2025-07-14T13:00:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204890211",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204890211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 349,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 354,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2205138710",
      "pull_request_review_id": 3016682153,
      "id": 2205138710,
      "node_id": "PRRC_kwDOAP4Jqs6Db78W",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 354,
      "original_position": 340,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for the detailed explanation! As I was thinking through this, it also occurred to me requiring the pointers to be valid for the lifetime of `_scan_outputs` would require keeping around pointers to every label found, even after they had been used by `_scan_outputs`. This seems undesirable, e.g., imagine a transaction with ~15k labeled outputs all paying to a single recipient. Your explanation seems to confirm my understanding.",
      "created_at": "2025-07-14T14:50:29Z",
      "updated_at": "2025-07-14T14:50:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2205138710",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2205138710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 349,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 354,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219105417",
      "pull_request_review_id": 3037944552,
      "id": 2219105417,
      "node_id": "PRRC_kwDOAP4Jqs6ERNyJ",
      "diff_hunk": "@@ -263,5 +286,61 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n         CHECK(ret == 1);\n     }\n \n+#endif\n+\n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    SECP256K1_CHECKMEM_DEFINE(key, 32);\n+\n+    generated_outputs[0] = &generated_output;\n+\n+    /* Initialize recipient */\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.scan_pubkey, key));\n+    key[31] ^= 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.labeled_spend_pubkey, key));\n+    key[31] ^= (1 << 1);\n+    recipient.index = 0;\n+    recipients[0] = &recipient;\n+\n+    /* Set up secret keys */\n+    SECP256K1_CHECKMEM_UNDEFINE(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &taproot_seckey, key);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret);\n+    key[31] ^= (1 << 2);\n+    taproot_seckeys[0] = &taproot_seckey;\n+    plain_seckeys[0] = key;\n+\n+    ret = secp256k1_silentpayments_sender_create_outputs(ctx, generated_outputs, recipients, 1, outpoint_smallest, taproot_seckeys, 1, plain_seckeys, 1);\n+    CHECK(ret == 1);\n+\n+    /* TODO: use non-confusing public key */\n+    ret = secp256k1_silentpayments_recipient_create_label(ctx, &recipient.labeled_spend_pubkey, label_tweak, key, 0);\n+    key[31] ^= (1 << 3);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey, NULL, &taproot_seckey));\n+    SECP256K1_CHECKMEM_DEFINE(&xonly_pubkey, sizeof(xonly_pubkey));\n+    xonly_pubkeys[0] = &xonly_pubkey;\n+    ret = secp256k1_ec_pubkey_create(ctx, &plain_pubkey, plain_seckeys[0]);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+    SECP256K1_CHECKMEM_DEFINE(&plain_pubkey, sizeof(plain_pubkey));\n+    plain_pubkeys[0] = &plain_pubkey;\n+\n+    ret = secp256k1_silentpayments_recipient_public_data_create(ctx, &public_data, outpoint_smallest, xonly_pubkeys, 1, plain_pubkeys, 1);\n+    CHECK(ret == 1);\n+\n+    tx_outputs[0] = generated_outputs[0];\n+    n_found_outputs = 1;\n+    SECP256K1_CHECKMEM_DEFINE(&recipient.labeled_spend_pubkey, sizeof(recipient.labeled_spend_pubkey));\n+    /* TODO: make sure we're actually go through all relevant code paths */\n+    ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\n+    CHECK(ret == 1);\n+\n+    /* TODO: this fails */\n+    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\n+    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */",
      "path": "src/ctime_tests.c",
      "position": null,
      "original_position": 95,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit de508a78ac66b93b0ff83b419cc6e149950ecc25: took a look into these TODOs, I think the following patch would tackle them (note that the serialize/parse-roundtrip looks superfluous at first sight, but it is needed to set the \"combined\" flag in the public data, which is ARG_CHECKEDed for 1 in _recipient_create_shared_secret):\r\n```diff\r\ndiff --git a/src/ctime_tests.c b/src/ctime_tests.c\r\nindex 17964b9..83596a3 100644\r\n--- a/src/ctime_tests.c\r\n+++ b/src/ctime_tests.c\r\n@@ -116,6 +116,8 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\r\n     const secp256k1_xonly_pubkey *xonly_pubkeys[1];\r\n     secp256k1_pubkey plain_pubkey;\r\n     const secp256k1_pubkey *plain_pubkeys[1];\r\n+    unsigned char public_data_ser[33] = { 0 };\r\n+    unsigned char shared_secret[33] = { 0 };\r\n #endif\r\n \r\n     for (i = 0; i < 32; i++) {\r\n@@ -338,9 +340,10 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\r\n     ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\r\n     CHECK(ret == 1);\r\n \r\n-    /* TODO: this fails */\r\n-    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\r\n-    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */\r\n+    CHECK(secp256k1_silentpayments_recipient_public_data_serialize(ctx, public_data_ser, &public_data));\r\n+    CHECK(secp256k1_silentpayments_recipient_public_data_parse(ctx, &public_data, public_data_ser));\r\n+    CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data));\r\n+    CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(ctx, &xonly_pubkey, shared_secret, &recipient.labeled_spend_pubkey, 0));\r\n \r\n #endif\r\n }\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\nindex 3fc42f5..7d3ad41 100644\r\n--- a/src/modules/silentpayments/main_impl.h\r\n+++ b/src/modules/silentpayments/main_impl.h\r\n@@ -708,6 +708,7 @@ int secp256k1_silentpayments_recipient_create_shared_secret(const secp256k1_cont\r\n     ret &= secp256k1_scalar_set_b32_seckey(&rsk, recipient_scan_key32);\r\n     ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_tweaked_ge, public_data);\r\n     /* If there are any issues with the recipient scan key or public data, return early */\r\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\r\n     if (!ret) {\r\n         return 0;\r\n     }\r\n```",
      "created_at": "2025-07-21T12:45:14Z",
      "updated_at": "2025-07-21T12:45:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2219105417",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219105417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219368126",
      "pull_request_review_id": 3038350839,
      "id": 2219368126,
      "node_id": "PRRC_kwDOAP4Jqs6ESN6-",
      "diff_hunk": "@@ -263,5 +286,61 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n         CHECK(ret == 1);\n     }\n \n+#endif\n+\n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    SECP256K1_CHECKMEM_DEFINE(key, 32);\n+\n+    generated_outputs[0] = &generated_output;\n+\n+    /* Initialize recipient */\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.scan_pubkey, key));\n+    key[31] ^= 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.labeled_spend_pubkey, key));\n+    key[31] ^= (1 << 1);\n+    recipient.index = 0;\n+    recipients[0] = &recipient;\n+\n+    /* Set up secret keys */\n+    SECP256K1_CHECKMEM_UNDEFINE(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &taproot_seckey, key);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret);\n+    key[31] ^= (1 << 2);\n+    taproot_seckeys[0] = &taproot_seckey;\n+    plain_seckeys[0] = key;\n+\n+    ret = secp256k1_silentpayments_sender_create_outputs(ctx, generated_outputs, recipients, 1, outpoint_smallest, taproot_seckeys, 1, plain_seckeys, 1);\n+    CHECK(ret == 1);\n+\n+    /* TODO: use non-confusing public key */\n+    ret = secp256k1_silentpayments_recipient_create_label(ctx, &recipient.labeled_spend_pubkey, label_tweak, key, 0);\n+    key[31] ^= (1 << 3);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey, NULL, &taproot_seckey));\n+    SECP256K1_CHECKMEM_DEFINE(&xonly_pubkey, sizeof(xonly_pubkey));\n+    xonly_pubkeys[0] = &xonly_pubkey;\n+    ret = secp256k1_ec_pubkey_create(ctx, &plain_pubkey, plain_seckeys[0]);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+    SECP256K1_CHECKMEM_DEFINE(&plain_pubkey, sizeof(plain_pubkey));\n+    plain_pubkeys[0] = &plain_pubkey;\n+\n+    ret = secp256k1_silentpayments_recipient_public_data_create(ctx, &public_data, outpoint_smallest, xonly_pubkeys, 1, plain_pubkeys, 1);\n+    CHECK(ret == 1);\n+\n+    tx_outputs[0] = generated_outputs[0];\n+    n_found_outputs = 1;\n+    SECP256K1_CHECKMEM_DEFINE(&recipient.labeled_spend_pubkey, sizeof(recipient.labeled_spend_pubkey));\n+    /* TODO: make sure we're actually go through all relevant code paths */\n+    ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\n+    CHECK(ret == 1);\n+\n+    /* TODO: this fails */\n+    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\n+    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */",
      "path": "src/ctime_tests.c",
      "position": null,
      "original_position": 95,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "in_reply_to_id": 2219105417,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for the patch! I've updated the ctime tests to use this, and also removed the remaining TODOs from the test file (with comments where appropriate).",
      "created_at": "2025-07-21T14:18:16Z",
      "updated_at": "2025-07-21T14:18:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2219368126",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219368126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2225857523",
      "pull_request_review_id": 3047815175,
      "id": 2225857523,
      "node_id": "PRRC_kwDOAP4Jqs6Eq-Pz",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 896e0af2f883d21ba3540290f176dcaa7f57272d: As for those TODOs, probably the safest option is to return an error if `_pubkey_tweak_add` indeed fails? Initially I assumed that doing that would introduce a branch that can't be tested in practice, but I think it is: by picking arbitrary `shared_secret33` and `k` values, and calculating `recipient_labeled_spend_pubkey` as `-G^(_create_t_k(shared_secret33, k))` the tweaking should fail with these three values. Will try to come up with some test code later to verify.",
      "created_at": "2025-07-23T14:51:40Z",
      "updated_at": "2025-07-23T14:51:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2225857523",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2225857523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2226200883",
      "pull_request_review_id": 3048350883,
      "id": 2226200883,
      "node_id": "PRRC_kwDOAP4Jqs6EsSEz",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, managed to come up with a test that makes the VERIFY_CHECK on the `_pubkey_tweak_add` return value fail:\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/tests_impl.h b/src/modules/silentpayments/tests_impl.h\r\nindex a1acab7..2a10791 100644\r\n--- a/src/modules/silentpayments/tests_impl.h\r\n+++ b/src/modules/silentpayments/tests_impl.h\r\n@@ -367,6 +367,23 @@ static void test_recipient_api(void) {\r\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_output_pubkey(CTX, &t, NULL, &p, 0));\r\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_output_pubkey(CTX, &t, o, NULL, 0));\r\n \r\n+    /* check the _recipient_create_output_pubkey cornercase where internal tweaking would fail;\r\n+       this is the case if the recipient spend public key is P = -(create_t_k(shared_secret, k))*G */\r\n+    {\r\n+        const unsigned char *shared_secret = o;\r\n+        const uint32_t k = 0;\r\n+        secp256k1_scalar t_k;\r\n+        unsigned char t_k_ser[32];\r\n+        secp256k1_pubkey fake_spend_pubkey;\r\n+        secp256k1_xonly_pubkey output_xonly;\r\n+\r\n+        secp256k1_silentpayments_create_t_k(&t_k, shared_secret, k);\r\n+        secp256k1_scalar_get_b32(t_k_ser, &t_k);\r\n+        CHECK(secp256k1_ec_pubkey_create(CTX, &fake_spend_pubkey, t_k_ser));\r\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &fake_spend_pubkey));\r\n+        CHECK(secp256k1_silentpayments_create_output_pubkey(CTX, &output_xonly, shared_secret, &fake_spend_pubkey, k) == 0);\r\n+    }\r\n+\r\n     n_f = 0;\r\n     labels_cache.entries_used = 0;\r\n     CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, &labels_cache));\r\n```\r\n</details>\r\n\r\nI assume that in practice a user can't be tricked into such a scenario though, as the recipient spend public key is known/generated before the shared secret is.",
      "created_at": "2025-07-23T17:14:12Z",
      "updated_at": "2025-07-23T17:14:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2226200883",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2226200883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2228336402",
      "pull_request_review_id": 3051391771,
      "id": 2228336402,
      "node_id": "PRRC_kwDOAP4Jqs6E0bcS",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Awesome! IIRC, the initial hesitance to returning a value was adding an untestable branch in the code. But considering this can be exercised in a test (which indicates its not inconceivable that someone could be tricked into calling this function with a maliciously crafted spend pubkey), I removed the VERIFY_CHECK in favour of returning the value and added your test case. Thanks for working on this!",
      "created_at": "2025-07-24T12:10:33Z",
      "updated_at": "2025-07-24T12:10:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2228336402",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2228336402"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229570600",
      "pull_request_review_id": 3053302400,
      "id": 2229570600,
      "node_id": "PRRC_kwDOAP4Jqs6E5Iwo",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 246,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Suggestion for the comment to tackle another TODO   (IIUC, the non-constant timing of group element serialization seems to ultimately be caused by [variable-time normalization of field elements](https://github.com/bitcoin-core/secp256k1/blob/b9313c6e1a6082a66b4c75777e18ca4b176fcf9d/src/eckey_impl.h#L44-L45)):\r\n```suggestion\r\n    /* Need to declassify the pubkey sum because serializing a group element (done in the\r\n       `_calculate_input_hash` call following) is not a constant-time operation */\r\n    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\r\n```",
      "created_at": "2025-07-24T21:04:03Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229570600",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229570600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 249,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229577936",
      "pull_request_review_id": 3053302400,
      "id": 2229577936,
      "node_id": "PRRC_kwDOAP4Jqs6E5KjQ",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 141,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "only noticing now that in one of my [earlier comments](https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2225857523) I was using multiplicative notation (cryptocamp leaving its marks already I guess )\r\n```suggestion\r\n     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\r\n```",
      "created_at": "2025-07-24T21:07:46Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229577936",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229577936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229609301",
      "pull_request_review_id": 3053302400,
      "id": 2229609301,
      "node_id": "PRRC_kwDOAP4Jqs6E5SNV",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 282,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should also memclear the shared secret here and in the error path a few lines above (admitedly a bit annoying though that this leads to so much code duplication :/)",
      "created_at": "2025-07-24T21:22:37Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229609301",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229609301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 285,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229624153",
      "pull_request_review_id": 3053302400,
      "id": 2229624153,
      "node_id": "PRRC_kwDOAP4Jqs6E5V1Z",
      "diff_hunk": "@@ -0,0 +1,618 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 151,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "72489a733c81153782eba2e4dded316dccc55c99",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could update the `main` return values in the example to use `EXIT_FAILURE`/`EXIT_SUCCESS` (done for other examples in #1654)",
      "created_at": "2025-07-24T21:32:44Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229624153",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229624153"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230327932",
      "pull_request_review_id": 3054340559,
      "id": 2230327932,
      "node_id": "PRRC_kwDOAP4Jqs6E8Bp8",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 141,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229577936,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was about to ask what this strange \"`-`\" symbol in `-G^(_create_t_k(shared_secret33, k))` is supposed to mean. :stuck_out_tongue:  ",
      "created_at": "2025-07-25T07:04:44Z",
      "updated_at": "2025-07-25T07:04:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230327932",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230327932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230609936",
      "pull_request_review_id": 3054721891,
      "id": 2230609936,
      "node_id": "PRRC_kwDOAP4Jqs6E9GgQ",
      "diff_hunk": "@@ -0,0 +1,618 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 151,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "72489a733c81153782eba2e4dded316dccc55c99",
      "in_reply_to_id": 2229624153,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-07-25T09:20:32Z",
      "updated_at": "2025-07-25T09:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230609936",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230609936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230612333",
      "pull_request_review_id": 3054725418,
      "id": 2230612333,
      "node_id": "PRRC_kwDOAP4Jqs6E9HFt",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 282,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229609301,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, also slightly reworded the comment. Overall, while slightly annoying, the code duplication doesn't seem too bad to me and I don't see a clever way to DRY it up.",
      "created_at": "2025-07-25T09:21:26Z",
      "updated_at": "2025-07-25T09:21:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230612333",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230612333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 285,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230613364",
      "pull_request_review_id": 3054726664,
      "id": 2230613364,
      "node_id": "PRRC_kwDOAP4Jqs6E9HV0",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 141,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229577936,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Team additive  ",
      "created_at": "2025-07-25T09:21:56Z",
      "updated_at": "2025-07-25T09:21:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230613364",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230613364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230614608",
      "pull_request_review_id": 3054728553,
      "id": 2230614608,
      "node_id": "PRRC_kwDOAP4Jqs6E9HpQ",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 246,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229570600,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for digging into this! Added the comment with some slight formatting changes.",
      "created_at": "2025-07-25T09:22:25Z",
      "updated_at": "2025-07-25T09:22:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230614608",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230614608"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 249,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230617988",
      "pull_request_review_id": 3054733915,
      "id": 2230617988,
      "node_id": "PRRC_kwDOAP4Jqs6E9IeE",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated this to actually calculate the shared secret from the public data object, to make valgrind happy.",
      "created_at": "2025-07-25T09:23:51Z",
      "updated_at": "2025-07-25T09:23:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230617988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230617988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236470910",
      "pull_request_review_id": 3062729343,
      "id": 2236470910,
      "node_id": "PRRC_kwDOAP4Jqs6FTdZ-",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": null,
      "original_position": 111,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It might make sense to split this benchmark into \"labeled\" and \"unlabeled\" variants in order to also get a feeling how overhead the labels scanning causes, with something like e.g.:\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/bench_impl.h b/src/modules/silentpayments/bench_impl.h\r\nindex 1dd1e5a..366d172 100644\r\n--- a/src/modules/silentpayments/bench_impl.h\r\n+++ b/src/modules/silentpayments/bench_impl.h\r\n@@ -108,7 +108,7 @@ static void bench_silentpayments_output_scan(void* arg, int iters) {\r\n     }\r\n }\r\n \r\n-static void bench_silentpayments_full_tx_scan(void* arg, int iters) {\r\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {\r\n     int i;\r\n     size_t n_found = 0;\r\n     secp256k1_silentpayments_found_output *found_output_ptrs[2];\r\n@@ -116,6 +116,8 @@ static void bench_silentpayments_full_tx_scan(void* arg, int iters) {\r\n     const secp256k1_xonly_pubkey *tx_input_ptrs[2];\r\n     bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\r\n     secp256k1_silentpayments_recipient_public_data public_data;\r\n+    const secp256k1_silentpayments_label_lookup label_lookup_fn = use_labels ? label_lookup : NULL;\r\n+    const void *label_context = use_labels ? label_cache : NULL;\r\n \r\n     for (i = 0; i < 2; i++) {\r\n         found_output_ptrs[i] = &data->found_outputs[i];\r\n@@ -135,11 +137,19 @@ static void bench_silentpayments_full_tx_scan(void* arg, int iters) {\r\n             data->scan_key,\r\n             &public_data,\r\n             &data->spend_pubkey,\r\n-            label_lookup, label_cache)\r\n+            label_lookup_fn, label_context)\r\n         );\r\n     }\r\n }\r\n \r\n+static void bench_silentpayments_full_tx_scan_unlabeled(void *arg, int iters) {\r\n+    bench_silentpayments_full_tx_scan(arg, iters, 0);\r\n+}\r\n+\r\n+static void bench_silentpayments_full_tx_scan_labeled(void *arg, int iters) {\r\n+    bench_silentpayments_full_tx_scan(arg, iters, 1);\r\n+}\r\n+\r\n static void run_silentpayments_bench(int iters, int argc, char** argv) {\r\n     bench_silentpayments_data data;\r\n     int d = argc == 1;\r\n@@ -147,7 +157,8 @@ static void run_silentpayments_bench(int iters, int argc, char** argv) {\r\n     /* create a context with no capabilities */\r\n     data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\r\n \r\n-    if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_full_tx_scan\", bench_silentpayments_full_tx_scan, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n+    if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_full_tx_scan_labeled\", bench_silentpayments_full_tx_scan_labeled, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n+    if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_full_tx_scan_unlabeled\", bench_silentpayments_full_tx_scan_unlabeled, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n     if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_output_scan\", bench_silentpayments_output_scan, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n \r\n     secp256k1_context_destroy(data.ctx);\r\n\r\n```\r\n</details>\r\nResults on my machine:\r\n\r\n```\r\nBenchmark                     ,    Min(us)    ,    Avg(us)    ,    Max(us)\r\n\r\nsilentpayments_full_tx_scan_labeled,    94.6       ,    96.6       ,   101.0\r\nsilentpayments_full_tx_scan_unlabeled,    82.7       ,    84.2       ,    85.9\r\nsilentpayments_output_scan    ,    85.3       ,    87.5       ,    90.7\r\n```",
      "created_at": "2025-07-28T13:27:27Z",
      "updated_at": "2025-07-28T13:27:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2236470910",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236470910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236659827",
      "pull_request_review_id": 3062979375,
      "id": 2236659827,
      "node_id": "PRRC_kwDOAP4Jqs6FULhz",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": null,
      "original_position": 111,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agreed. I added the dummy labels originally to make sure I was reporting worst-case[^1] numbers for the full scan benchmark, and the idea was to add more benchmarks in a follow-up that more accurately benchmark labels. However, I think what you have here is nicer and we can still leave a TODO comment to add a more representative benchmark for scanning _with_ labels.\r\n\r\n[^1]: worst case in the sense that all of the scan-with-labels code paths are hit during the benchmark. Its not an actual worst case in that you could have a very large, poorly implemented labels cache which would necessarily slow down scanning",
      "created_at": "2025-07-28T14:11:33Z",
      "updated_at": "2025-07-28T14:11:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2236659827",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236659827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2237486984",
      "pull_request_review_id": 3064088495,
      "id": 2237486984,
      "node_id": "PRRC_kwDOAP4Jqs6FXVeI",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": null,
      "original_position": 111,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added your diff with a few minor naming differences and left a TODO comment for filling out the labels benchmark in a follow-up. In particular, I would be interested to see a benchmark that demonstrates that scan time is largely unaffected by label cache size, e.g., scanning with 10 labels vs 100,000 labels shouldn't make a difference. I think this should be a follow-up, however, since it's not strictly necessary and will likely require dedicated review of its own to get things right. ",
      "created_at": "2025-07-28T18:09:35Z",
      "updated_at": "2025-07-28T18:09:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2237486984",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2237486984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2240863450",
      "pull_request_review_id": 3069025328,
      "id": 2240863450,
      "node_id": "PRRC_kwDOAP4Jqs6FkNza",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": null,
      "original_position": 111,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Seems fine to limit the scanning-with-labels benchmark to the cryptography-related parts for now. The planned extended benchmark doesn't even necessarily have to live in the secp repo IMHO, it could as well be in a project using the module (i.e. Bitcoin Core in our case), where a labels cache has to be implemented anyways and we wouldn't have to fake it (which might be non-trivial in C to achieve something representative, as I guess we'd need to implement some hashmap-like data structure a la `std::unordered_map`?). But no hard feelings on the details of where/how, I agree that seeing such a followup would be very interesting indeed.",
      "created_at": "2025-07-29T20:08:33Z",
      "updated_at": "2025-07-29T20:08:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2240863450",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2240863450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2242248473",
      "pull_request_review_id": 3070874257,
      "id": 2242248473,
      "node_id": "PRRC_kwDOAP4Jqs6Fpf8Z",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": null,
      "original_position": 111,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Excellent point regarding the hashmap. I'll leave the TODO comment for now, but it might be that the follow-up is simply to remove the comment in favour of, as you suggest, benchmarking this in a more realistic setting like Bitcoin Core.",
      "created_at": "2025-07-30T10:48:11Z",
      "updated_at": "2025-07-30T10:48:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2242248473",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2242248473"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244025546",
      "pull_request_review_id": 3073577403,
      "id": 2244025546,
      "node_id": "PRRC_kwDOAP4Jqs6FwRzK",
      "diff_hunk": "@@ -0,0 +1,619 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return EXIT_SUCCESS;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 35,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "070ea002339bf10603da5dd772795c7ccae3af51",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in 070ea002339bf10603da5dd772795c7ccae3af51, function `my_memcmp_var`\r\n```suggestion\r\n    return 0;\r\n```\r\nas this doesn't indicate a process execution status",
      "created_at": "2025-07-30T23:05:57Z",
      "updated_at": "2025-07-30T23:49:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2244025546",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244025546"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244864246",
      "pull_request_review_id": 3074665943,
      "id": 2244864246,
      "node_id": "PRRC_kwDOAP4Jqs6Fzej2",
      "diff_hunk": "@@ -0,0 +1,619 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return EXIT_SUCCESS;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 35,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "070ea002339bf10603da5dd772795c7ccae3af51",
      "in_reply_to_id": 2244025546,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, good catch!",
      "created_at": "2025-07-31T09:33:28Z",
      "updated_at": "2025-07-31T09:33:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2244864246",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244864246"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245393152",
      "pull_request_review_id": 3075428613,
      "id": 2245393152,
      "node_id": "PRRC_kwDOAP4Jqs6F1fsA",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 36,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: it may be worth reminding the reader why there's never more than one secret key per input; BIP352 excludes inputs \"with conditional branches or multiple public keys\". ",
      "created_at": "2025-07-31T13:23:55Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245393152",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245393152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245418259",
      "pull_request_review_id": 3075428613,
      "id": 2245418259,
      "node_id": "PRRC_kwDOAP4Jqs6F1l0T",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 47,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: the taproot secret keys",
      "created_at": "2025-07-31T13:33:02Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245418259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245418259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245425545",
      "pull_request_review_id": 3075428613,
      "id": 2245425545,
      "node_id": "PRRC_kwDOAP4Jqs6F1nmJ",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 68,
      "original_position": 45,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: I still think it would be nice to have a helper for this, but it can be introduced in a later PR.",
      "created_at": "2025-07-31T13:35:58Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245425545",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245425545"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 68,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245490407",
      "pull_request_review_id": 3075428613,
      "id": 2245490407,
      "node_id": "PRRC_kwDOAP4Jqs6F13bn",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 9,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: from offline conversation my understanding is as follows:\r\n\r\nWe don't add a tie breaker here (e.g. `->index`) because:\r\n\r\n1. The protocol doesn't require it\r\n2. It would break the constant time property of heap sort\r\n\r\nIf so, it would be good to say this in a comment so nobody is a) confused b) tempted later to introduce a footgun.\r\n\r\n(the temptation might come from a user of this library who finds that their tests are breaking half of the time because they had an ordering related bug - or just natural programmer desire for deterministic sort ) ",
      "created_at": "2025-07-31T14:00:45Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245490407",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245490407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245508149",
      "pull_request_review_id": 3075428613,
      "id": 2245508149,
      "node_id": "PRRC_kwDOAP4Jqs6F17w1",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 38,
      "original_position": 33,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: anyone have a nice Python / Ruby incantation to derive the midstates of `BIP0352/...`?",
      "created_at": "2025-07-31T14:07:45Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245508149",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245508149"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245582298",
      "pull_request_review_id": 3075428613,
      "id": 2245582298,
      "node_id": "PRRC_kwDOAP4Jqs6F2N3a",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 298,
      "original_position": 293,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: it's worth noting somewhere, maybe in the BIP, that _removing_ (omitting) any output `k` later will cause the recipient to not find outputs `> k`  ",
      "created_at": "2025-07-31T14:34:23Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245582298",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245582298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245635733",
      "pull_request_review_id": 3075428613,
      "id": 2245635733,
      "node_id": "PRRC_kwDOAP4Jqs6F2a6V",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 16,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: \"is set to\" -> \"must be set to ... starting with 0\" (since it's checked).",
      "created_at": "2025-07-31T14:54:50Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245635733",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245635733"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245675709",
      "pull_request_review_id": 3075428613,
      "id": 2245675709,
      "node_id": "PRRC_kwDOAP4Jqs6F2kq9",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 265,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: so the last shall be first, and the first last :-)\r\n\r\nI think it would be more clear to store `recipients[0]->scan_pubkey` instead and call it `current_scan_pubkey`.",
      "created_at": "2025-07-31T15:10:30Z",
      "updated_at": "2025-07-31T15:27:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245675709",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245675709"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245789470",
      "pull_request_review_id": 3076017194,
      "id": 2245789470,
      "node_id": "PRRC_kwDOAP4Jqs6F3Ace",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 38,
      "original_position": 33,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Wrote one in C using secp256k1 itself a while ago, see https://github.com/bitcoin-core/secp256k1/issues/1653 (regarding Python, the thread suggests using the https://github.com/cloudtools/sha256 library, but didn't try that yet; with the standard library implementation in `hashlib` it's unfortunately not possible to access the internal state :/).",
      "created_at": "2025-07-31T15:57:43Z",
      "updated_at": "2025-07-31T15:57:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245789470",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245789470"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247461288",
      "pull_request_review_id": 3078444703,
      "id": 2247461288,
      "node_id": "PRRC_kwDOAP4Jqs6F9Ymo",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 9,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245490407,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Following up on this, I misspoke regarding 2). Its not about being constant time (heapsort is $O(n\\log{}n)$ time, $O(1)$ space), but rather heapsort is unstable so there isn't a straightforward way to do a stable, e.g., multi-key, sort.\r\n\r\nEven if there were a straightforward way, I'd still push back since the protocol is _designed_ to not rely on ordering. Rather, the BIP only specifies grouping by scan key and sorting is just our way of implementing \"grouping.\" I'll flesh out the comment to make this more clear.",
      "created_at": "2025-08-01T09:35:28Z",
      "updated_at": "2025-08-01T09:35:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247461288",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247461288"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247485588",
      "pull_request_review_id": 3078478732,
      "id": 2247485588,
      "node_id": "PRRC_kwDOAP4Jqs6F9eiU",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 38,
      "original_position": 33,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've had this thought a few times in the past. Opened https://github.com/secp256k1lab/secp256k1lab/issues/10 to discuss further, as that seems like the most natural place to me for an example/script to live.",
      "created_at": "2025-08-01T09:45:47Z",
      "updated_at": "2025-08-01T09:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247485588",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247485588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247487614",
      "pull_request_review_id": 3078481228,
      "id": 2247487614,
      "node_id": "PRRC_kwDOAP4Jqs6F9fB-",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 298,
      "original_position": 293,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245582298,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Great point! I'll add a footnote to the BIP.",
      "created_at": "2025-08-01T09:46:19Z",
      "updated_at": "2025-08-01T09:46:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247487614",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247487614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247625218",
      "pull_request_review_id": 3078686422,
      "id": 2247625218,
      "node_id": "PRRC_kwDOAP4Jqs6F-AoC",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 265,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245675709,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-08-01T10:35:07Z",
      "updated_at": "2025-08-01T10:35:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247625218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247625218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247629863",
      "pull_request_review_id": 3078693598,
      "id": 2247629863,
      "node_id": "PRRC_kwDOAP4Jqs6F-Bwn",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 16,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245635733,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. I also took out the first sentence, as it seemed to imply we only need to set the index field in certain situations (the index field must always be set, even if only sending to one silent payment recipient).",
      "created_at": "2025-08-01T10:36:24Z",
      "updated_at": "2025-08-01T10:36:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247629863",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247629863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247633383",
      "pull_request_review_id": 3078699912,
      "id": 2247633383,
      "node_id": "PRRC_kwDOAP4Jqs6F-Cnn",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 9,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245490407,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated the comment to indicate developers cannot and should not rely on deterministic sorting of the recipients.",
      "created_at": "2025-08-01T10:37:16Z",
      "updated_at": "2025-08-01T10:37:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247633383",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247633383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247638059",
      "pull_request_review_id": 3078708175,
      "id": 2247638059,
      "node_id": "PRRC_kwDOAP4Jqs6F-Dwr",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 68,
      "original_position": 45,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245425545,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think this module should include a helper function for this, but we can debate this in a later PR  ",
      "created_at": "2025-08-01T10:39:16Z",
      "updated_at": "2025-08-01T10:39:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247638059",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247638059"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 68,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680706",
      "pull_request_review_id": 3078762032,
      "id": 2247680706,
      "node_id": "PRRC_kwDOAP4Jqs6F-OLC",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 298,
      "original_position": 293,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245582298,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done in https://github.com/bitcoin/bips/pull/1908",
      "created_at": "2025-08-01T10:53:04Z",
      "updated_at": "2025-08-01T10:53:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247680706",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680706"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680951",
      "pull_request_review_id": 3078762423,
      "id": 2247680951,
      "node_id": "PRRC_kwDOAP4Jqs6F-OO3",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 47,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245418259,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-08-01T10:53:14Z",
      "updated_at": "2025-08-01T10:53:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247680951",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680951"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247682028",
      "pull_request_review_id": 3078764200,
      "id": 2247682028,
      "node_id": "PRRC_kwDOAP4Jqs6F-Ofs",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 36,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245393152,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a reminder, with a prompt to review the BIP for more details.",
      "created_at": "2025-08-01T10:53:46Z",
      "updated_at": "2025-08-01T10:53:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247682028",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247682028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254104769",
      "pull_request_review_id": 3087942073,
      "id": 2254104769,
      "node_id": "PRRC_kwDOAP4Jqs6GWujB",
      "diff_hunk": "@@ -0,0 +1,619 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].labeled_spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 252,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "e0c225c047645ae92db877f661ede385f4f8603d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in e0c225c047645ae92db877f661ede385f4f8603d: this comment seems outdated? the cast for `tx_output_ptrs` is now happening at the scan function below (from non-const to const rather than the other way round)",
      "created_at": "2025-08-05T11:47:25Z",
      "updated_at": "2025-08-05T13:33:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2254104769",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254104769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 248,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254202085",
      "pull_request_review_id": 3087942073,
      "id": 2254202085,
      "node_id": "PRRC_kwDOAP4Jqs6GXGTl",
      "diff_hunk": "@@ -0,0 +1,619 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    /* Randomizing the context is recommended to protect against side-channel\n+     * leakage. See `secp256k1_context_randomize` in secp256k1.h for more\n+     * information about it. This should never fail. */\n+    ret = secp256k1_context_randomize(ctx, randomize);\n+    assert(ret);\n+\n+    /*** Sending ***/\n+    {\n+        secp256k1_keypair sender_keypairs[N_INPUTS];\n+        const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\n+        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\n+        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\n+        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\n+        unsigned char seckey[32];\n+\n+        /*** Generate private keys for the sender ***\n+         *\n+         * In this example, only taproot inputs are used but the function can be\n+         * called with a mix of taproot seckeys and plain seckeys. Taproot\n+         * seckeys are passed as keypairs to allow the sending function to check\n+         * if the private keys need to be negated without needing to do an\n+         * expensive pubkey generation. This is not needed for plain seckeys\n+         * since there is no need for negation.\n+         *\n+         * The public key from each input keypair is saved in the `tx_inputs`\n+         * array. This array will be used later in the example to represent the\n+         * public keys the recipient will extract from the transaction inputs.\n+         *\n+         * If the secret key is zero or out of range (bigger than secp256k1's\n+         * order), fail. Note that the probability of this happening is\n+         * negligible. */\n+        for (i = 0; i < N_INPUTS; i++) {\n+            if (!fill_random(seckey, sizeof(seckey))) {\n+                printf(\"Failed to generate randomness\\n\");\n+                return EXIT_FAILURE;\n+            }\n+            /* Try to create a keypair with a valid context, it should only fail\n+             * if the secret key is zero or out of range. */\n+            if (secp256k1_keypair_create(ctx, &sender_keypairs[i], seckey)) {\n+                sender_keypair_ptrs[i] = &sender_keypairs[i];\n+                ret = secp256k1_keypair_xonly_pub(\n+                    ctx,\n+                    &tx_inputs[i],\n+                    NULL,\n+                    &sender_keypairs[i]\n+                );\n+                assert(ret);\n+            } else {\n+                printf(\"Failed to create keypair\\n\");\n+                return EXIT_FAILURE;\n+            }\n+        }\n+        /*** Create the recipient objects ***/\n+\n+        /* Alice is sending to Bob and Carol in this transaction:\n+         *\n+         *     1. One output to Bob's labeled address\n+         *     2. Two outputs for Carol\n+         *\n+         * To create multiple outputs for Carol, Alice simply passes Carol's\n+         * silent payment address mutltiple times.\n+         */\n+        sp_addresses[0] = &carol_address;\n+        sp_addresses[1] = &bob_address;\n+        sp_addresses[2] = &carol_address;\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            ret = secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].scan_pubkey,\n+                (*(sp_addresses[i]))[0],\n+                33\n+            );\n+            ret &= secp256k1_ec_pubkey_parse(ctx,\n+                &recipients[i].labeled_spend_pubkey,\n+                (*(sp_addresses[i]))[1],\n+                33\n+            );\n+            if (!ret) {\n+                printf(\"\\n\");\n+                printf(\"Something went wrong, this is not a valid silent payments address.\");\n+                return EXIT_FAILURE;\n+            }\n+\n+            /* Alice creates the recipient objects and adds the index of the\n+             * original ordering (the ordering of the `sp_addresses` array) to\n+             * each object. This index is used to return the generated outputs\n+             * in the original ordering so that Alice can match up the generated\n+             * outputs with the correct amounts.\n+             */\n+            recipients[i].index = i;\n+            recipient_ptrs[i] = &recipients[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+        /* To keep things simple, we cast the tx_output_ptr array to remove the\n+         * const qualifer, so that we can create the outputs. We want the const\n+         * qualifer because this same array will be passed to the scan function\n+         * later in the example.\n+         */\n+        ret = secp256k1_silentpayments_sender_create_outputs(ctx,\n+            tx_output_ptrs,\n+            recipient_ptrs, N_OUTPUTS,\n+            smallest_outpoint,\n+            sender_keypair_ptrs, N_INPUTS,\n+            NULL, 0\n+        );\n+        assert(ret);\n+        printf(\"Alice created the following outputs for Bob and Carol: \\n\");\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            printf(\"    \");\n+            secp256k1_xonly_pubkey_serialize(ctx,\n+                serialized_xonly,\n+                &tx_outputs[i]\n+            );\n+            print_hex(serialized_xonly, sizeof(serialized_xonly));\n+        }\n+        /* It's best practice to try to clear secrets from memory after using\n+         * them. This is done because some bugs can allow an attacker to leak\n+         * memory, for example through \"out of bounds\" array access (see\n+         * Heartbleed), or the OS swapping them to disk. Hence, we overwrite the\n+         * secret key buffer with zeros.\n+         *\n+         * Here we are preventing these writes from being optimized out, as any\n+         * good compiler will remove any writes that aren't used. */\n+        secure_erase(seckey, sizeof(seckey));\n+        for (i = 0; i < N_INPUTS; i++) {\n+            secure_erase(&sender_keypairs[i], sizeof(sender_keypairs[i]));\n+        }\n+    }\n+\n+    /*** Receiving ***/\n+    {\n+        unsigned char light_client_data33[33];\n+\n+        for (i = 0; i < N_INPUTS; i++) {\n+            tx_input_ptrs[i] = &tx_inputs[i];\n+        }\n+        for (i = 0; i < N_OUTPUTS; i++) {\n+            tx_output_ptrs[i] = &tx_outputs[i];\n+        }\n+\n+        {\n+            /*** Scanning as a full node (Bob) ***\n+             *\n+             * Since Bob has access to the full transaction, scanning is simple:\n+             *\n+             *     1. Collect the relevant public data from the transaction\n+             *        and call `_silentpayments_recipient_public_data_create`\n+             *     2. Call `_silentpayments_recipient_scan_outputs`\n+             *\n+             */\n+            secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\n+            secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\n+            secp256k1_silentpayments_recipient_public_data public_data;\n+            secp256k1_pubkey spend_pubkey;\n+            secp256k1_pubkey labeled_spend_pubkey;\n+            secp256k1_pubkey address_labeled_spend_pubkey;\n+            size_t n_found_outputs;\n+            struct labels_cache labels_cache;\n+\n+            for (i = 0; i < N_OUTPUTS; i++) {\n+                found_output_ptrs[i] = &found_outputs[i];\n+            }\n+            {\n+                /** Labels setup\n+                 *\n+                 *  These steps are only necessary if the recipient is using the\n+                 *  optional labels feature. Recipients not using labels can\n+                 *  ignore these steps and simply pass `NULL` for the\n+                 *  label_lookup and label_context arguments:\n+                 *\n+                 *      _silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+                 *\n+                 *  In this case, since Bob has access to the full transaction\n+                 *  outputs when scanning, it's easy for him to scan with labels,\n+                 *  as demonstrated below. For efficient scanning, Bob keeps a\n+                 *  cache of every label he has previously used and uses a\n+                 *  callback to check if a potential label exists in his cache.\n+                 *  Since the labels are created using an incremental integer\n+                 *  `m`, if Bob ever forgets how many labels he has previously\n+                 *  used, he can pregenerate a large number of labels e.g.,\n+                 *  0..100_000.\n+                 */\n+                size_t len = 33;\n+                secp256k1_pubkey label;\n+                unsigned int m = 1;\n+\n+                /* Load Bob's spend public key */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &spend_pubkey,\n+                    bob_spend_pubkey,\n+                    33\n+                );\n+                assert(ret);\n+\n+                /* Add an entry to the cache. This implies Bob has previously\n+                 * called\n+                 * `secp256k1_silentpayments_recipient_create_labeled_spend_pubkey`\n+                 * and is using the resulting labeled spend pubkey to encode a\n+                 * labeled silent payments address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_label(ctx,\n+                    &label,\n+                    labels_cache.entries[0].label_tweak,\n+                    bob_scan_key,\n+                    m\n+                );\n+                assert(ret);\n+                ret = secp256k1_ec_pubkey_serialize(ctx,\n+                    labels_cache.entries[0].label,\n+                    &len,\n+                    &label,\n+                    SECP256K1_EC_COMPRESSED\n+                );\n+                assert(ret);\n+                labels_cache.entries_used = 1;\n+\n+                /* Verify the label we just created and added to the cache is the\n+                 * same one used in Bob's silent payment address.\n+                 */\n+                ret = secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(ctx,\n+                    &labeled_spend_pubkey,\n+                    &spend_pubkey,\n+                    &label\n+                );\n+                assert(ret);\n+                /* Load the labeled spend public key from Bob's address */\n+                ret = secp256k1_ec_pubkey_parse(ctx,\n+                    &address_labeled_spend_pubkey,\n+                    bob_address[1],\n+                    33\n+                );\n+                assert(ret);\n+                if (secp256k1_ec_pubkey_cmp(ctx, &labeled_spend_pubkey, &address_labeled_spend_pubkey) != 0) {\n+                    printf(\"\\n\");\n+                    printf(\"Something went wrong, the labeled spend public key does not match Bob's address.\");\n+                };\n+            }\n+\n+            /* Bob collects the public data from the transaction inputs and\n+             * creates a `secp256k1_silentpayments_recipient_public_data` object. He uses\n+             * this for his own scanning and also serializes the `public_data`\n+             * object to send to light clients. We will use this later for\n+             * Carol, who is scanning as a light client. Note, anyone can create\n+             * and provide these `public_data` objects, i.e. you don't need to be\n+             * a silent payments wallet, just someone interested in providing this\n+             * data to light clients, e.g. a wallet service provider. In our\n+             * example, Bob is scanning for himself but also sharing this data\n+             * with light clients.\n+             */\n+            ret = secp256k1_silentpayments_recipient_public_data_create(ctx,\n+                &public_data,\n+                smallest_outpoint,\n+                tx_input_ptrs, N_INPUTS,\n+                NULL, 0 /* NULL because no eligible plain pubkey inputs were found in the tx */\n+            );\n+            if (!ret) {\n+                /* We need to always check that the public data object is valid\n+                 * before proceeding, since a malicious actor could create a transaction\n+                 * such that the input public keys sum to the point at infinity, which\n+                 * could cause our node to crash if, e.g., we assume that public_data_create\n+                 * will always succeed.\"\n+                 */\n+                printf(\"\\n\");\n+                printf(\"This transaction is not valid for silent payments, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            /* Serialize the public data object for later use. */\n+            ret = secp256k1_silentpayments_recipient_public_data_serialize(ctx,\n+                light_client_data33,\n+                &public_data\n+            );\n+            assert(ret);\n+\n+            /* Scan the transaction */\n+            n_found_outputs = 0;\n+            ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\n+                found_output_ptrs, &n_found_outputs,\n+                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\n+                bob_scan_key,\n+                &public_data,\n+                &spend_pubkey,\n+                label_lookup, &labels_cache /* NULL, NULL for no labels */\n+            );\n+            if (!ret) {\n+                /* Since we've already validated the public data, this shouldn't fail, but\n+                 * better to be careful here since we are scanning data that could have been\n+                 * maliciously created.\n+                 */\n+                printf(\"\\n\");\n+                printf(\"Something went wrong while scanning this transaction, skipping.\");\n+                return EXIT_SUCCESS;\n+            }\n+            if (n_found_outputs > 0) {\n+                secp256k1_keypair kp;\n+                secp256k1_xonly_pubkey xonly_output;\n+                unsigned char full_seckey[32];\n+\n+                printf(\"\\n\");\n+                printf(\"Bob found the following outputs: \\n\");\n+                for (i = 0; i < n_found_outputs; i++) {\n+                    printf(\"    \");\n+                    secp256k1_xonly_pubkey_serialize(ctx,\n+                        serialized_xonly,\n+                        &found_outputs[i].output\n+                    );",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 459,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "e0c225c047645ae92db877f661ede385f4f8603d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in e0c225c047645ae92db877f661ede385f4f8603d:\r\n```suggestion\r\n                    ret = secp256k1_xonly_pubkey_serialize(ctx,\r\n                        serialized_xonly,\r\n                        &found_outputs[i].output\r\n                    );\r\n                    assert(ret);\r\n```\r\njust to evaluate all API call return values for consistency (here and in the light client scanning loop below)",
      "created_at": "2025-08-05T12:30:39Z",
      "updated_at": "2025-08-05T13:33:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2254202085",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254202085"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 456,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254258008",
      "pull_request_review_id": 3087942073,
      "id": 2254258008,
      "node_id": "PRRC_kwDOAP4Jqs6GXT9Y",
      "diff_hunk": "@@ -25,6 +26,94 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the taproot secret keys are negated to enforce even y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the secret keys correspond to x-only\n+ *  (taproot) outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 75,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "e0c7a09415de00e94e8a8c8fc3c5154d00cc0739",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in e0c7a09415de00e94e8a8c8fc3c5154d00cc0739:\r\n```suggestion\r\n *       outpoint_smallest36: serialized (36-byte) smallest outpoint\r\n```\r\n(also in the description above)",
      "created_at": "2025-08-05T12:53:43Z",
      "updated_at": "2025-08-05T13:33:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2254258008",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254258008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254306773",
      "pull_request_review_id": 3087942073,
      "id": 2254306773,
      "node_id": "PRRC_kwDOAP4Jqs6GXf3V",
      "diff_hunk": "@@ -165,6 +168,256 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used or context is not needed)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs,\n+    size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs,\n+    size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)\n+    SECP256K1_ARG_NONNULL(6) SECP256K1_ARG_NONNULL(7) SECP256K1_ARG_NONNULL(8);\n+\n+/** Create Silent Payment shared secret.\n+ *\n+ *  Given the public input data (secp256k1_silentpayments_recipient_public_data),\n+ *  and the recipient's 32 byte scan key, calculate the shared secret.\n+ *\n+ *  The resulting shared secret is needed as input for creating silent payments\n+ *  outputs belonging to the same recipient scan public key. This function is\n+ *  intended for light clients, i.e., scenarios where the caller does not have\n+ *  access to the full transaction. If the caller does have access to the full\n+ *  transaction, `secp256k1_silentpayments_recipient_scan_outputs` should be\n+ *  used instead.\n+ *\n+ *  Returns: 1 if shared secret creation was successful. 0 if an error occurred.\n+ *  Args:                  ctx: pointer to a context object\n+ *  Out:       shared_secret33: pointer to the resulting 33-byte shared secret\n+ *  In:   recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                 public_data: pointer to the public_data object, loaded using\n+ *                              `_recipient_public_data_parse`\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_shared_secret(\n+    const secp256k1_context *ctx,\n+    unsigned char *shared_secret33,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment output public key.\n+ *\n+ *  Given a shared_secret, a public key B_spend, and an output counter k,\n+ *  create an output public key.\n+ *\n+ *  This function is used by the recipient when scanning for outputs without\n+ *  access to the transaction outputs (e.g., using BIP158 block filters). When\n+ *  scanning with this function, it is the scanners responsibility to determine\n+ *  if the generated output exists in a block before proceeding to the next\n+ *  value of `k`.\n+ *\n+ *  Returns: 1 if output creation was successful. 0 if an error occurred.\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:         P_output_xonly: pointer to the resulting output x-only pubkey\n+ *  In:         shared_secret33: shared secret, derived from either sender's\n+ *                               or recipient's perspective with routines from\n+ *                               above\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                               (labeled or unlabeled)\n+ *                            k: output counter (initially set to 0, must be\n+ *                               incremented for each additional output created\n+ *                               or after each output found when scanning)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_output_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey *P_output_xonly,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 274,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "0a79d3a2e516d7dea07023e68a94aa37842f9be5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could maybe consider removing the `P_` prefix as we don't use this naming scheme anywhere else in this or other modules (I think I introduced that in the first take of the BIP352 module for some reason)",
      "created_at": "2025-08-05T13:12:28Z",
      "updated_at": "2025-08-05T13:33:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2254306773",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2254306773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 415,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263241107",
      "pull_request_review_id": 3101192531,
      "id": 2263241107,
      "node_id": "PRRC_kwDOAP4Jqs6G5lGT",
      "diff_hunk": "@@ -53,7 +56,7 @@ typedef struct secp256k1_silentpayments_recipient {\n  *  public keys are excluded from silent payments eligible inputs; see BIP352\n  *  for more information.\n  *\n- *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 22,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "32d8077cb7d288c7114dcf8d7b831d7ada590bd0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 32d8077cb7d288c7114dcf8d7b831d7ada590bd0: minimum-diff pedantic nit: this change, as well as all other single-line changes in the same commit below should already be part of an earlier commit",
      "created_at": "2025-08-08T15:09:42Z",
      "updated_at": "2025-08-08T15:58:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2263241107",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263241107"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 56,
      "start_side": "LEFT",
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263288446",
      "pull_request_review_id": 3101192531,
      "id": 2263288446,
      "node_id": "PRRC_kwDOAP4Jqs6G5wp-",
      "diff_hunk": "@@ -25,6 +26,97 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the taproot secret keys are negated to enforce even y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the secret keys correspond to x-only\n+ *  (taproot) outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (stastically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 56,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "d176c1e5d83298e9f60e4d34fe6f40b1a4e679c5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *             (statistically improbable).\r\n```\r\n(here and in many other instances)",
      "created_at": "2025-08-08T15:30:40Z",
      "updated_at": "2025-08-08T15:58:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2263288446",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263288446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263308971",
      "pull_request_review_id": 3101192531,
      "id": 2263308971,
      "node_id": "PRRC_kwDOAP4Jqs6G51qr",
      "diff_hunk": "@@ -25,6 +26,97 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the taproot secret keys are negated to enforce even y-parity.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 48,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "d176c1e5d83298e9f60e4d34fe6f40b1a4e679c5",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Not knowing the answer myself, but I'm wondering now whether internal details like this should be part of the header API documentation (that's slightly related to the questions brought up at https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3159769239 about the proper detail level of error case documentation), or if it's just sufficient to say that there are two secret key types that are somehow treated differently. Or even just remove the sentence completely (and the \"For that reason\" part). Maybe it's not a big deal to keep it, but I'd assume the user of the module likely doesn't care (and shouldn't) what exactly is going on under the hood at this detail level. That sentence was already part of the first take at #1471, so all the blame goes to me anyways :sweat_smile: ",
      "created_at": "2025-08-08T15:41:05Z",
      "updated_at": "2025-08-08T15:58:03Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2263308971",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2263308971"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2265970427",
      "pull_request_review_id": 3104590579,
      "id": 2265970427,
      "node_id": "PRRC_kwDOAP4Jqs6HD_b7",
      "diff_hunk": "@@ -25,6 +26,97 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the taproot secret keys are negated to enforce even y-parity.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 48,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "d176c1e5d83298e9f60e4d34fe6f40b1a4e679c5",
      "in_reply_to_id": 2263308971,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch, I think keeping the API documentation focused on usage makes sense. In this case, I think we can safely drop line 65 to the end. `libsecp256k1` already has different data types for plain keys and taproot keys, which I think is explanation enough for a user as to why we have two different arguments for accepting secret keys in this function.",
      "created_at": "2025-08-11T08:06:55Z",
      "updated_at": "2025-08-11T08:06:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2265970427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2265970427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2265971983",
      "pull_request_review_id": 3104592755,
      "id": 2265971983,
      "node_id": "PRRC_kwDOAP4Jqs6HD_0P",
      "diff_hunk": "@@ -25,6 +26,97 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the taproot secret keys are negated to enforce even y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the secret keys correspond to x-only\n+ *  (taproot) outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (stastically improbable).",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 56,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "d176c1e5d83298e9f60e4d34fe6f40b1a4e679c5",
      "in_reply_to_id": 2263288446,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Turns out I am not as good a typist as I thought I was  ",
      "created_at": "2025-08-11T08:07:46Z",
      "updated_at": "2025-08-11T08:07:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2265971983",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2265971983"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268166071",
      "pull_request_review_id": 3107973701,
      "id": 2268166071,
      "node_id": "PRRC_kwDOAP4Jqs6HMXe3",
      "diff_hunk": "@@ -0,0 +1,258 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *             Seckey: secret key for Alice\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46,0x0d,0x68,0x08,0x65,0x64,0x45,0xee,\n+    0x4d,0x4e,0xc0,0x8e,0xba,0x8a,0x66,0xea,\n+    0x66,0x8e,0x4e,0x12,0x98,0x9a,0x0e,0x60,\n+    0x4b,0x5c,0x36,0x0e,0x43,0xf5,0x5a,0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7,0xf3,0xc6,0x79,0x30,0x4a,0xef,0x8c,\n+    0xc0,0xc7,0x61,0xf1,0x00,0x99,0xdd,0x7b,\n+    0x20,0x65,0x20,0xd7,0x11,0x6f,0xb7,0x91,\n+    0xee,0x74,0x54,0xa2,0xfc,0x22,0x79,0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b,0x81,0x34,0x5d,0x53,0x89,0xba,0xa3,\n+    0xd8,0x93,0xe2,0xfb,0xe7,0x08,0xdd,0x6d,\n+    0x82,0xdc,0xd8,0x49,0xab,0x03,0xc1,0xdb,\n+    0x68,0xbe,0xc7,0xe9,0x2a,0x45,0xfa,0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea,0xdc,0x78,0x16,0x5f,0xf1,0xf8,0xea,\n+    0x94,0xad,0x7c,0xfd,0xc5,0x49,0x90,0x73,\n+    0x8a,0x4c,0x53,0xf6,0xe0,0x50,0x7b,0x42,\n+    0x15,0x42,0x01,0xb8,0xe5,0xdf,0xf3,0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].labeled_spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    /* Note: in this case, the second output for Carol comes before the first.\n+     * This is because heapsort is an unstable sorting algorithm, i.e., the ordering\n+     * of identical elements is not guaranteed to be preserved\n+     */\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &CAROL_OUTPUT_ONE;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}\n+\n+static void test_send_api(void) {\n+    unsigned char (*sp_addresses[2])[2][33];\n+    unsigned char const *p[1];\n+    secp256k1_keypair const *t[1];\n+    secp256k1_silentpayments_recipient r[2];\n+    const secp256k1_silentpayments_recipient *rp[2];\n+    secp256k1_xonly_pubkey o[2];\n+    secp256k1_xonly_pubkey *op[2];\n+    secp256k1_keypair taproot;\n+    size_t i;\n+\n+    /* Set up Bob and Carol as the recipients */\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].labeled_spend_pubkey,(*sp_addresses[i])[1], 33));\n+        /* Set the index value incorrectly */\n+        r[i].index = 0;\n+        rp[i] = &r[i];\n+        op[i] = &o[i];\n+    }\n+    /* Set up a taproot key and a plain key for Alice */\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    t[0] = &taproot;\n+    p[0] = ALICE_SECKEY;\n+\n+    /* Fails if the index is set incorrectly */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Set the index correctly for the next tests */\n+    for (i = 0; i < 2; i++) {\n+        r[i].index = i;\n+    }\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that null arguments are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, NULL, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, NULL, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, NULL, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 1));\n+\n+    /* Check correct context is used */\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_silentpayments_sender_create_outputs(STATIC_CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that array arguments are verified */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, NULL, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 0, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 0));\n+\n+    /* Create malformed keys for Alice by using a key that will overflow */\n+    p[0] = ORDERC;\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    /* Malleate the keypair object so that the secret key is all zeros. We need to keep\n+     * public key as is since it is loaded first and would hit an ARG_CHECK if invalid.\n+     */\n+    memset(&taproot.data[0], 0, 32);\n+    /* Check that an invalid plain secret key is caught */\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    /* Check that an invalid keypair is caught */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 0));\n+    /* Create malformed keys for Alice by using a zero'd seckey */\n+    p[0] = MALFORMED_SECKEY;\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    p[0] = ALICE_SECKEY;\n+    /* Create malformed recipients by setting all of the public key bytes to zero.\n+     * Realistically, this would never happen since a bad public key would get caught when\n+     * trying to parse the public key with _ec_pubkey_parse\n+     */\n+    memset(&r[1].labeled_spend_pubkey.data, 0, sizeof(secp256k1_pubkey));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+    {\n+         secp256k1_pubkey tmp = r[1].labeled_spend_pubkey;\n+         memset(&r[1].labeled_spend_pubkey, 0, sizeof(r[1].labeled_spend_pubkey));\n+         CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 237,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "051ad339427fa7e69246e372b98d61c5a0e04ab0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Seems like this `memset` is a no-op and the test a repetition of the one four lines above. Was the idea here to run the previous test without damaging the spend pubkey of `r[1]` first? (would make sense considering that it is saved and restored via `tmp`)",
      "created_at": "2025-08-11T22:43:06Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268166071",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268166071"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 236,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268167935",
      "pull_request_review_id": 3107973701,
      "id": 2268167935,
      "node_id": "PRRC_kwDOAP4Jqs6HMX7_",
      "diff_hunk": "@@ -0,0 +1,258 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *             Seckey: secret key for Alice\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 19,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "051ad339427fa7e69246e372b98d61c5a0e04ab0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nitty nit: for easier matching for the reader, could sort these constant descriptions in the same order as they appear in the array definitions below",
      "created_at": "2025-08-11T22:44:43Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268167935",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268167935"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 13,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 19,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268208257",
      "pull_request_review_id": 3107973701,
      "id": 2268208257,
      "node_id": "PRRC_kwDOAP4Jqs6HMhyB",
      "diff_hunk": "@@ -164,6 +167,262 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 135,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: slightly more specific (as the current wording implies that the actual cache data structure can be created with this module)\r\n```suggestion\r\n *  For creating the labels cache data (label public key and label tweak),\r\n```\r\nor just\r\n```suggestion\r\n *  For creating the labels cache data,\r\n```",
      "created_at": "2025-08-11T23:20:14Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268208257",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268208257"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268232573",
      "pull_request_review_id": 3107973701,
      "id": 2268232573,
      "node_id": "PRRC_kwDOAP4Jqs6HMnt9",
      "diff_hunk": "@@ -131,28 +131,28 @@ static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, co\n     secp256k1_sha256_clear(&hash);\n }\n \n-static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n-    secp256k1_ge P_output_ge;\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 6,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "reviewer-friendliness nit: the P_ prefix removal should be part of an earlier commit already to not create extra diff lines",
      "created_at": "2025-08-11T23:37:16Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268232573",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268232573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268236399",
      "pull_request_review_id": 3107973701,
      "id": 2268236399,
      "node_id": "PRRC_kwDOAP4Jqs6HMopv",
      "diff_hunk": "@@ -375,4 +375,350 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(pubkeylen == 33);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 167,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "for consistency, could still `VERIFY_CHECK` the return values of these two function calls",
      "created_at": "2025-08-11T23:41:50Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268236399",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268236399"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 503,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 505,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268250793",
      "pull_request_review_id": 3107973701,
      "id": 2268250793,
      "node_id": "PRRC_kwDOAP4Jqs6HMsKp",
      "diff_hunk": "@@ -375,4 +375,350 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(pubkeylen == 33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes where the input_hash would be\n+     */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 1;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &pk);\n+    memset(&public_data->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy.\n+     *\n+     * However, if there is something wrong with the recipient scan key, recipient spend pubkey, or the public data,\n+     * we fail early and make sure to clear the scan key from memory. */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&A_sum_ge, &public_data->data[5]);\n+    combined = (int)public_data->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k is the negation of B_spend, but this is statistically\n+         * improbable as t_k is the output of a hash function. */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided) */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge P_output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&P_output_negated_ge, &P_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 * label1 = tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* serialize must succeed because the point was just loaded */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 * label2 = -tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* serialize must succeed because the point was just loaded */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+            }\n+        }\n+        if (found) {\n+            found_outputs[n_found]->output = *tx_outputs[found_idx];\n+            secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+            if (label_tweak != NULL) {\n+                found_outputs[n_found]->found_with_label = 1;\n+                /* This is extremely unlikely to fail in that it can only really fail if label_tweak\n+                 * is the negation of the shared secret tweak. But since both tweak and label_tweak are\n+                 * created by hashing data, practically speaking this would only happen if an attacker\n+                 * tricked us into using a particular label_tweak (deviating from the protocol).\n+                 */\n+                ret = secp256k1_ec_seckey_tweak_add(ctx, found_outputs[n_found]->tweak, label_tweak);\n+                VERIFY_CHECK(ret);\n+                secp256k1_pubkey_save(&found_outputs[n_found]->label, &label_ge);\n+            } else {\n+                found_outputs[n_found]->found_with_label = 0;\n+                /* Set the label public key with an invalid public key value */\n+                secp256k1_memclear(&found_outputs[n_found]->label, sizeof(secp256k1_pubkey));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 328,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: a regular `memset` is sufficient here, as this is no stack data (and not secret data either)",
      "created_at": "2025-08-11T23:56:57Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268250793",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268250793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 666,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268254431",
      "pull_request_review_id": 3107973701,
      "id": 2268254431,
      "node_id": "PRRC_kwDOAP4Jqs6HMtDf",
      "diff_hunk": "@@ -375,4 +375,350 @@ int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256\n     return 1;\n }\n \n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(pubkeylen == 33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes where the input_hash would be\n+     */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 1;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &pk);\n+    memset(&public_data->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy.\n+     *\n+     * However, if there is something wrong with the recipient scan key, recipient spend pubkey, or the public data,\n+     * we fail early and make sure to clear the scan key from memory. */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&A_sum_ge, &public_data->data[5]);\n+    combined = (int)public_data->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k is the negation of B_spend, but this is statistically\n+         * improbable as t_k is the output of a hash function. */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&P_output_xonly, &P_output_ge);\n+        for (i = 0; i < n_tx_outputs; i++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &P_output_xonly, tx_outputs[i]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = i;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided) */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge P_output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[i]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                secp256k1_ge_neg(&P_output_negated_ge, &P_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 * label1 = tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* serialize must succeed because the point was just loaded */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 * label2 = -tx_output - P_output */\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &P_output_negated_ge, NULL);\n+                secp256k1_ge_set_gej(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* serialize must succeed because the point was just loaded */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = i;\n+                    break;\n+                }\n+            }\n+        }\n+        if (found) {\n+            found_outputs[n_found]->output = *tx_outputs[found_idx];\n+            secp256k1_scalar_get_b32(found_outputs[n_found]->tweak, &t_k_scalar);\n+            if (label_tweak != NULL) {\n+                found_outputs[n_found]->found_with_label = 1;\n+                /* This is extremely unlikely to fail in that it can only really fail if label_tweak\n+                 * is the negation of the shared secret tweak. But since both tweak and label_tweak are\n+                 * created by hashing data, practically speaking this would only happen if an attacker\n+                 * tricked us into using a particular label_tweak (deviating from the protocol).\n+                 */\n+                ret = secp256k1_ec_seckey_tweak_add(ctx, found_outputs[n_found]->tweak, label_tweak);\n+                VERIFY_CHECK(ret);\n+                secp256k1_pubkey_save(&found_outputs[n_found]->label, &label_ge);\n+            } else {\n+                found_outputs[n_found]->found_with_label = 0;\n+                /* Set the label public key with an invalid public key value */\n+                secp256k1_memclear(&found_outputs[n_found]->label, sizeof(secp256k1_pubkey));\n+            }\n+            /* Set everything for the next round of scanning */\n+            label_tweak = NULL;\n+            n_found++;\n+            k++;\n+        } else {\n+            break;\n+        }\n+    }\n+    *n_found_outputs = n_found;\n+    /* Explicitly clear secrets. Recall that the scan key is not quite \"secret\" in that leaking the scan key\n+     * results in a loss of privacy, not a loss of funds\n+     */\n+    secp256k1_scalar_clear(&rsk_scalar);\n+    /* Explicitly clear the shared secret. While this isn't technically \"secret data,\" any third party\n+     * with access to the shared secret could potentially identify and link the transaction back to the\n+     * recipient address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    secp256k1_memclear(shared_secret, sizeof(shared_secret));\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const unsigned char *recipient_scan_key32, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_scalar rsk;\n+    secp256k1_ge A_tweaked_ge;\n+    int ret;\n+    /* Sanity check inputs */\n+    ARG_CHECK(shared_secret33 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(public_data->data[4] == 1);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(&A_tweaked_ge, &public_data->data[5]);\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk, recipient_scan_key32);\n+    /* If there are any issues with the recipient scan key, return early */\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret33, &rsk, &A_tweaked_ge);\n+\n+    /* Explicitly clear secrets */\n+    secp256k1_scalar_clear(&rsk);\n+    return ret;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 373,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "equivalent but more explicit (ret can only be 1 at this point)\r\n```suggestion\r\n    return 1;\r\n```",
      "created_at": "2025-08-12T00:00:18Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268254431",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268254431"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 711,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268280579",
      "pull_request_review_id": 3107973701,
      "id": 2268280579,
      "node_id": "PRRC_kwDOAP4Jqs6HMzcD",
      "diff_hunk": "@@ -273,6 +274,10 @@ src/wycheproof/ecdh_secp256k1_test.h:\n \tmkdir -p $(@D)\n \tpython3 $(top_srcdir)/tools/tests_wycheproof_generate_ecdh.py $(top_srcdir)/src/wycheproof/ecdh_secp256k1_test.json > $@\n \n+src/modules/silentpayments/vectors.h:\n+\tmkdir -p $(@D)\n+\tpython3 $(top_srcdir)/tools/tests_silentpayments_generate.py $(top_srcdir)/src/modules/silentpayments/bip352_send_and_receive_test_vectors.json > $@",
      "path": "Makefile.am",
      "position": 32,
      "original_position": 14,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "b1138b20a45adff4818b023d7ea80569e3dacaba",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "unrelated nit: noted that there is no CMake-equivalent for that, but it's not for any other generated test vectors either, so probably a topic for a different PR (if at all, I assume test vectors are usually just updated by manual script runs rather than involving the build system)",
      "created_at": "2025-08-12T00:23:41Z",
      "updated_at": "2025-08-12T00:32:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2268280579",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2268280579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 277,
      "original_start_line": 277,
      "start_side": "RIGHT",
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269183460",
      "pull_request_review_id": 3109372347,
      "id": 2269183460,
      "node_id": "PRRC_kwDOAP4Jqs6HQP3k",
      "diff_hunk": "@@ -164,6 +167,262 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipien\n     const secp256k1_pubkey *label\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful.\n+ *           0 if the input public keys sum to zero,\n+ *             or the input_hash is an invalid scalar (statistically improbable).\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 135,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "b107203694439ddf261f474c132d42040bd3db6c",
      "in_reply_to_id": 2268208257,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think \"data\" should be sufficient, considering the data is better explained in the documentation for the `_create_label` function.",
      "created_at": "2025-08-12T08:59:10Z",
      "updated_at": "2025-08-12T08:59:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269183460",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269183460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269244971",
      "pull_request_review_id": 3109482971,
      "id": 2269244971,
      "node_id": "PRRC_kwDOAP4Jqs6HQe4r",
      "diff_hunk": "@@ -273,6 +274,10 @@ src/wycheproof/ecdh_secp256k1_test.h:\n \tmkdir -p $(@D)\n \tpython3 $(top_srcdir)/tools/tests_wycheproof_generate_ecdh.py $(top_srcdir)/src/wycheproof/ecdh_secp256k1_test.json > $@\n \n+src/modules/silentpayments/vectors.h:\n+\tmkdir -p $(@D)\n+\tpython3 $(top_srcdir)/tools/tests_silentpayments_generate.py $(top_srcdir)/src/modules/silentpayments/bip352_send_and_receive_test_vectors.json > $@",
      "path": "Makefile.am",
      "position": 32,
      "original_position": 14,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "b1138b20a45adff4818b023d7ea80569e3dacaba",
      "in_reply_to_id": 2268280579,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Would consider this a follow-up as a more general build system improvement.",
      "created_at": "2025-08-12T09:22:31Z",
      "updated_at": "2025-08-12T09:22:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269244971",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269244971"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 277,
      "original_start_line": 277,
      "start_side": "RIGHT",
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269261738",
      "pull_request_review_id": 3109526848,
      "id": 2269261738,
      "node_id": "PRRC_kwDOAP4Jqs6HQi-q",
      "diff_hunk": "@@ -273,6 +274,10 @@ src/wycheproof/ecdh_secp256k1_test.h:\n \tmkdir -p $(@D)\n \tpython3 $(top_srcdir)/tools/tests_wycheproof_generate_ecdh.py $(top_srcdir)/src/wycheproof/ecdh_secp256k1_test.json > $@\n \n+src/modules/silentpayments/vectors.h:\n+\tmkdir -p $(@D)\n+\tpython3 $(top_srcdir)/tools/tests_silentpayments_generate.py $(top_srcdir)/src/modules/silentpayments/bip352_send_and_receive_test_vectors.json > $@",
      "path": "Makefile.am",
      "position": 32,
      "original_position": 14,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "b1138b20a45adff4818b023d7ea80569e3dacaba",
      "in_reply_to_id": 2268280579,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> (if at all, I assume test vectors are usually just updated by manual script runs rather than involving the build system)\r\n\r\nThe current idea is that you can manually delete the files, and the build system will then regenerate them (and you don't need to worry about how this is done). And yes, that's restricted to autotools, which is fine because it's a developer-only thing. Decoupling this from the build system entirely would also be an option.\r\n\r\nAnyway, none of this is related to this PR.",
      "created_at": "2025-08-12T09:29:18Z",
      "updated_at": "2025-08-12T09:29:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269261738",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269261738"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 277,
      "original_start_line": 277,
      "start_side": "RIGHT",
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269272477",
      "pull_request_review_id": 3109559266,
      "id": 2269272477,
      "node_id": "PRRC_kwDOAP4Jqs6HQlmd",
      "diff_hunk": "@@ -0,0 +1,258 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *             Seckey: secret key for Alice\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46,0x0d,0x68,0x08,0x65,0x64,0x45,0xee,\n+    0x4d,0x4e,0xc0,0x8e,0xba,0x8a,0x66,0xea,\n+    0x66,0x8e,0x4e,0x12,0x98,0x9a,0x0e,0x60,\n+    0x4b,0x5c,0x36,0x0e,0x43,0xf5,0x5a,0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7,0xf3,0xc6,0x79,0x30,0x4a,0xef,0x8c,\n+    0xc0,0xc7,0x61,0xf1,0x00,0x99,0xdd,0x7b,\n+    0x20,0x65,0x20,0xd7,0x11,0x6f,0xb7,0x91,\n+    0xee,0x74,0x54,0xa2,0xfc,0x22,0x79,0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b,0x81,0x34,0x5d,0x53,0x89,0xba,0xa3,\n+    0xd8,0x93,0xe2,0xfb,0xe7,0x08,0xdd,0x6d,\n+    0x82,0xdc,0xd8,0x49,0xab,0x03,0xc1,0xdb,\n+    0x68,0xbe,0xc7,0xe9,0x2a,0x45,0xfa,0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea,0xdc,0x78,0x16,0x5f,0xf1,0xf8,0xea,\n+    0x94,0xad,0x7c,0xfd,0xc5,0x49,0x90,0x73,\n+    0x8a,0x4c,0x53,0xf6,0xe0,0x50,0x7b,0x42,\n+    0x15,0x42,0x01,0xb8,0xe5,0xdf,0xf3,0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].labeled_spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    /* Note: in this case, the second output for Carol comes before the first.\n+     * This is because heapsort is an unstable sorting algorithm, i.e., the ordering\n+     * of identical elements is not guaranteed to be preserved\n+     */\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &CAROL_OUTPUT_ONE;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}\n+\n+static void test_send_api(void) {\n+    unsigned char (*sp_addresses[2])[2][33];\n+    unsigned char const *p[1];\n+    secp256k1_keypair const *t[1];\n+    secp256k1_silentpayments_recipient r[2];\n+    const secp256k1_silentpayments_recipient *rp[2];\n+    secp256k1_xonly_pubkey o[2];\n+    secp256k1_xonly_pubkey *op[2];\n+    secp256k1_keypair taproot;\n+    size_t i;\n+\n+    /* Set up Bob and Carol as the recipients */\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].labeled_spend_pubkey,(*sp_addresses[i])[1], 33));\n+        /* Set the index value incorrectly */\n+        r[i].index = 0;\n+        rp[i] = &r[i];\n+        op[i] = &o[i];\n+    }\n+    /* Set up a taproot key and a plain key for Alice */\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    t[0] = &taproot;\n+    p[0] = ALICE_SECKEY;\n+\n+    /* Fails if the index is set incorrectly */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Set the index correctly for the next tests */\n+    for (i = 0; i < 2; i++) {\n+        r[i].index = i;\n+    }\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that null arguments are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, NULL, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, NULL, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, NULL, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 1));\n+\n+    /* Check correct context is used */\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_silentpayments_sender_create_outputs(STATIC_CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that array arguments are verified */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, NULL, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 0, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 0));\n+\n+    /* Create malformed keys for Alice by using a key that will overflow */\n+    p[0] = ORDERC;\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    /* Malleate the keypair object so that the secret key is all zeros. We need to keep\n+     * public key as is since it is loaded first and would hit an ARG_CHECK if invalid.\n+     */\n+    memset(&taproot.data[0], 0, 32);\n+    /* Check that an invalid plain secret key is caught */\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    /* Check that an invalid keypair is caught */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 0));\n+    /* Create malformed keys for Alice by using a zero'd seckey */\n+    p[0] = MALFORMED_SECKEY;\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    p[0] = ALICE_SECKEY;\n+    /* Create malformed recipients by setting all of the public key bytes to zero.\n+     * Realistically, this would never happen since a bad public key would get caught when\n+     * trying to parse the public key with _ec_pubkey_parse\n+     */\n+    memset(&r[1].labeled_spend_pubkey.data, 0, sizeof(secp256k1_pubkey));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+    {\n+         secp256k1_pubkey tmp = r[1].labeled_spend_pubkey;\n+         memset(&r[1].labeled_spend_pubkey, 0, sizeof(r[1].labeled_spend_pubkey));\n+         CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 237,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "051ad339427fa7e69246e372b98d61c5a0e04ab0",
      "in_reply_to_id": 2268166071,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I believe the lines above were a leftover. The idea, as you mention, was to add coverage for a damaged spend pubkey and a damaged scan pubkey. I removed the old lines in favour of the two test cases using the tmp values.",
      "created_at": "2025-08-12T09:33:21Z",
      "updated_at": "2025-08-12T09:33:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269272477",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269272477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 236,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269287929",
      "pull_request_review_id": 3109600166,
      "id": 2269287929,
      "node_id": "PRRC_kwDOAP4Jqs6HQpX5",
      "diff_hunk": "@@ -397,6 +401,19 @@ SECP_CFLAGS=\"$SECP_CFLAGS $WERROR_CFLAGS\"\n \n # Processing must be done in a reverse topological sorting of the dependency graph\n # (dependent module first).\n+if test x\"$enable_module_silentpayments\" = x\"yes\"; then\n+  if test x\"$enable_module_schnorrsig\" = x\"no\"; then\n+    AC_MSG_ERROR([Module dependency error: You have disabled the schnorrsig module explicitly, but it is required by the silentpayments module.])\n+  fi\n+  enable_module_schnorrsig=yes\n+\n+  if test x\"$enable_module_extrakeys\" = x\"no\"; then\n+    AC_MSG_ERROR([Module dependency error: You have disabled the extrakeys module explicitly, but it is required by the silentpayments module.])\n+  fi\n+  enable_module_extrakeys=yes",
      "path": "configure.ac",
      "position": null,
      "original_position": 24,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "ca2538a8782628437488ca32c49f52957aff5f69",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/1698/commits/ca2538a8782628437488ca32c49f52957aff5f69 I'd drop this check for consistency. (But nothing bad happens if we keep it.) \r\n - Musig also depends on schnorrsig and thus transitively on extrakeys, but we don't check for this.\r\n - You don't add an equivalent check to CMake\r\n\r\n```suggestion\r\n```",
      "created_at": "2025-08-12T09:38:46Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269287929",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269287929"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 409,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 413,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269412021",
      "pull_request_review_id": 3109600166,
      "id": 2269412021,
      "node_id": "PRRC_kwDOAP4Jqs6HRHq1",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 204,
      "original_position": 203,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nIs there a reason why we require the user to set this instead of setting it ourselves? This would make the API simpler and easier to explain.",
      "created_at": "2025-08-12T10:28:51Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269412021",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269412021"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 202,
      "original_start_line": 205,
      "start_side": "RIGHT",
      "line": 204,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269421036",
      "pull_request_review_id": 3109600166,
      "id": 2269421036,
      "node_id": "PRRC_kwDOAP4Jqs6HRJ3s",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 24,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nsome writing improvements. if you take them, please reformat \r\n\r\n```suggestion\r\n/** The data from a single recipient address\r\n *\r\n *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\r\n *\r\n *  `index` must be set to the position (starting with 0) of this recipient in the\r\n *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\r\n *  used to map the returned generated outputs back to the original recipient.\r\n *\r\n *  Note:\r\n *  The spend public key field is named `labeled_spend_pubkey` to indicate that this\r\n *  spend public key may have been optionally tweaked with a label by the sender.  \r\n *  This is purely a documentation convention to differentiate \r\n *  between other uses of `spend_pubkey` in this API, where it is meant to refer\r\n *  to the unlabeled spend public key.\r\n *  Whether `labeled_spend_pubkey` has actually been tagged is irrelevant\r\n *  for the sender and\r\n */\r\n```\r\n\r\n - Would it be nicer for the user if we had `spend_pubkey` and `unlabeled_spend_pubkey` or (`raw_` or whatever) instead?",
      "created_at": "2025-08-12T10:32:55Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269421036",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269421036"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269422761",
      "pull_request_review_id": 3109600166,
      "id": 2269422761,
      "node_id": "PRRC_kwDOAP4Jqs6HRKSp",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 14,
      "original_position": 13,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nwant to add a test for this property? (this also makes review easier)",
      "created_at": "2025-08-12T10:33:40Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269422761",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269422761"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269424684",
      "pull_request_review_id": 3109600166,
      "id": 2269424684,
      "node_id": "PRRC_kwDOAP4Jqs6HRKws",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 35,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nnit: inconsistent spacing",
      "created_at": "2025-08-12T10:34:30Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269424684",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269424684"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 23,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269446844",
      "pull_request_review_id": 3109862400,
      "id": 2269446844,
      "node_id": "PRRC_kwDOAP4Jqs6HRQK8",
      "diff_hunk": "@@ -273,6 +274,10 @@ src/wycheproof/ecdh_secp256k1_test.h:\n \tmkdir -p $(@D)\n \tpython3 $(top_srcdir)/tools/tests_wycheproof_generate_ecdh.py $(top_srcdir)/src/wycheproof/ecdh_secp256k1_test.json > $@\n \n+src/modules/silentpayments/vectors.h:\n+\tmkdir -p $(@D)\n+\tpython3 $(top_srcdir)/tools/tests_silentpayments_generate.py $(top_srcdir)/src/modules/silentpayments/bip352_send_and_receive_test_vectors.json > $@",
      "path": "Makefile.am",
      "position": 32,
      "original_position": 14,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "b1138b20a45adff4818b023d7ea80569e3dacaba",
      "in_reply_to_id": 2268280579,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I opened https://github.com/bitcoin-core/secp256k1/issues/1723 as a follow-up. Mostly because I think it would be really nice to keep the build systems consistent, and I got curious on what this would look like for CMake.",
      "created_at": "2025-08-12T10:44:16Z",
      "updated_at": "2025-08-12T10:44:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269446844",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269446844"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 277,
      "original_start_line": 277,
      "start_side": "RIGHT",
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269449070",
      "pull_request_review_id": 3109600166,
      "id": 2269449070,
      "node_id": "PRRC_kwDOAP4Jqs6HRQtu",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 38,
      "original_position": 33,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "see https://gist.github.com/real-or-random/a4aaae5d04eee9f63e7a2e43d25bc2b1#file-sha256_midstate-py\r\n\r\nBut I think the \"proper\"TM way is that josie adds a test that checks if the finalized hash is the same as when recomputed from scratch, see https://github.com/bitcoin-core/secp256k1/blob/e523e4f90e1b1c0fba49cd8a08016e1a8dff9232/src/modules/musig/tests_impl.h#L551-L586. Then the reviewer only needs to review this check.",
      "created_at": "2025-08-12T10:45:14Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269449070",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269449070"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269451956",
      "pull_request_review_id": 3109600166,
      "id": 2269451956,
      "node_id": "PRRC_kwDOAP4Jqs6HRRa0",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23\n+    },\n+    {\n+        0x02,0x3e,0xff,0xf8,0x18,0x51,0x65,0xea,\n+        0x63,0xa9,0x92,0xb3,0x9f,0x31,0xd8,0xfd,\n+        0x8e,0x0e,0x64,0xae,0xf9,0xd3,0x88,0x07,\n+        0x34,0x97,0x37,0x14,0xa5,0x3d,0x83,0x11,0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03,0xbb,0xc6,0x3f,0x12,0x74,0x5d,0x3b,\n+        0x9e,0x9d,0x24,0xc6,0xcd,0x7a,0x1e,0xfe,\n+        0xba,0xd0,0xa7,0xf4,0x69,0x23,0x2f,0xbe,\n+        0xcf,0x31,0xfb,0xa7,0xb4,0xf7,0xdd,0xed,0xa8\n+    },\n+    {\n+        0x03,0x81,0xeb,0x9a,0x9a,0x9e,0xc7,0x39,\n+        0xd5,0x27,0xc1,0x63,0x1b,0x31,0xb4,0x21,\n+        0x56,0x6f,0x5c,0x2a,0x47,0xb4,0xab,0x5b,\n+        0x1f,0x6a,0x68,0x6d,0xfb,0x68,0xea,0xb7,0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46,0x0d,0x68,0x08,0x65,0x64,0x45,0xee,\n+    0x4d,0x4e,0xc0,0x8e,0xba,0x8a,0x66,0xea,\n+    0x66,0x8e,0x4e,0x12,0x98,0x9a,0x0e,0x60,\n+    0x4b,0x5c,0x36,0x0e,0x43,0xf5,0x5a,0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7,0xf3,0xc6,0x79,0x30,0x4a,0xef,0x8c,\n+    0xc0,0xc7,0x61,0xf1,0x00,0x99,0xdd,0x7b,\n+    0x20,0x65,0x20,0xd7,0x11,0x6f,0xb7,0x91,\n+    0xee,0x74,0x54,0xa2,0xfc,0x22,0x79,0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b,0x81,0x34,0x5d,0x53,0x89,0xba,0xa3,\n+    0xd8,0x93,0xe2,0xfb,0xe7,0x08,0xdd,0x6d,\n+    0x82,0xdc,0xd8,0x49,0xab,0x03,0xc1,0xdb,\n+    0x68,0xbe,0xc7,0xe9,0x2a,0x45,0xfa,0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16,0x9e,0x1e,0x83,0xe9,0x30,0x85,0x33,0x91,\n+    0xbc,0x6f,0x35,0xf6,0x05,0xc6,0x75,0x4c,0xfe,\n+    0xad,0x57,0xcf,0x83,0x87,0x63,0x9d,0x3b,0x40,\n+    0x96,0xc5,0x4f,0x18,0xf4,0x00,0x00,0x00,0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea,0xdc,0x78,0x16,0x5f,0xf1,0xf8,0xea,\n+    0x94,0xad,0x7c,0xfd,0xc5,0x49,0x90,0x73,\n+    0x8a,0x4c,0x53,0xf6,0xe0,0x50,0x7b,0x42,\n+    0x15,0x42,0x01,0xb8,0xe5,0xdf,0xf3,0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].labeled_spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret);",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 114,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\n```suggestion\r\n    CHECK(ret == 1);\r\n```\r\nthis is what the docs promise.",
      "created_at": "2025-08-12T10:46:31Z",
      "updated_at": "2025-08-12T10:52:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269451956",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269451956"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269487878",
      "pull_request_review_id": 3109923614,
      "id": 2269487878,
      "node_id": "PRRC_kwDOAP4Jqs6HRaMG",
      "diff_hunk": "@@ -22,6 +22,7 @@ Features:\n * Optional module for Schnorr signatures according to [BIP-340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n * Optional module for ElligatorSwift key exchange according to [BIP-324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki).\n * Optional module for MuSig2 Schnorr multi-signatures according to [BIP-327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki).\n+* Optional module for Silent Payments send and receive according to [BIP-352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki).",
      "path": "README.md",
      "position": null,
      "original_position": 4,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "2b57d2ad8964e536508fae0b6ab1331396fe0308",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/2b57d2ad8964e536508fae0b6ab1331396fe0308\r\nnit: I suggest \"sending and receiving\"",
      "created_at": "2025-08-12T11:01:38Z",
      "updated_at": "2025-08-12T11:01:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2269487878",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2269487878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2270403564",
      "pull_request_review_id": 3111636132,
      "id": 2270403564,
      "node_id": "PRRC_kwDOAP4Jqs6HU5vs",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 61,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nsorted by what?\r\nAnd do we want to make this guarantee in the API?",
      "created_at": "2025-08-12T15:57:00Z",
      "updated_at": "2025-08-12T15:59:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2270403564",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2270403564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2270416794",
      "pull_request_review_id": 3111636132,
      "id": 2270416794,
      "node_id": "PRRC_kwDOAP4Jqs6HU8-a",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 12,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin-core/secp256k1/commit/1a5f53f2cf7d3228b7ed147282ea5bd796957cbf\r\nrelated to the other comment in this review: Are you saying here that the user should not rely on int `secp256k1_silentpayments_sender_create_outputs` sorting the recipients? If yes, this contradicts the API docs. (And  the implementation file is the wrong place to make such a statement.)\r\n ",
      "created_at": "2025-08-12T15:59:38Z",
      "updated_at": "2025-08-12T15:59:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2270416794",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2270416794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 16,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273846219",
      "pull_request_review_id": 3116575816,
      "id": 2273846219,
      "node_id": "PRRC_kwDOAP4Jqs6HiCPL",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char ORDERC[32] = {\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n+    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n+    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41\n+};\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02,0x15,0x40,0xae,0xa8,0x97,0x54,0x7a,\n+        0xd4,0x39,0xb4,0xe0,0xf6,0x09,0xe5,0xf0,\n+        0xfa,0x63,0xde,0x89,0xab,0x11,0xed,0xe3,\n+        0x1e,0x8c,0xde,0x4b,0xe2,0x19,0x42,0x5f,0x23",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": null,
      "original_position": 35,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269424684,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Took a moment to look how secret keys and public keys are formatted in the other tests, will update these to match the rest of the library.",
      "created_at": "2025-08-13T15:34:59Z",
      "updated_at": "2025-08-13T15:34:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2273846219",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273846219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 23,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273870546",
      "pull_request_review_id": 3116608081,
      "id": 2273870546,
      "node_id": "PRRC_kwDOAP4Jqs6HiILS",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 14,
      "original_position": 13,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269422761,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I copied this value from https://github.com/bitcoin-core/secp256k1/blob/d599714147b20dda092ec4af44ef4174d584bb7d/src/tests.c#L6031-L6037 , where it is comprehensively tested. Would a comment pointing the reviewer to the edge case test be sufficient? Also happy to duplicate a subset of the edge case test over here if that's preferred.",
      "created_at": "2025-08-13T15:44:28Z",
      "updated_at": "2025-08-13T15:44:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2273870546",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273870546"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273874700",
      "pull_request_review_id": 3116613458,
      "id": 2273874700,
      "node_id": "PRRC_kwDOAP4Jqs6HiJMM",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 38,
      "original_position": 33,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree on the \"proper\" approach, thanks for the pointer to the musig test. I'll add the same here.",
      "created_at": "2025-08-13T15:46:05Z",
      "updated_at": "2025-08-13T15:46:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2273874700",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273874700"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273887476",
      "pull_request_review_id": 3116629861,
      "id": 2273887476,
      "node_id": "PRRC_kwDOAP4Jqs6HiMT0",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 24,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269421036,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think what you're suggesting makes more sense. As the comment already mentions, from the senders perspective it is always just a spend public key. Using this naming convention, we could simplify the docs here and instead move the explainer to the label API docs, where it is actually important that the user of the API understand the distinction. ",
      "created_at": "2025-08-13T15:51:08Z",
      "updated_at": "2025-08-13T15:51:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2273887476",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2273887476"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276141026",
      "pull_request_review_id": 3119903531,
      "id": 2276141026,
      "node_id": "PRRC_kwDOAP4Jqs6Hqyfi",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 14,
      "original_position": 13,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269422761,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, I see. Then I suggest copying the line `    CHECK(secp256k1_ec_seckey_verify(CTX, orderc) == 0);` . This saves the reviewer from looking up the group order and doing the comparison manually.  ",
      "created_at": "2025-08-14T09:49:18Z",
      "updated_at": "2025-08-14T09:49:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276141026",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276141026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276470356",
      "pull_request_review_id": 3120376843,
      "id": 2276470356,
      "node_id": "PRRC_kwDOAP4Jqs6HsC5U",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 204,
      "original_position": 203,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269412021,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I vaguely remember discussing this with you and @jonasnick previously where we were debating back and forth on whether the caller should set this or we should set it internally. The preference was to have the caller set the value as this seemed the least confusing of our options, but I can't recall the reasons why  .\r\n\r\nIf we keep the `index` field in the struct, then I do think we should have the caller set it, as it seems even more confusing to have the caller create the recipient structs without fully initialising them. That leaves removing the field entirely from the struct, but I don't think there is a (sane) way to keep track of the original ordering internally so that we can ensure we map the generated outputs back to the original ordering.\r\n\r\nSo I'd prefer to leave it as-is, but perhaps we can better explain this in the API documentation?\r\n\r\n",
      "created_at": "2025-08-14T12:18:31Z",
      "updated_at": "2025-08-14T12:18:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276470356",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276470356"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 202,
      "original_start_line": 205,
      "start_side": "RIGHT",
      "line": 204,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276476304",
      "pull_request_review_id": 3120385029,
      "id": 2276476304,
      "node_id": "PRRC_kwDOAP4Jqs6HsEWQ",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 61,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270403564,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"Sorting\" is an implementation detail, since sorting is simply the method we are using to \"group\" the addresses by scan key. Given that, its probably better to remove all references to sorting from the API docs and instead use \"grouping\" to match the language in the BIP?",
      "created_at": "2025-08-14T12:21:11Z",
      "updated_at": "2025-08-14T12:21:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276476304",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276476304"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276490048",
      "pull_request_review_id": 3120403417,
      "id": 2276490048,
      "node_id": "PRRC_kwDOAP4Jqs6HsHtA",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 61,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270403564,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What about:\r\n\r\n```diff\r\ndiff --git a/include/secp256k1_silentpayments.h b/include/secp256k1_silentpayments.h\r\nindex f547207..108c61c 100644\r\n--- a/include/secp256k1_silentpayments.h\r\n+++ b/include/secp256k1_silentpayments.h\r\n@@ -80,14 +80,15 @@ typedef struct secp256k1_silentpayments_recipient {\r\n  *                            recipients, where each recipient is a scan public\r\n  *                            key, a spend public key, and an index indicating\r\n  *                            its position in the original ordering. The\r\n- *                            recipient array will be sorted in place, but\r\n- *                            generated outputs are saved in the\r\n- *                            `generated_outputs` array to match the ordering\r\n- *                            from the index field. This ensures the caller is\r\n- *                            able to match the generated outputs to the\r\n- *                            correct silent payment addresses. The same\r\n- *                            recipient can be passed multiple times to create\r\n- *                            multiple outputs for the same recipient.\r\n+ *                            recipient array will be grouped by scan public key\r\n+ *                            in place (as specified in BIP0352), but generated\r\n+ *                            outputs are saved in the `generated_outputs` array\r\n+ *                            to match the original ordering (using the index\r\n+ *                            field). This ensures the caller is able to match\r\n+ *                            the generated outputs to the correct silent\r\n+ *                            payment addresses. The same recipient can be\r\n+ *                            passed multiple times to create multiple outputs\r\n+ *                            for the same recipient.\r\n  *              n_recipients: the number of recipients. This is equal to the\r\n  *                            total number of outputs to be generated as each\r\n  *                            recipient may passed multiple times to generate",
      "created_at": "2025-08-14T12:27:37Z",
      "updated_at": "2025-08-14T12:27:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276490048",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276490048"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276501470",
      "pull_request_review_id": 3120418978,
      "id": 2276501470,
      "node_id": "PRRC_kwDOAP4Jqs6HsKfe",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 12,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270416794,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Looking at this with fresh eyes, I think the need for this comment arose from the fact the API docs were perhaps giving too much information about the sorting implementation and creating confusion.\r\n\r\nI think it would be better to remove any mentions of sorting from the API, e.g., https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276490048, and then remove the \"Note: \" clarifying comment.",
      "created_at": "2025-08-14T12:32:44Z",
      "updated_at": "2025-08-14T12:33:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276501470",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276501470"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 16,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276546031",
      "pull_request_review_id": 3120477921,
      "id": 2276546031,
      "node_id": "PRRC_kwDOAP4Jqs6HsVXv",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 61,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270403564,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Pushed a slight variant of this, lmk what you think.",
      "created_at": "2025-08-14T12:52:12Z",
      "updated_at": "2025-08-14T12:52:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276546031",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276546031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276547977",
      "pull_request_review_id": 3120480364,
      "id": 2276547977,
      "node_id": "PRRC_kwDOAP4Jqs6HsV2J",
      "diff_hunk": "@@ -0,0 +1,256 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Constants\n+ *\n+ *             orderc: a scalar which overflows the secp256k1 group order",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 14,
      "original_position": 13,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269422761,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added!",
      "created_at": "2025-08-14T12:52:58Z",
      "updated_at": "2025-08-14T12:52:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276547977",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276547977"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276549549",
      "pull_request_review_id": 3120482368,
      "id": 2276549549,
      "node_id": "PRRC_kwDOAP4Jqs6HsWOt",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 24,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269421036,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated to use `spend_pubkey` and `unlabeled_spend_pubkey`, which I think is much better than what we had before.",
      "created_at": "2025-08-14T12:53:37Z",
      "updated_at": "2025-08-14T12:53:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276549549",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276549549"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276550991",
      "pull_request_review_id": 3120484014,
      "id": 2276550991,
      "node_id": "PRRC_kwDOAP4Jqs6HsWlP",
      "diff_hunk": "@@ -397,6 +401,19 @@ SECP_CFLAGS=\"$SECP_CFLAGS $WERROR_CFLAGS\"\n \n # Processing must be done in a reverse topological sorting of the dependency graph\n # (dependent module first).\n+if test x\"$enable_module_silentpayments\" = x\"yes\"; then\n+  if test x\"$enable_module_schnorrsig\" = x\"no\"; then\n+    AC_MSG_ERROR([Module dependency error: You have disabled the schnorrsig module explicitly, but it is required by the silentpayments module.])\n+  fi\n+  enable_module_schnorrsig=yes\n+\n+  if test x\"$enable_module_extrakeys\" = x\"no\"; then\n+    AC_MSG_ERROR([Module dependency error: You have disabled the extrakeys module explicitly, but it is required by the silentpayments module.])\n+  fi\n+  enable_module_extrakeys=yes",
      "path": "configure.ac",
      "position": null,
      "original_position": 24,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "ca2538a8782628437488ca32c49f52957aff5f69",
      "in_reply_to_id": 2269287929,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed.",
      "created_at": "2025-08-14T12:54:08Z",
      "updated_at": "2025-08-14T12:54:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2276550991",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2276550991"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 409,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 413,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2278732752",
      "pull_request_review_id": 3123521055,
      "id": 2278732752,
      "node_id": "PRRC_kwDOAP4Jqs6H0rPQ",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 38,
      "original_position": 33,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Considering we are using optimised tagged hashes in a majority of the modules, this seemed like a good opportunity to DRY up the code and propose a convention for testing tagged hash midstates: https://github.com/bitcoin-core/secp256k1/pull/1725",
      "created_at": "2025-08-15T10:07:28Z",
      "updated_at": "2025-08-15T10:07:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2278732752",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2278732752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2282964041",
      "pull_request_review_id": 3129198442,
      "id": 2282964041,
      "node_id": "PRRC_kwDOAP4Jqs6IE0RJ",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 204,
      "original_position": 203,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269412021,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fwiw, I remember thinking about this idea while reviewing at least once, but always ended up on dropping the suggestion as I found it strange that users would pass in input parameters that can be partly uninitialized (haven't checked, but I assume that none of the existing API functions allow this). Users have to fill in the recipients in a loop anyway, so this should usually need one extra line of code. I agree though that the current solution is not ideal either, so no strong opinion. As a compromise, to not allow uninitialized values, one could require that the `index` field is always zero (maybe renaming it to something like `_internal`, to express that the user doesn't have to care what it is used for), and then set it internally, but not sure if that is better.",
      "created_at": "2025-08-18T17:02:11Z",
      "updated_at": "2025-08-18T17:02:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2282964041",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2282964041"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 202,
      "original_start_line": 205,
      "start_side": "RIGHT",
      "line": 204,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284517322",
      "pull_request_review_id": 3131271276,
      "id": 2284517322,
      "node_id": "PRRC_kwDOAP4Jqs6IKvfK",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 12,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270416794,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agreed",
      "created_at": "2025-08-19T08:25:15Z",
      "updated_at": "2025-08-19T08:25:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2284517322",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284517322"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 16,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284518900",
      "pull_request_review_id": 3131273523,
      "id": 2284518900,
      "node_id": "PRRC_kwDOAP4Jqs6IKv30",
      "diff_hunk": "@@ -25,6 +26,92 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  Index must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from silent payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 if the input private keys sum to zero,\n+ *             or input_hash or hash(shared_secret || k) are invalid scalars\n+ *             (statistically improbable).\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 61,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2270403564,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "looks good. I think I'll do an entire review pass over the API docs once I've finished looking at the actual code",
      "created_at": "2025-08-19T08:25:55Z",
      "updated_at": "2025-08-19T08:25:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2284518900",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284518900"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 77,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284527016",
      "pull_request_review_id": 3131284890,
      "id": 2284527016,
      "node_id": "PRRC_kwDOAP4Jqs6IKx2o",
      "diff_hunk": "@@ -7,10 +7,303 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: only grouping, not deterministic ordering, of the scan public keys is required by the protocol.\n+ *  As such, users of the library cannot and should not rely on deterministic sorting of the recipients.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 204,
      "original_position": 203,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "1a5f53f2cf7d3228b7ed147282ea5bd796957cbf",
      "in_reply_to_id": 2269412021,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Okay, yes. My thinking was that I prefer an API in which the user passes a data structure which doesn't even have an `index` field, but this seems hard in C (or at least, it comes with a bunch of other disadvantages). So yes, let's keep this unless someone has a great idea to get rid of this field without introducing any other overhead. In any case, having the field is safe because we check that the value is set correctly. It's just a minor annoyance for the caller.",
      "created_at": "2025-08-19T08:29:09Z",
      "updated_at": "2025-08-19T08:29:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2284527016",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284527016"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 202,
      "original_start_line": 205,
      "start_side": "RIGHT",
      "line": 204,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284547348",
      "pull_request_review_id": 3131312139,
      "id": 2284547348,
      "node_id": "PRRC_kwDOAP4Jqs6IK20U",
      "diff_hunk": "@@ -0,0 +1,723 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    ret = secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+    (void)ret;\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes where the input_hash would be\n+     */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 1;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &pk);\n+    memset(&public_data->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy.\n+     *\n+     * However, if there is something wrong with the recipient scan key, recipient spend pubkey, or the public data,\n+     * we fail early and make sure to clear the scan key from memory. */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&A_sum_ge, &public_data->data[5]);\n+    combined = (int)public_data->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k is the negation of B_spend, but this is statistically\n+         * improbable as t_k is the output of a hash function. */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 598,
      "original_position": 598,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Couldn't we also in this case (like on the sending side) construct inputs to the functions that hit this? (Did we discuss this on the BIP? I vaguely remember having thought about this before.)",
      "created_at": "2025-08-19T08:35:52Z",
      "updated_at": "2025-08-19T08:35:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2284547348",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2284547348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 594,
      "original_start_line": 594,
      "start_side": "RIGHT",
      "line": 598,
      "original_line": 598,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287467872",
      "pull_request_review_id": 3135479839,
      "id": 2287467872,
      "node_id": "PRRC_kwDOAP4Jqs6IV_1g",
      "diff_hunk": "@@ -0,0 +1,723 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, recipient_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&a_sum_scalar);\n+    secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *recipient_scan_key32, const uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+\n+    /* Compute label_tweak = hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, recipient_scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    /* Compute label = label_tweak * G */\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *recipient_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge B_m, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate B_m = B_spend + label\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &B_m, recipient_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return ret;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &B_m);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** A explanation of the public_data object and its usage:\n+ *\n+ *  The public_data object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][A_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the public_data object to\n+ *  check that the public data object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the A_sum point and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and A_sum separate is so that an elliptic curve multiplication\n+ *  can be avoided when creating the shared secret, i.e., (b_scan * input_hash) * A_sum.\n+ *\n+ *  But when storing the public data object, either to send to light clients or for\n+ *  wallet rescans, we can save 32-bytes by combining the input_hash and A_sum and saving\n+ *  the resulting point serialized as a compressed public key, i.e., input_hash * A_sum.\n+ *\n+ *  For the each function:\n+ *\n+ *  - `_recipient_public_data_create` always creates a public_data object with combined = false\n+ *  - `_recipient_public_data_serialize` only accepts a public_data object with combined = false\n+ *    and then performs an EC mult before serializing the resulting public key as a compressed\n+ *    public key\n+ *  - `_recpient_public_data_parse` assumes the input represents a previously serialized\n+ *    public_data object and always deserializes into a public_data object with combined = true\n+ *    (and the input_hash portion zeroed out).\n+ */\n+\n+int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    size_t pubkeylen = 64;\n+    secp256k1_ge A_sum_ge, addend;\n+    secp256k1_gej A_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+    unsigned char input_hash_local[32];\n+    int overflow = 0;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute input public keys sum: A_sum = A_1 + A_2 + ... + A_n */\n+    secp256k1_gej_set_infinity(&A_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        ret &= secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        ret &= secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i]);\n+        secp256k1_gej_add_ge_var(&A_sum_gej, &A_sum_gej, &addend, NULL);\n+    }\n+    /* Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning many malicious transactions\n+     *\n+     * This will also fail if any of the provided input public keys are malformed.\n+     */\n+    if (!ret || secp256k1_gej_is_infinity(&A_sum_gej)) {\n+        return 0;\n+    }\n+    /* Compute input_hash = hash(outpoint_L || A_sum) */\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    secp256k1_silentpayments_calculate_input_hash(input_hash_local, outpoint_smallest36, &A_sum_ge);\n+    /* Convert input_hash to a scalar to ensure the value is less than the curve order.\n+     *\n+     * This can only fail if the output of the hash function is greater than the curve order, which\n+     * is statistically improbable. We use a VERIFY_CHECK as opposed to reruning an error, since returning an\n+     * error here would result in an untestable branch in the code.\n+     */\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash_local, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    /* serialize the public_data struct */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 0;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &A_sum_ge);\n+    memcpy(&public_data->data[5 + pubkeylen], input_hash_local, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_serialize(const secp256k1_context *ctx, unsigned char *output33, const secp256k1_silentpayments_recipient_public_data *public_data) {\n+    secp256k1_ge ge;\n+    secp256k1_scalar input_hash_scalar;\n+    size_t pubkeylen = 33;\n+    int ret;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(output33 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    /* Only allow public_data to be serialized if it has the hash and the summed public key\n+     * This helps protect against accidentally serializing just the summed public key A\n+     */\n+    ARG_CHECK(public_data->data[4] == 0);\n+    /* These functions should never fail at this point considering:\n+     *   - loading the pubkey and input hash can only fail if the public data object was created incorrectly\n+     *     and we already check for this above\n+     *   - `_tweak_mul` can only fail if input_hash_scalar is zero, but assuming the public_data object\n+     *     was created correctly, this is impossible because input_hash_scalar is the output of a hash function\n+     *   - `_eckey_pubkey_serialize` can only fail if the point we are trying to serialize is the point at infinity\n+     *\n+     *   Note: we don't verify that the input hash is less than the curve order since this is verified when the\n+     *   public data object is created.\n+     */\n+    secp256k1_ge_from_bytes(&ge, &public_data->data[5]);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+    ret = secp256k1_eckey_pubkey_tweak_mul(&ge, &input_hash_scalar);\n+    ret &= secp256k1_eckey_pubkey_serialize(&ge, output33, &pubkeylen, 1);\n+    VERIFY_CHECK(ret && pubkeylen == 33);\n+    (void)ret;\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_public_data_parse(const secp256k1_context *ctx, secp256k1_silentpayments_recipient_public_data *public_data, const unsigned char *input33) {\n+    size_t inputlen = 33;\n+    secp256k1_ge pk;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(input33 != NULL);\n+    /* Since an attacker can send us malicious data that looks like a serialized public key but is not, fail early */\n+    if (!secp256k1_eckey_pubkey_parse(&pk, input33, inputlen)) {\n+        return 0;\n+    }\n+    /* A serialized public data will always have have the input_hash multiplied in, so we set combined = true.\n+     * Additionally, we zero out the 32 bytes where the input_hash would be\n+     */\n+    memcpy(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4);\n+    public_data->data[4] = 1;\n+    secp256k1_ge_to_bytes(&public_data->data[5], &pk);\n+    memset(&public_data->data[5 + 64], 0, 32);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *recipient_scan_key32,\n+    const secp256k1_silentpayments_recipient_public_data *public_data,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar t_k_scalar, rsk_scalar;\n+    secp256k1_ge label_ge, recipient_spend_pubkey_ge, A_sum_ge;\n+    secp256k1_xonly_pubkey P_output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t i, k, n_found, found_idx;\n+    int found, combined;\n+    int ret = 1;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(recipient_scan_key32 != NULL);\n+    ARG_CHECK(public_data != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&public_data->data[0], secp256k1_silentpayments_public_data_magic, 4) == 0);\n+    ARG_CHECK(recipient_spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    /* Recall: a scan key isnt really \"secret\" data in that leaking the scan key will only leak privacy.\n+     *\n+     * However, if there is something wrong with the recipient scan key, recipient spend pubkey, or the public data,\n+     * we fail early and make sure to clear the scan key from memory. */\n+    ret = secp256k1_scalar_set_b32_seckey(&rsk_scalar, recipient_scan_key32);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&A_sum_ge, &public_data->data[5]);\n+    combined = (int)public_data->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &public_data->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&rsk_scalar, &rsk_scalar, &input_hash_scalar);\n+    }\n+    ret &= secp256k1_pubkey_load(ctx, &recipient_spend_pubkey_ge, recipient_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&rsk_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &rsk_scalar, &A_sum_ge);\n+\n+    found_idx = 0;\n+    n_found = 0;\n+    k = 0;\n+    while (1) {\n+        secp256k1_ge P_output_ge = recipient_spend_pubkey_ge;\n+        /* Calculate t_k = hash(shared_secret || ser_32(k)) */\n+        secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret, k);\n+\n+        /* Calculate P_output = B_spend + t_k * G\n+         * This can fail if t_k is the negation of B_spend, but this is statistically\n+         * improbable as t_k is the output of a hash function. */\n+        ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+        VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 598,
      "original_position": 598,
      "commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "original_commit_id": "99aef9204636f04cf689d13eeb365f4f2e3a1568",
      "in_reply_to_id": 2284547348,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We did discuss this and decided it was improbable due to `t_k_scalar` being the output of a hash function, where the allowable hash preimage values can only come from the senders spendable UTXOs.\r\n\r\nThat being said, you're right that we can create a test case for this by first picking a `t_k_scalar` value and then choosing a `B_spend` that is the negation of `t_k_scalar`. In practice, I don't think this could ever happen since the sender is not in control of `B_spend`, but you could have a malicious receiver that puts out silent payment addresses with maliciously crafted `B_spends`. Based on that, I think it's worth adding a test case and handling the error in this function.",
      "created_at": "2025-08-20T08:54:41Z",
      "updated_at": "2025-08-20T08:54:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2287467872",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2287467872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 594,
      "original_start_line": 594,
      "start_side": "RIGHT",
      "line": 598,
      "original_line": 598,
      "side": "RIGHT"
    }
  ]
}