{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698",
    "id": 2655159183,
    "node_id": "PR_kwDOAP4Jqs6eQoOP",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1698.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1698.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
    "number": 1698,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add BIP352 module (take 3)",
    "user": {
      "login": "josibake",
      "id": 7444140,
      "node_id": "MDQ6VXNlcjc0NDQxNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/josibake",
      "html_url": "https://github.com/josibake",
      "followers_url": "https://api.github.com/users/josibake/followers",
      "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
      "organizations_url": "https://api.github.com/users/josibake/orgs",
      "repos_url": "https://api.github.com/users/josibake/repos",
      "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/josibake/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This PR implements [BIP352 - Silent payments](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki). It is recommended to read through the BIP before reviewing this PR.\r\n\r\nThis is a continuation of the work in https://github.com/bitcoin-core/secp256k1/pull/1519 and only opened as a new PR due to the comment history on #1519 becoming quite long and difficult to sift through. It is recommended reviewers go through #1519 for background context, if interested.",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "created_at": "2025-07-10T08:53:21Z",
    "updated_at": "2025-08-01T10:53:46Z",
    "mergeable": true,
    "mergeable_state": "unstable",
    "merged": false,
    "merge_commit_sha": "81fa1ee3b58335939ef35b7b1803e28202d425b1",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "josibake:bip352-silentpayments-module-2025",
      "ref": "bip352-silentpayments-module-2025",
      "sha": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 751433786,
        "node_id": "R_kgDOLMn4Og",
        "name": "secp256k1",
        "full_name": "josibake/secp256k1",
        "owner": {
          "login": "josibake",
          "id": 7444140,
          "node_id": "MDQ6VXNlcjc0NDQxNDA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/josibake",
          "html_url": "https://github.com/josibake",
          "followers_url": "https://api.github.com/users/josibake/followers",
          "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
          "organizations_url": "https://api.github.com/users/josibake/orgs",
          "repos_url": "https://api.github.com/users/josibake/repos",
          "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/josibake/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/josibake/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/josibake/secp256k1",
        "archive_url": "https://api.github.com/repos/josibake/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/josibake/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/josibake/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/josibake/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/josibake/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/josibake/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/josibake/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/josibake/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/josibake/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/josibake/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/josibake/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/josibake/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/josibake/secp256k1/events",
        "forks_url": "https://api.github.com/repos/josibake/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/josibake/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/josibake/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/josibake/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/josibake/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/josibake/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/josibake/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/josibake/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/josibake/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/josibake/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/josibake/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/josibake/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/josibake/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/josibake/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/josibake/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/josibake/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:josibake/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/josibake/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/josibake/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/josibake/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/josibake/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/josibake/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/josibake/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/josibake/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/josibake/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/josibake/secp256k1/hooks",
        "svn_url": "https://github.com/josibake/secp256k1",
        "language": "C",
        "forks_count": 1,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 13376,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-08-01T10:29:25Z",
        "created_at": "2024-02-01T15:52:50Z",
        "updated_at": "2025-07-22T08:03:12Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "74b8068c5d9411a9a96261bc898cc9e9f1f20dfb",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1070,
        "stargazers_count": 2280,
        "watchers_count": 2280,
        "size": 12649,
        "default_branch": "master",
        "open_issues_count": 149,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-08-01T05:54:40Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2025-08-01T05:54:45Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 10097,
    "deletions": 35,
    "changed_files": 25,
    "commits": 10,
    "review_comments": 47,
    "comments": 11
  },
  "events": [
    {
      "event": "reviewed",
      "id": 3005508488,
      "node_id": "PRR_kwDOAP4Jqs6zJGuI",
      "url": null,
      "actor": null,
      "commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3005508488",
      "submitted_at": "2025-07-10T16:26:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18619898506,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARV1RqK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18619898506",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9e85256bbe527bf084222ee08dade9ea497d5c99",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/9e85256bbe527bf084222ee08dade9ea497d5c99",
      "created_at": "2025-07-14T14:54:07Z"
    },
    {
      "event": "commented",
      "id": 3069942270,
      "node_id": "IC_kwDOAP4Jqs62-5n-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3069942270",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:20Z",
      "updated_at": "2025-07-14T15:04:20Z",
      "author_association": "MEMBER",
      "body": "Updated [6264c3d](https://github.com/bitcoin-core/secp256k1/commit/6264c3d0939f2ab11ba8c92f3cb521f9c89c8596) -> [9e85256](https://github.com/bitcoin-core/secp256k1/commit/9e85256bbe527bf084222ee08dade9ea497d5c99) ([2025_00](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_00) -> [2025_01](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_01), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_00..bip352-silentpayments-module-2025_01))\r\n\r\n* Added documentation for expectations around `label_lookup` pointer lifetimes (h/t @antonilol)\r\n* Update docs to accurately reflect that `label_context` is optional (h/t @antonilol)\r\n* Added a test case for passing a lookup callback with a null context (which required some small updates to the test label lookup function)",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3069942270",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18620089953,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARV2AZh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18620089953",
      "actor": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:20Z"
    },
    {
      "event": "subscribed",
      "id": 18620089990,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARV2AaG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18620089990",
      "actor": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:04:21Z"
    },
    {
      "event": "reviewed",
      "id": 3037944552,
      "node_id": "PRR_kwDOAP4Jqs61E1ro",
      "url": null,
      "actor": null,
      "commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3037944552",
      "submitted_at": "2025-07-21T12:45:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18729968570,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARcZKO6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18729968570",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a4db27946b6bdf165095348543e44d7cc4e45e1c",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/a4db27946b6bdf165095348543e44d7cc4e45e1c",
      "created_at": "2025-07-21T14:09:02Z"
    },
    {
      "event": "commented",
      "id": 3096975105,
      "node_id": "IC_kwDOAP4Jqs64mBcB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3096975105",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:15:58Z",
      "updated_at": "2025-07-21T14:15:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "Sorry, stopping CI here. We're about to make a release and need to the CI. :)\r\n\r\nWe'll restart the jobs here afterwards.  ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3096975105",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "commented",
      "id": 3096996582,
      "node_id": "IC_kwDOAP4Jqs64mGrm",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3096996582",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:51Z",
      "updated_at": "2025-07-21T14:21:51Z",
      "author_association": "MEMBER",
      "body": "Update [9e85256](https://github.com/bitcoin-core/secp256k1/commit/9e85256bbe527bf084222ee08dade9ea497d5c99) -> [a4db279](https://github.com/bitcoin-core/secp256k1/commit/a4db27946b6bdf165095348543e44d7cc4e45e1c) ([2025_01](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_01) -> [2025_02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_01..bip352-silentpayments-module-2025_02))\r\n\r\n* Update the constant time tests to cover the `_recipient_created_shared_secret` and `_recipient_created_output_pubkey` functions (h/t @theStack )\r\n* Remove no longer needed TODO comments and clarify why a constant time test without a label lookup function is sufficient for `_recipient_scan_outputs`",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3096996582",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18730266172,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARcaS48",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18730266172",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:52Z"
    },
    {
      "event": "subscribed",
      "id": 18730266200,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARcaS5Y",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18730266200",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-21T14:21:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18749002077,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARdhxFd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18749002077",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e35bedeca6318011afbd59bba6f412a85c33e134",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/e35bedeca6318011afbd59bba6f412a85c33e134",
      "created_at": "2025-07-22T10:27:59Z"
    },
    {
      "event": "commented",
      "id": 3102130501,
      "node_id": "IC_kwDOAP4Jqs645sFF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3102130501",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-22T10:29:47Z",
      "updated_at": "2025-07-22T10:29:47Z",
      "author_association": "MEMBER",
      "body": "Rebased on top of 0.7.0 release :tada: [a4db279](https://github.com/bitcoin-core/secp256k1/commit/a4db27946b6bdf165095348543e44d7cc4e45e1c) -> [e35bede](https://github.com/bitcoin-core/secp256k1/commit/e35bedeca6318011afbd59bba6f412a85c33e134) ([2025_02](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02) -> [2025_02_rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02_rebase), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_02..bip352-silentpayments-module-2025_02_rebase))",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3102130501",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "commented",
      "id": 3102274260,
      "node_id": "IC_kwDOAP4Jqs646PLU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3102274260",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-22T11:13:33Z",
      "updated_at": "2025-07-22T11:13:33Z",
      "author_association": "MEMBER",
      "body": "I did a deep dive on using `(*arg)[size]` in this PR and opened https://github.com/bitcoin-core/secp256k1/issues/1710 for discussion, since this is a broader topic than just this PR. The relevant changes for here and the downstream Bitcoin Core PRs are https://github.com/josibake/secp256k1/commit/5a1088066b2ce5e2e77b4e4bc190575d1171c374 and https://github.com/josibake/bitcoin/commit/5835d987477fc8eae391e4d1cc5033d921925ea1",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3102274260",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "labeled",
      "id": 18768558526,
      "node_id": "LE_lADOAP4Jqs6_1gh3zwAAAAResXm-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18768558526",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-23T08:17:16Z",
      "label": {
        "name": "feature",
        "color": "731E95"
      }
    },
    {
      "event": "reviewed",
      "id": 3047815175,
      "node_id": "PRR_kwDOAP4Jqs61qfgH",
      "url": null,
      "actor": null,
      "commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3047815175",
      "submitted_at": "2025-07-23T14:51:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18794190282,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARgOJXK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794190282",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "created_at": "2025-07-24T12:18:04Z"
    },
    {
      "event": "commented",
      "id": 3113267037,
      "node_id": "IC_kwDOAP4Jqs65kK9d",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3113267037",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:16Z",
      "updated_at": "2025-07-24T12:23:16Z",
      "author_association": "MEMBER",
      "body": "Updated [e35bede](https://github.com/bitcoin-core/secp256k1/commit/e35bedeca6318011afbd59bba6f412a85c33e134) -> [1a84908](https://github.com/bitcoin-core/secp256k1/commit/1a84908cdac60d7313a8d5faee470ce8e2c1c763) ([2025_02_rebase](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_02_rebase) -> [2025_03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_03), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_02_rebase..bip352-silentpayments-module-2025_03))\r\n\r\n* Added a test case for the `_recipient_create_output_pubkey` corner case (h/t @theStack)\r\n* Removed the `VERIFY_CHECK` in favour of returning an error",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3113267037",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18794275408,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARgOeJQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794275408",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:17Z"
    },
    {
      "event": "subscribed",
      "id": 18794275428,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARgOeJk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18794275428",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T12:23:17Z"
    },
    {
      "event": "reviewed",
      "id": 3053302400,
      "node_id": "PRR_kwDOAP4Jqs61_bKA",
      "url": null,
      "actor": null,
      "commit_id": "1a84908cdac60d7313a8d5faee470ce8e2c1c763",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3053302400",
      "submitted_at": "2025-07-24T21:35:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18811001330,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARhORny",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811001330",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/2948a9bf619ba97a0acf38056e6b27005448ebb6",
      "created_at": "2025-07-25T09:16:34Z"
    },
    {
      "event": "commented",
      "id": 3117040572,
      "node_id": "IC_kwDOAP4Jqs65ykO8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3117040572",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:23Z",
      "updated_at": "2025-07-25T09:20:23Z",
      "author_association": "MEMBER",
      "body": "Update [1a84908](https://github.com/bitcoin-core/secp256k1/commit/1a84908cdac60d7313a8d5faee470ce8e2c1c763) -> [2948a9b](https://github.com/bitcoin-core/secp256k1/commit/2948a9bf619ba97a0acf38056e6b27005448ebb6) ([2025_03](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_03) -> [2025_04](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_04), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_03..bip352-silentpayments-module-2025_04))\r\n\r\n* Fixed valgrind error in test\r\n* Update the example to use `EXIT_SUCCESS`/`EXIT_FAILURE` (h/t @theStack)\r\n* Clear shared secret variable consistently (and update comment) (h/t @theStack)\r\n* Add comment explaining why we declassify the pubkey sum (h/t @theStack)\r\n\r\nThanks for the thorough review, @theStack !",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3117040572",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18811062137,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARhOgd5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811062137",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:24Z"
    },
    {
      "event": "subscribed",
      "id": 18811062166,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARhOgeW",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18811062166",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T09:20:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18815902894,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARhg-Su",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18815902894",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "64ecd6c01d394fbdd8902a5d7f3f297a76d5f570",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/64ecd6c01d394fbdd8902a5d7f3f297a76d5f570",
      "created_at": "2025-07-25T14:25:54Z"
    },
    {
      "event": "commented",
      "id": 3118116695,
      "node_id": "IC_kwDOAP4Jqs652q9X",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3118116695",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:30Z",
      "updated_at": "2025-07-25T14:33:30Z",
      "author_association": "MEMBER",
      "body": "Update [2948a9b](https://github.com/bitcoin-core/secp256k1/commit/2948a9bf619ba97a0acf38056e6b27005448ebb6) -> [64ecd6c](https://github.com/bitcoin-core/secp256k1/commit/64ecd6c01d394fbdd8902a5d7f3f297a76d5f570) ([2025_04](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_04) -> [2025_05](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_05), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_04..bip352-silentpayments-module-2025_05))\r\n* Remove no longer needed TODO comment regarding `_cmov`\r\n* Remove todo comment regarding `input_hash`, now that this is [properly specified](https://github.com/bitcoin/bips/pull/1902) in the BIP\r\n\r\ncc @jonasnick and @real-or-random regarding the use of a `VERIFY_CHECK` in favour of returning an error, when returning an error results in an untestable branch. I'm happy with the approach here were we use a `VERIFY_CHECK` for `input_hash` and `t_k` to check for an overflow of the curve order. However, given this is something we've discussed a few times in the post, would be great to hear your thoughts on this and I'm happy to defer to whatever you both think is best.\r\n\r\nThis should address all of the outstanding TODOs (at least the ones we left comments for 😅 )",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3118116695",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18816034806,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARhhef2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034806",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "subscribed",
      "id": 18816034824,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARhhegI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034824",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "mentioned",
      "id": 18816034846,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARhhege",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034846",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "subscribed",
      "id": 18816034872,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARhheg4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18816034872",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T14:33:32Z"
    },
    {
      "event": "reviewed",
      "id": 3062729343,
      "node_id": "PRR_kwDOAP4Jqs62jYp_",
      "url": null,
      "actor": null,
      "commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3062729343",
      "submitted_at": "2025-07-28T13:27:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18861898456,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARkQbrY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18861898456",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3c4af8fee015bb8b10f53ae560d83ab51738b838",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/3c4af8fee015bb8b10f53ae560d83ab51738b838",
      "created_at": "2025-07-28T18:01:49Z"
    },
    {
      "event": "commented",
      "id": 3128406259,
      "node_id": "IC_kwDOAP4Jqs66d7Dz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3128406259",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T18:06:21Z",
      "updated_at": "2025-07-28T18:06:21Z",
      "author_association": "MEMBER",
      "body": "Updated [64ecd6c](https://github.com/bitcoin-core/secp256k1/commit/64ecd6c01d394fbdd8902a5d7f3f297a76d5f570) -> [3c4af8f](https://github.com/bitcoin-core/secp256k1/commit/3c4af8fee015bb8b10f53ae560d83ab51738b838) ([2025_05](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_05) -> [2025_06](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_06), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_05..bip352-silentpayments-module-2025_06))\r\n\r\n* Updates the benchmarks per @theStack 's suggestion to have separate benchmarks for `_full_scan` and `full_scan_with_labels`\r\n* Leave a TODO comment for a follow-up to make the labels benchmark more representative of real world usage\r\n* Cleans up the benchmark arguments and formatting",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3128406259",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18861996956,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARkQzuc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18861996956",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T18:06:22Z"
    },
    {
      "event": "subscribed",
      "id": 18861996990,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARkQzu-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18861996990",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T18:06:22Z"
    },
    {
      "event": "reviewed",
      "id": 3073577403,
      "node_id": "PRR_kwDOAP4Jqs63MxG7",
      "url": null,
      "actor": null,
      "commit_id": "3c4af8fee015bb8b10f53ae560d83ab51738b838",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "In the CI commit, could add the silent payments module also to the native macOS arm64 job (as done for musig recently in #1699), e.g.\r\n\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml\r\nindex 8ee13ce..f612a84 100644\r\n--- a/.github/workflows/ci.yml\r\n+++ b/.github/workflows/ci.yml\r\n@@ -583,13 +583,13 @@ jobs:\r\n       fail-fast: false\r\n       matrix:\r\n         env_vars:\r\n-          - { WIDEMUL: 'int64',  RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes' }\r\n+          - { WIDEMUL: 'int64',  RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes' }\r\n           - { WIDEMUL: 'int128_struct', ECMULTGENPRECISION: 2, ECMULTWINDOW: 4 }\r\n-          - { WIDEMUL: 'int128',                  ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes' }\r\n+          - { WIDEMUL: 'int128',                  ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes' }\r\n           - { WIDEMUL: 'int128', RECOVERY: 'yes' }\r\n-          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes' }\r\n-          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', CC: 'gcc' }\r\n-          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', CPPFLAGS: '-DVERIFY' }\r\n+          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes' }\r\n+          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes', CC: 'gcc' }\r\n+          - { WIDEMUL: 'int128', RECOVERY: 'yes', ECDH: 'yes', EXTRAKEYS: 'yes', SCHNORRSIG: 'yes', MUSIG: 'yes', ELLSWIFT: 'yes', SILENTPAYMENTS: 'yes', CPPFLAGS: '-DVERIFY' }\r\n           - BUILD: 'distcheck'\r\n \r\n     steps:\r\n\r\n```\r\n</details>\r\n(untested)",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3073577403",
      "submitted_at": "2025-07-30T23:49:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18915784215,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARnd_YX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18915784215",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "eb32d06a936307fcce649cf8002e49e6f8730948",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/eb32d06a936307fcce649cf8002e49e6f8730948",
      "created_at": "2025-07-31T09:51:58Z"
    },
    {
      "event": "commented",
      "id": 3139313124,
      "node_id": "IC_kwDOAP4Jqs67Hh3k",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3139313124",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-31T10:04:11Z",
      "updated_at": "2025-07-31T10:04:11Z",
      "author_association": "MEMBER",
      "body": "Updated [3c4af8f](https://github.com/bitcoin-core/secp256k1/commit/3c4af8fee015bb8b10f53ae560d83ab51738b838) -> [eb32d06](https://github.com/bitcoin-core/secp256k1/commit/eb32d06a936307fcce649cf8002e49e6f8730948) ([2025_06](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_06) -> [2025_07](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_07), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_06..bip352-silentpayments-module-2025_07))\r\n\r\n* Enable macOS arm64 jobs in the CI (h/t @theStack)\r\n* Fix return value in the example (h/t @theStack)\r\n* Improve test coverage (100% function and branch coverage 💪)\r\n* Simplify public data functions\r\n\r\nWhile working through the test coverage, I realised the two public data internal functions `public_data_load_pubkey` and `public_data_load_input_hash` are unnecessary, as they were just thin wrappers around secp256k1 function calls that never return an error.\r\n\r\nI've removed those functions and instead ensured we always check a public data object for correctness before accessing the internals.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3139313124",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18915995135,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARney3_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18915995135",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-31T10:04:12Z"
    },
    {
      "event": "subscribed",
      "id": 18915995173,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARney4l",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18915995173",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-31T10:04:13Z"
    },
    {
      "event": "reviewed",
      "id": 3075428613,
      "node_id": "PRR_kwDOAP4Jqs63T1EF",
      "url": null,
      "actor": null,
      "commit_id": "eb32d06a936307fcce649cf8002e49e6f8730948",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Reviewed eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_ again and it looks good to me (not a C expert). Comments mainly about documentation and one variable name suggestion.\r\n\r\nIt could make sense to split  993d34b7ae3d4a8b6d3a8957b309b38e7e50e796 _tests: add BIP-352 test vectors_ and move the send-side tests directly after this commit. Ditto for the send example in ce7cb982d4aceefd8bb8591fd069c3a0b81d1ef2 _silentpayments: add examples/silentpayments.c_.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3075428613",
      "submitted_at": "2025-07-31T15:24:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDg2ZGRhMzg3YmY1MzQ0MGYzOWFmNjllMGIyYTg2Nzg5YjBkNDgxZDc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/86dda387bf53440f39af69e0b2a86789b0d481d7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/86dda387bf53440f39af69e0b2a86789b0d481d7",
      "tree": {
        "sha": "412c684fb80cf297863ac26eafec73f52f9557c8",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/412c684fb80cf297863ac26eafec73f52f9557c8"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 412c684fb80cf297863ac26eafec73f52f9557c8\nparent b9313c6e1a6082a66b4c75777e18ca4b176fcf9d\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1695828134 +0200\ncommitter josibake <josibake@protonmail.com> 1754044037 +0100\n\nbuild: add skeleton for new silentpayments (BIP352) module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiMloYACgkQity1WMTz\nPWVR2g/6A3svRPXF1iULw8Bt49xjsmvR+PUJZQCi4JOsONGpVgdp9alnzwdsl148\n8oUP/zlsKwnCFvFBhPCvMo5zS2geAxkF7Dmq7r9mfOYR4zTnlSjghrUH3BkUaia/\njAhEOiUQiikMvzB8zS+gDO5JtDVxanxACNcNn20YDL4aSnYwz5slH1yVc5k9hk4W\nCKa3Kq69bAmTXQ7XUKu2lWx2XUEH0/RTXPFXSbNYnH6diV3M/HCfpak/MstZDLbd\n0Uw/qPevuCMAiVu04I7hrsP7jQe/PS4v+TDSqnviKWQL5G/qxQg3HnYLd5m7lNKf\nnLflR0Npwm0VKWWulo8Si6JhAYXHAW17m9aJcNBUdyEqaoxWkOU7Bk/IpKR/8EiW\nu1DQH7cseeE3MbEzO0BU0x3UpHbWuogrl6Q0LdbHC/jSZ5yL2IDJMXo7xGcJnKut\n7VMyV3Io0PgvbBnBER+88GgIdcDPa+48AiwSh/XhkkIiqGN7WuRJxHBu+mNA9NUd\n/hpKIp7e4ridXD2XPa2g39OCY1pnddGvXs/qm5JSnQ160OdujCELL7LjxkUOrXKT\nTr0cxuGUKFSbLrjf+Sx9m1nZWgg67tu3DQlYJCS2to0ePz2rrXP0wbVlrloWrNEm\nUa9CczE8pu3q+r/GLLvk1ECWpdPWZQEva8/hNI4WKulk+lG9lU4=\n=3U4W\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b9313c6e1a6082a66b4c75777e18ca4b176fcf9d",
          "sha": "b9313c6e1a6082a66b4c75777e18ca4b176fcf9d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b9313c6e1a6082a66b4c75777e18ca4b176fcf9d"
        }
      ],
      "message": "build: add skeleton for new silentpayments (BIP352) module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-01T10:27:17Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2023-09-27T15:22:14Z"
      },
      "sha": "86dda387bf53440f39af69e0b2a86789b0d481d7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGUwYzdhMDk0MTVkZTAwZTk0ZThhOGM4ZmMzYzUxNTRkMDBjYzA3Mzk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/e0c7a09415de00e94e8a8c8fc3c5154d00cc0739",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/e0c7a09415de00e94e8a8c8fc3c5154d00cc0739",
      "tree": {
        "sha": "38f3077b1646f75d35963283401791bab189e686",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/38f3077b1646f75d35963283401791bab189e686"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 38f3077b1646f75d35963283401791bab189e686\nparent 86dda387bf53440f39af69e0b2a86789b0d481d7\nauthor josibake <josibake@protonmail.com> 1711383817 +0100\ncommitter josibake <josibake@protonmail.com> 1754044038 +0100\n\nsilentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiMlocACgkQity1WMTz\nPWUnFxAAgNTJceCUz/1EZ0s4/HtRji+M89DAFjqE31eENzHVdB6DIYTz3/UK/3gn\nqnEHS6F9v1+Brm02m6KKNbX35clQRTT22z8BWbRpOjrxM5NUZBqW396a2rhzulpN\nPjooqdAI7kdHdN14EOI8AJ/qyc8F1Pa0EalBhD8nSoP9jqRTzIWO/RFxD9x/dT0C\nQdmbLsipxHBNJazH++bH3aR4DYGNb2mVMIW2APm6hee968WLpIg26js5+cg+Gt7g\nO8j6JXAu7iVBomkkmv7tnocBVrlL7eANtgiDw6G0/ERjC35ZH6gqUtM1G8aP4JK0\nnFE7+58SUXGkHlRcxxqyVFUVJ+MJ4WkdOS/V9zF1l/WPFyZg/ellfUQOEXDe6lwo\n0nke/0SzTsXyd9EcOOcr673EyW856WKF8A5N6rYQWcl8Mf0No1liz0jIG6a81aER\nQ0Me1YGT2SGp22YgHCBPv9TsmdVsVNfXeVfhbq0KjFUVY4DiiPI1LylI23zkTfQe\n2BsEF/O2AET513A9uyUdW0AzSYij50VFj4aMzGj47EVQ8qB0cMq9K/BogTSB/n49\nHGLpi5Sgol+od3ab0eakZq1UvFLsxe8cMYVAy/zKluFZ2ESmFBvfZwpICvfAqTER\nAAIQ+AOM6THHq8bKz00pne7Ek75jFiDFkcdk/Bv2sSUMBafWAog=\n=e+8B\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/86dda387bf53440f39af69e0b2a86789b0d481d7",
          "sha": "86dda387bf53440f39af69e0b2a86789b0d481d7",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/86dda387bf53440f39af69e0b2a86789b0d481d7"
        }
      ],
      "message": "silentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-01T10:27:18Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-03-25T16:23:37Z"
      },
      "sha": "e0c7a09415de00e94e8a8c8fc3c5154d00cc0739"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGVjMWJhMTkyMDZmMGIxYmFhMzgxMjFkMzhiZjMxYjE0YzVkNGRkZDU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ec1ba19206f0b1baa38121d38bf31b14c5d4ddd5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ec1ba19206f0b1baa38121d38bf31b14c5d4ddd5",
      "tree": {
        "sha": "78443fb0eceeb6e6302d664d1a78075eecc78c37",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/78443fb0eceeb6e6302d664d1a78075eecc78c37"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 78443fb0eceeb6e6302d664d1a78075eecc78c37\nparent e0c7a09415de00e94e8a8c8fc3c5154d00cc0739\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1705946165 +0100\ncommitter josibake <josibake@protonmail.com> 1754044039 +0100\n\nsilentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiMlogACgkQity1WMTz\nPWWXoQ/8CIffhg7lO7d+xOSdzcO2LYp2bXkGgYahIUSBTx0b3la++BSlA0ADchiH\nceJarx1uj5A9K61q/Awx4lvuFBSUiaLFcvQWph2a75Q+M8dbwc3Zj8IQeSsp/M9V\nwrtIWRsySxLWebWUVU/iI5pjscFlfPXbJ+Ve1aO/oZWR8jvGyd3lCWBYaBs8GY+6\nrkL4k6JFv70Cnu7zoRyZhVxOgrgjAFyPj2sSJRz3cTgKId9FBRofaqllBPuUOmr5\nlr4Lg4dcveiPtSIE+T7tXXEGa5cdJhJFA7MwR2b9lWbzy90ws7fsS+ePN388HpVt\nGs4xRlMoygfB9Uiyan821HihO7pP/jg61+5Nx9hZcrTg9IPqXd2Eo+/f9S/elGD2\n981dNJyx/9wj6Tt4kj4OSO7FqyfexTBlDa4TQME2jjBVhAmICvWu1Su9aELVIxx6\nGYefS8ehGtzCtgKmhw1vsKgpmixrB/SDamcNvRgnHJoyAH6hXsSng5UbVqy6GZDp\nihoszaE3hQ+dRJIGmo0ZVnL1Tb9R53wak0QcpEY7A0EeJS+lBTC/CUod0QeNmtNz\n5qDp4xfnQLbCOs6T6uwRfT2zE2eoaqfVuSSVPkGvexnlD12IAvwkGZm+woi8CiEN\nQNC7ZT9ahYgjhOEP4BaYVwWVSsl4Govvh3U0OaSKNHAzxRy783Q=\n=kYxj\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/e0c7a09415de00e94e8a8c8fc3c5154d00cc0739",
          "sha": "e0c7a09415de00e94e8a8c8fc3c5154d00cc0739",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/e0c7a09415de00e94e8a8c8fc3c5154d00cc0739"
        }
      ],
      "message": "silentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-01T10:27:19Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-01-22T17:56:05Z"
      },
      "sha": "ec1ba19206f0b1baa38121d38bf31b14c5d4ddd5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDBhNzlkM2EyZTUxNmQ3ZGVhMDcwMjNlNjhhOTRhYTM3ODQyZjliZTU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0a79d3a2e516d7dea07023e68a94aa37842f9be5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0a79d3a2e516d7dea07023e68a94aa37842f9be5",
      "tree": {
        "sha": "ec9166f10481cb5149ea33db9f5d0c4ca135354c",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ec9166f10481cb5149ea33db9f5d0c4ca135354c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ec9166f10481cb5149ea33db9f5d0c4ca135354c\nparent ec1ba19206f0b1baa38121d38bf31b14c5d4ddd5\nauthor josibake <josibake@protonmail.com> 1719660810 +0200\ncommitter josibake <josibake@protonmail.com> 1754044040 +0100\n\nsilentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the summed input public key (A_sum)\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply b_scan * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a public_data object to\nand from a public key. When serializing a public_data object, the\ninput_hash is multplied into A_sum. This is so the object can be stored\nas public key for wallet rescanning later, or to vend to light clients.\nFor the light client, a `_parse` function is added which parses the\ncompressed public key serialization into a `public_data` object.\n\nFinally, add test coverage for the receiving API.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiMlokACgkQity1WMTz\nPWU7+xAAql9+A6z5WDkHID/lK0AEEWd0yYk4t44lGGdOBWT/OQJUHERvCKTYm2GE\nDo37xse74c91XIthu1HCDJzWmIOy/yqxwPKNWRi1IlMfrLBFwF74YYT9FPJxGO1/\nfp/J5jwwK1SljGubnyjOKgr0eVH+uhMPJ5IbW846pi44lVCQ1WHsZdKoa+xN/hh/\nuWqoiVNWxlZz+vf8hD6U1uBBoOAteQR7oxbHvKXkBdKkMiMtStSVA2HEdb1itiQL\nkMA+wI510ISE+U6fFUNBcUdXDoIuzHqbDlsu3BDw3VujPpB2yz+oEJ6CsG8vJuDU\nd3lTX6EoPf+D5t/LWgDQQpRTjEomh4XBrLrxKWDHjpjHR8Y2JWO8f3tFIzC/dOIA\nXGn5F5ywumncyvEYQbogca2uzKuhb2VrBgahfNqQDSI7APWJ7wlmYmkLICglbLuH\nTRX8uzL7iOkQHgoiTtpUkWa8bKX9CmJLgCAV7JuFL1MrW6TBA2QoikdIXtZCJUaA\n//803faynQ4L+svb+x5K4JNlfvJAQqzKP4RNjPiiECnyGT31HDAEpBW9PLr3nAYb\nUMjAlPXUZPBCZlQl0amfRfQlXOTmqVay6NtFKn2HkGix0P2PmKkFX8HrYixnBYUE\nnWZZZsOu3ywvyOD+mfYrurPk+uMWSx1kRm3cGQnD0tdbpxKwZVU=\n=5cT5\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ec1ba19206f0b1baa38121d38bf31b14c5d4ddd5",
          "sha": "ec1ba19206f0b1baa38121d38bf31b14c5d4ddd5",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ec1ba19206f0b1baa38121d38bf31b14c5d4ddd5"
        }
      ],
      "message": "silentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled by exposing the\n`_create_shared_secret` and `_create_output_pubkey` functions in the\nAPI. This means the light client will need to manage their own scanning\nstate, so wherever possible it is preferrable to use the\n`_recipient_scan_ouputs` function.\n\nAdd an opaque data type for passing around the summed input public key (A_sum)\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply b_scan * input_hash before doing ECDH.\n\nAdd functions for deserializing / serializing a public_data object to\nand from a public key. When serializing a public_data object, the\ninput_hash is multplied into A_sum. This is so the object can be stored\nas public key for wallet rescanning later, or to vend to light clients.\nFor the light client, a `_parse` function is added which parses the\ncompressed public key serialization into a `public_data` object.\n\nFinally, add test coverage for the receiving API.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-01T10:27:20Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-06-29T11:33:30Z"
      },
      "sha": "0a79d3a2e516d7dea07023e68a94aa37842f9be5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGUwYzIyNWMwNDc2NDVhZTkyZGI4NzdmNjYxZWRlMzg1ZjRmODYwM2Q",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/e0c225c047645ae92db877f661ede385f4f8603d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/e0c225c047645ae92db877f661ede385f4f8603d",
      "tree": {
        "sha": "455443cd1c61e3138b5358a1f903e2832e4c1722",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/455443cd1c61e3138b5358a1f903e2832e4c1722"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 455443cd1c61e3138b5358a1f903e2832e4c1722\nparent 0a79d3a2e516d7dea07023e68a94aa37842f9be5\nauthor josibake <josibake@protonmail.com> 1713202589 +0200\ncommitter josibake <josibake@protonmail.com> 1754044041 +0100\n\nsilentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiMlooACgkQity1WMTz\nPWXHbQ//Q6G/6YNCtuheRRNIsXY/2TI+Ob89AQiXdnUOk7pugql4JvmDx+MtqLq5\nDB/9gVj896WAKLm4ySfsPEVo+X4yzpmGUCTlO7a6oZujeRpCH5/+2GNI3/yl5nBR\nK61DnnoWQcXiwPo265IAcNpEHFXaT8PMGLzNoysIscO9o36Jh9kW69LCTpf74ylY\nS0DXm+TMbSFI/JzBZWVsa5oiVrXIcvjeT5f3LlCpnxvnSA5/4QJ2WxX8y0oAPcm9\nc4Ob2BkMvrUdWjGH/qC5ny4gF4/YtBc9xQqKE23oHfteGdeB/Bxe8udp82pv8mL2\n/BRvcXKKFqY2syX7sQ3RQGXxkiWJh+upJ2esySdlPajSDNPijKClov5v3euUlif8\nies7DuoVFTZCfU0tEgXMC4unw8UcfhNjU6epFNDSXCdJJ5Ul6WxxS6ay82v7gkj8\nJttBdzrm2/IwLyFxWauUbfVs+aIR+ek9e0joOrBe/qFo7CMXMYy9/RBKw85I61nJ\n4P5poZZbN0uJmecPhLVcdBjKNJwM1xU9B7r5Kb1A89PspfqhyA0wgMW+lkKhuzPf\nrToX+gC91C17g2Wa0yMNjaaeIrvxH7v7ekMatwLw0ZCHZn4eJOqXQb115FC/QHIt\nPCg8XoK9aO2Ud74wjvHT75F8Ol96dJTpPTLDTZ4RavLdob7r4I0=\n=MyxV\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0a79d3a2e516d7dea07023e68a94aa37842f9be5",
          "sha": "0a79d3a2e516d7dea07023e68a94aa37842f9be5",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0a79d3a2e516d7dea07023e68a94aa37842f9be5"
        }
      ],
      "message": "silentpayments: add examples/silentpayments.c\n\nDemonstrate sending, scanning, and light client scanning.",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-01T10:27:21Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-15T17:36:29Z"
      },
      "sha": "e0c225c047645ae92db877f661ede385f4f8603d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDg4MGE1ZGMwNjRkMTZjNTY1NTQ2ZDdhMzI1ZDYxYjEyMzg3NGFjYmE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/880a5dc064d16c565546d7a325d61b123874acba",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/880a5dc064d16c565546d7a325d61b123874acba",
      "tree": {
        "sha": "ef5d939531832900a066b9e560759e37a5c7a399",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ef5d939531832900a066b9e560759e37a5c7a399"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ef5d939531832900a066b9e560759e37a5c7a399\nparent e0c225c047645ae92db877f661ede385f4f8603d\nauthor josibake <josibake@protonmail.com> 1714066415 +0200\ncommitter josibake <josibake@protonmail.com> 1754044042 +0100\n\nsilentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan and for scanning a single\noutput. Only benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiMlosACgkQity1WMTz\nPWV5tA/+Kh3vkaahKy+O63JcypCnv1rwlc+DgYxcq/ong7mOduSzT7jr9EpharB2\nVePIXn926J+OhGr7UOMkAZC3z04r/gngZB/AI1sStIvvdELWLC8zfRhJwfltq2jF\nuKdchSJC5foXmwltRidY0fyJUeljqOt1dmzZB5RQg+EQuIFQw2ZLi4er4Z9nicsE\nzCqJrOQWVvpyzl2laCmYZuPKw1yLMKhk+ZcmD9ryjM11hJtKywCAMLLlKlw9nefx\nB6LcstkU1RtvzHs71UXITmwPIxJTmqGGbExdDpFjC1BydHoNJicaUtpYMzxiDFRx\nG//FZRI4ZZKhJjDfwsmarmhotGkfWypu5+mZD+8r3UBm0Y+z+4+XbBzvNzZhQQNR\nb6ShJgOB35YYahN78bsreuwutg1qJ2glcwIXId4sxHUCwKXTE+ZMVYCSRkSKe6J0\nMUBYrMYLz3h0P8QE+mMRBUy+EVhgEEtrhc4LBPmrphaP3Mm4cZ0uIspkVAfKUk8m\nN0hlVZVL1BgmmgxoihcWQxk+iDeR/xhcfUuQ5qPvwVutgpwGKvMS8FM0r5hoJWY/\nRu9PleeeVMnzPlY9RTGh7483dYol6WHku7/R4bW3TnGM3Uz21O8FB8ZOgBC0kJwZ\n0M6nT3VKcW5sqaI0CP6E9KJDDMgSGgJBgWqM0zet+Dk6BOzYvAk=\n=sH6S\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/e0c225c047645ae92db877f661ede385f4f8603d",
          "sha": "e0c225c047645ae92db877f661ede385f4f8603d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/e0c225c047645ae92db877f661ede385f4f8603d"
        }
      ],
      "message": "silentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan and for scanning a single\noutput. Only benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-01T10:27:22Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-25T17:33:35Z"
      },
      "sha": "880a5dc064d16c565546d7a325d61b123874acba"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGU1MDJkMzYxMzJjZGY4YzUyYmE5ZTAzYTBkYTg1OTBhZjUyNzFiMDM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/e502d36132cdf8c52ba9e03a0da8590af5271b03",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/e502d36132cdf8c52ba9e03a0da8590af5271b03",
      "tree": {
        "sha": "e702cc786a00332ded5a6f350fa074d7f5ac6179",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e702cc786a00332ded5a6f350fa074d7f5ac6179"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e702cc786a00332ded5a6f350fa074d7f5ac6179\nparent 880a5dc064d16c565546d7a325d61b123874acba\nauthor josibake <josibake@protonmail.com> 1719942343 +0200\ncommitter josibake <josibake@protonmail.com> 1754044043 +0100\n\ntests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiMlowACgkQity1WMTz\nPWU7jRAAgWIAAwR8BJLJqBJjOApSc20n2UxG/F5RmpvwOnLchIMCEON1xh6bsHkV\ncaVh88KcxYb3vIdVI55eDzez9ip31ARDzgCMCT/X9R2BpBcjcqBLZ/k36GaEtnuq\njNuAwTEMNTdvw627ilXun0dSABQlgtC326dxdnIotP7IfDUbjYpj/rqBVoNyjx9B\ncCYXC16/X3v7uIloyWDBCdxKZKbiFpXFvxuk8xoIwySzI//XDz/T7yymoKLu+2aW\ncUHeq73P/PNDS35VNgAY7AMPuQw0NLy9M45vfq2sMd6pE939kay31FzXvVnJTzTQ\n4zaRr48yvBT/uLeqHRwgjnM5nw3Qgw2CwgG4gdUc/igtOsNht9KD8YYJpOiUv/es\nw8f9rBpyHWHam1RornDU/4WK/gZYt9OYiERd/cNujpV1d8wLxBF8M+aLlCmLRIY+\nTEWmMngBK+6agxi/saRjwSEPLoME4/v9aif9NQeE/7bO0K718wqBEIrxcOalNMCA\ntH2MurKs15VYQilHMWyBJ+COWqXmYsKMdylH/lhEUlRZUv0pqzKumG9qkg9QybTe\nPasZkF50FIXFRCmg/M67bYaYF3jsRwc9yrJlNKm6MsaF8kFVcFUicKZ/Hi2VI+3H\n8WQAQF/YQAqj/LfDo3fKX4Mg2/gNBXz94+pSzjdcaQVD7C86r1k=\n=SOIB\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/880a5dc064d16c565546d7a325d61b123874acba",
          "sha": "880a5dc064d16c565546d7a325d61b123874acba",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/880a5dc064d16c565546d7a325d61b123874acba"
        }
      ],
      "message": "tests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-01T10:27:23Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-02T17:45:43Z"
      },
      "sha": "e502d36132cdf8c52ba9e03a0da8590af5271b03"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDIxNjlkNGFjYjc0MWU5NTUyN2E4ZTFiYmU5NTM5MmNiNjUyNDI2YmE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/2169d4acb741e95527a8e1bbe95392cb652426ba",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/2169d4acb741e95527a8e1bbe95392cb652426ba",
      "tree": {
        "sha": "f9aeac30b8d9cfff8c8283fd599e6fde1c4ff45a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/f9aeac30b8d9cfff8c8283fd599e6fde1c4ff45a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree f9aeac30b8d9cfff8c8283fd599e6fde1c4ff45a\nparent e502d36132cdf8c52ba9e03a0da8590af5271b03\nauthor josibake <josibake@protonmail.com> 1730981939 +0100\ncommitter josibake <josibake@protonmail.com> 1754044044 +0100\n\ntests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiMlo0ACgkQity1WMTz\nPWUEZQ/8DB0kd9L4VusnNAGIXmd4K3CXoI5nfkV/8iAmvGNauYQi54Rb9uGmLs1d\nMDo/TTomoPbZaFCbHPkbziL/uFuPnCROudCxj099YEvZsKT9I19idedaiRE4cc4Q\n4OibXQtuPuK7NRvgs+ArTDvtDcaTRYHwt95bulgvErWf680SzX0IQOjj9B5I2kxU\nzJWpgtJ8FcZevdc+Ki7q+TXAFZVbHdJRQnwlDkQJiAE/amlPjyyYl5LmdQEL8elG\noJTcCF1vhk4vjSDEwp4cN/eiaIzwlOSxTNDHqqlE2NZyYX2cPk1jv32nHHmnmwQt\nyCjzgEHEmSQ49J36LFAIFGHNKeJ1DmxcvdrbNITP2I+pPjJZ7qxrIxAaJ3xn7hB+\nEzEskyZ5fY4AL+qELmivcxuFw2yCS3NgbwH/oqNn2ZX61WMyKKPQdkwzY7nEQG+M\nKVQnmsQ7IWWytyFwmHPIwJbpNOFKYoLMxLaMfg1x+ix4vlvPpPK+YSZG7c9c7aSP\nlSabf4Pz2GwQHH4gmaaNQWWHQnkGPFOukwS4eYf3EXz6Kq5C6PGovYcIr5ZBzhuJ\nG/+KWU4d96by0109rNFgwn68KnvyvwenIFQOc6ZcLp13fdaaM1etPS/2yDbww39g\n0fLvMizYDdJKVzMd4WNGGzD6S9F9uJsz0NGqnRNHjKyLtE5esoM=\n=kJT7\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/e502d36132cdf8c52ba9e03a0da8590af5271b03",
          "sha": "e502d36132cdf8c52ba9e03a0da8590af5271b03",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/e502d36132cdf8c52ba9e03a0da8590af5271b03"
        }
      ],
      "message": "tests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-01T10:27:24Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-11-07T12:18:59Z"
      },
      "sha": "2169d4acb741e95527a8e1bbe95392cb652426ba"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDU1NjI2MDQ3MDc2YmU5NzYzYzM5ZjdmYzMwMTE4ZTE0ZjJiZDk1YWI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/55626047076be9763c39f7fc30118e14f2bd95ab",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/55626047076be9763c39f7fc30118e14f2bd95ab",
      "tree": {
        "sha": "51f0060553d57359b5600f33b2f94541247e3f7c",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/51f0060553d57359b5600f33b2f94541247e3f7c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 51f0060553d57359b5600f33b2f94541247e3f7c\nparent 2169d4acb741e95527a8e1bbe95392cb652426ba\nauthor Sebastian Falbesoner <sebastian.falbesoner@gmail.com> 1708644341 +0100\ncommitter josibake <josibake@protonmail.com> 1754044045 +0100\n\nci: enable silentpayments module\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiMlo4ACgkQity1WMTz\nPWXp1BAAs02SzfFXOh3V0Kbx+5Bpns19l89amIIlgAevg9IIalxUJu+xnmPDkM6t\nA4jPYZJaOiZRF563tiQQn8kzPGg3ql0mWK7REFEnj3fYfe4o72CEQvv8vtgZYq1a\n5y1AkOp51yNPLBG5C+/Svr+0/9F/YdNR2pTxqseEAurU4vbAsmMsOcOBPkOk/xwa\nvnK6cFgwnze/XSMkJl7fvIYoVcjpHOeRShUNIQK1Gw9VBOkB4uB8OHcAiW2Smdmu\nGzhoqeK/JJwvhCCBkl/z7QllHyZMEwSWdP6ixJuyUhYYNDbwgdlP9eu8WilR2NoB\nTtA8K/i3qlDLK7rSHXGWggRpMRfEgo0nSlr5DTHD/SSFPmhbxpbjEHA0ZGgqwrib\nAlIIereGbkltS4p2AQm4sxYIJqpWMdkqCPEEp/KwZBeVbJQUWrrFLW7/ZhcYGRpJ\nzP/QpB4QP4ew2S0776pT+2dZaMBDvti07Zlo/DFDUUOS8g9N5y9E6D/CgK11kxX/\nGwGD4ck40SACYKT8OVeuUiJCvI6U1wsaBUkP8vjzxcZcu5cOLbcprZkyWeNRD4yu\nwOVcZjfaJKoaQIgCmforURmgFXAS1ONs2MKjNGqK95xHxoDM/2dHEiE0CWEBFLYe\nu1w9E9Ss98v22sUlK809Yy6s9OIPY2WTMuCSP3W4t8NUsYCjwc0=\n=K3Zm\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/2169d4acb741e95527a8e1bbe95392cb652426ba",
          "sha": "2169d4acb741e95527a8e1bbe95392cb652426ba",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/2169d4acb741e95527a8e1bbe95392cb652426ba"
        }
      ],
      "message": "ci: enable silentpayments module",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-01T10:27:25Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-02-22T23:25:41Z"
      },
      "sha": "55626047076be9763c39f7fc30118e14f2bd95ab"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGIyNmM4N2Q1YzA5ZGRlZmU3NjRhOWNhZDZhODYxMmUzNGNjZDEzZGU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "tree": {
        "sha": "c2663a33449b2fec6c7ccda3768fa717bc8ac3b1",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/c2663a33449b2fec6c7ccda3768fa717bc8ac3b1"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree c2663a33449b2fec6c7ccda3768fa717bc8ac3b1\nparent 55626047076be9763c39f7fc30118e14f2bd95ab\nauthor josibake <josibake@protonmail.com> 1720789074 +0200\ncommitter josibake <josibake@protonmail.com> 1754044046 +0100\n\ndocs: update README\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmiMlo8ACgkQity1WMTz\nPWUCjBAAy9s0BEzllBsik/hBhLVJwRmUrNgHtqGkMgk+m7XNkb4WtmvRwgWDNyGk\n9BwM4j7h/aNHVPew9D5X+9xClK/JWCZAMSJCiFtoBpOx9KK0Z+AM+SS/b1D5zv37\nE+rId7AKyJyTvdBvovY6W4WauGROyVNUfZjrQ9Y/KvDYFBHrfWYys+UMh6lgSXRd\nV2OkEt0m7s9Lg3Uae8cVkEHGC3WA3Z8ZoVyux8j3KuHvvBKamgkCXzAoY22r+2mv\nUEE1jbwFjcMKYoJBu8LuLHW2AAEM/c6WtFZoFBhtzkxQ+hTwS3eR/U/3Q8YH9F66\nbrPYe+zpI5U8IRX1SUcQ6zdLRJ54xnIQtxO7cJoac/pz4QgFxda92gL4xJA4TphE\nlavsP9ex3r/tynfokXgbnVh982JAI83h7xYQ11YtwXjb1lqD3KfIe7T4AccNP68X\nYTW5t8bJzC36uk94+WtTLBykJN6PhLMDPGgKY0ucav69T6oJFrApL2GOz36WtPKM\nTwH+du+1kAe3VLFSzSW/jIBJ4M1OGsYpIEtF2awVj21hPFTnSaVcsEta+Yr0/qLW\nM8NnZYRHZvFPn+aFLzXundWmboeSPfXnPP+zV13Mro13iXhruyI6oBHMcRal/hEJ\n5CeEekuySFhQ3RF6IhbuFU2nPMo7JO4OWh3dbsE403qVxfUg1uI=\n=ehui\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/55626047076be9763c39f7fc30118e14f2bd95ab",
          "sha": "55626047076be9763c39f7fc30118e14f2bd95ab",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/55626047076be9763c39f7fc30118e14f2bd95ab"
        }
      ],
      "message": "docs: update README",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-01T10:27:26Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-12T12:57:54Z"
      },
      "sha": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18936863463,
      "node_id": "HRFPE_lADOAP4Jqs6_1gh3zwAAAARouZrn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18936863463",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "commit_url": "https://api.github.com/repos/josibake/secp256k1/commits/b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "created_at": "2025-08-01T10:29:26Z"
    },
    {
      "event": "commented",
      "id": 3144097162,
      "node_id": "IC_kwDOAP4Jqs67Zx2K",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3144097162",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:34:46Z",
      "updated_at": "2025-08-01T10:34:46Z",
      "author_association": "MEMBER",
      "body": "Updated [eb32d06](https://github.com/bitcoin-core/secp256k1/commit/eb32d06a936307fcce649cf8002e49e6f8730948) -> [b26c87d](https://github.com/bitcoin-core/secp256k1/commit/b26c87d5c09ddefe764a9cad6a8612e34ccd13de) ([2025_07](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_07) -> [2025_08](https://github.com/josibake/secp256k1/tree/bip352-silentpayments-module-2025_08), [compare](https://github.com/josibake/secp256k1/compare/bip352-silentpayments-module-2025_07..bip352-silentpayments-module-2025_08))\r\n\r\n* Updated sending API docs (h/t @Sjors)\r\n* Updated comments and improved variable naming for sending (h/t @Sjors)\r\n\r\nThanks for the review, @Sjors !",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3144097162",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1698"
    },
    {
      "event": "mentioned",
      "id": 18936947911,
      "node_id": "MEE_lADOAP4Jqs6_1gh3zwAAAARouuTH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18936947911",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:34:47Z"
    },
    {
      "event": "subscribed",
      "id": 18936947932,
      "node_id": "SE_lADOAP4Jqs6_1gh3zwAAAARouuTc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18936947932",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:34:47Z"
    },
    {
      "event": "unsubscribed",
      "id": 18937315173,
      "node_id": "UE_lADOAP4Jqs6_1gh3zwAAAARowH9l",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/18937315173",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T10:55:46Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2197616199",
      "pull_request_review_id": 3005508488,
      "id": 2197616199,
      "node_id": "PRRC_kwDOAP4Jqs6C_PZH",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 342,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": null,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n *                label_context: pointer to a label context object (NULL if\r\n *                               labels are not used or context is not needed)\r\n```\r\n\r\n(was changed after https://github.com/bitcoin-core/secp256k1/pull/1519#discussion_r1832632525)",
      "created_at": "2025-07-10T12:37:09Z",
      "updated_at": "2025-07-10T16:26:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2197616199",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2197616199"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2198191851",
      "pull_request_review_id": 3005508488,
      "id": 2198191851,
      "node_id": "PRRC_kwDOAP4Jqs6DBb7r",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 346,
      "original_position": 340,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": null,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think it should be documented for how long the returned pointer from `label_lookup` should be valid. I think it is obvious it should be valid until the next call of `label_lookup`, but it is currently not clear (from the docs) whether it should remain valid until `secp256k1_silentpayments_recipient_scan_outputs` returns.\r\nThe current implementation of `secp256k1_silentpayments_recipient_scan_outputs` does not need this (from looking at the code) and in a safe Rust abstraction for this function ([code](https://github.com/antonilol/rust-secp256k1/commit/2b3f63399df449d39d90cd2292a913d2a20136cb), does contain some outdated comments) suggested for https://github.com/rust-bitcoin/rust-secp256k1/pull/721 (WIP bindings to this pull request's code) I relied on this **not** being a requirement (though that can be changed).\r\n",
      "created_at": "2025-07-10T16:26:31Z",
      "updated_at": "2025-07-10T16:26:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2198191851",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2198191851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 341,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 346,
      "original_line": 346,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204412350",
      "pull_request_review_id": 3015616207,
      "id": 2204412350,
      "node_id": "PRRC_kwDOAP4Jqs6DZKm-",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 346,
      "original_position": 340,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hi @antonilol , thanks for the review and bindings code! Agreed that this should be documented. How about something like:\r\n\r\n```diff\r\ndiff --git a/include/secp256k1_silentpayments.h b/include/secp256k1_silentpayments.h\r\nindex 2e71405..11fa596 100644\r\n--- a/include/secp256k1_silentpayments.h\r\n+++ b/include/secp256k1_silentpayments.h\r\n@@ -311,6 +311,11 @@ typedef struct secp256k1_silentpayments_found_output {\r\n  *  the recipient uses labels. This allows for checking if a label exists in\r\n  *  the recipients label cache and retrieving the label tweak during scanning.\r\n  *\r\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\r\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\r\n+ *  valid until the next call to `label_lookup` or until the function returns,\r\n+ *  whichever comes first. It is not retained beyond that.\r\n+ *\r\n  *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\r\n  *  can be used.\r\n  *\r\n  ```\r\n  \r\n  I think the above is the most precise requirement, but perhaps a simpler alternative would be to require that the returned pointer (and labels cache, if used) be valid until `_scan_outputs` returns? You mention you rely on this _not_ being the case today, but does this make a material difference if we _do_ require that the returned pointer and labels cache be valid for the lifetime of the `_scan_outputs` function?",
      "created_at": "2025-07-14T09:53:56Z",
      "updated_at": "2025-07-14T09:53:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204412350",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204412350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 341,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 346,
      "original_line": 346,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204418847",
      "pull_request_review_id": 3015624158,
      "id": 2204418847,
      "node_id": "PRRC_kwDOAP4Jqs6DZMMf",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)\n+ *                label_context: pointer to a label context object (NULL if\n+ *                               labels are not used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 342,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2197616199,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, I've updated the comment and added a test case for the `(lookup, NULL)` argument combination.",
      "created_at": "2025-07-14T09:55:25Z",
      "updated_at": "2025-07-14T09:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204418847",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204418847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204890211",
      "pull_request_review_id": 3016293957,
      "id": 2204890211,
      "node_id": "PRRC_kwDOAP4Jqs6Da_Rj",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 346,
      "original_position": 340,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "antonilol",
        "id": 49868160,
        "node_id": "MDQ6VXNlcjQ5ODY4MTYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/49868160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/antonilol",
        "html_url": "https://github.com/antonilol",
        "followers_url": "https://api.github.com/users/antonilol/followers",
        "following_url": "https://api.github.com/users/antonilol/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/antonilol/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/antonilol/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/antonilol/subscriptions",
        "organizations_url": "https://api.github.com/users/antonilol/orgs",
        "repos_url": "https://api.github.com/users/antonilol/repos",
        "events_url": "https://api.github.com/users/antonilol/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/antonilol/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Looks good!\r\n\r\n> I think the above is the most precise requirement, but perhaps a simpler alternative would be to require that the returned pointer (and labels cache, if used) be valid until `_scan_outputs` returns? You mention you rely on this _not_ being the case today, but does this make a material difference if we _do_ require that the returned pointer and labels cache be valid for the lifetime of the `_scan_outputs` function?\r\n\r\nThis depends on the function signature on the Rust side, I have considered 2 cases. The difference is in what the user has to return from `label_lookup`.\r\n\r\nFirst, there is the one in the proof of concept binding I mentioned here, the user has to return any byte array of length 32 or nothing (translates to NULL pointer).\r\nThe C side accepts a pointer so the Rust side stores this byte array on the stack and gives the C side a pointer to that. This place on the stack is reused, so requiring that the pointer lives for longer than until the next call of `label_lookup` means that previous return values need to be kept and some dynamic allocation would be needed.\r\nI see this as the easiest for user to use. As far as I can tell no borrow checker issues can arise from this design.\r\n\r\nSecond, the user has to return a reference to a byte array of length 32 or nothing. The reference is required to live for as long as the function runs. This is because in Rust it is not (yet) possible to declare the reference is only required to live until the next call of `label_lookup`.\r\nThis is simple to implement because it is basically a pointer cast and is compatible with `_scan_outputs` needing pointers to be valid for the lifetime of the function.\r\nThis one is harder to use, especially for `label_lookup`s that are not simply looking up in a data structure. Returning a reference to any byte array that is not stored outside the function's stack frame is not allowed and storing it on the fly like the first case here probably requires the user to use unsafe code (needs a data structure that allows adding elements while there exist references to its existing elements because the reference is required to live for as long as the function runs) and has the same need for dynamic allocation like the first case can have.\r\n\r\nThe validity of the context pointer should be completely up to the users of the C library (I consider the Rust binding to also be a user of the C library).\r\n\r\nI will also link this discussion in the Rust bindings pull request.",
      "created_at": "2025-07-14T13:00:14Z",
      "updated_at": "2025-07-14T13:00:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2204890211",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2204890211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 341,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 346,
      "original_line": 346,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2205138710",
      "pull_request_review_id": 3016682153,
      "id": 2205138710,
      "node_id": "PRRC_kwDOAP4Jqs6Db78W",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payment outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+static const unsigned char secp256k1_silentpayments_public_data_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.\n+ *  For that reason, the secret keys have to be passed in via two different\n+ *  parameter pairs, depending on whether the seckeys correspond to x-only\n+ *  outputs or not.\n+ *\n+ *  Returns: 1 if creation of outputs was successful. 0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly pubkeys,\n+ *                            one per recipient.\n+ *                            The outputs here are sorted by the index value\n+ *                            provided in the recipient objects.\n+ *  In:           recipients: pointer to an array of pointers to silent payment\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be sorted in place, but\n+ *                            generated outputs are saved in the\n+ *                            `generated_outputs` array to match the ordering\n+ *                            from the index field. This ensures the caller is\n+ *                            able to match the generated outputs to the\n+ *                            correct silent payment addresses. The same\n+ *                            recipient can be passed multiple times to create\n+ *                            multiple outputs for the same recipient.\n+ *              n_recipients: the number of recipients. This is equal to the\n+ *                            total number of outputs to be generated as each\n+ *                            recipient may passed multiple times to generate\n+ *                            multiple outputs for the same recipient\n+ *         outpoint_smallest: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the number of sender's taproot input secret keys\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the number of sender's non-taproot input secret\n+ *                            keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Create Silent Payment label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key b_scan and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *  label_tweak = hash(b_scan || m)\n+ *        label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                ctx: pointer to a context object\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In: recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: label integer (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *recipient_scan_key32,\n+    const uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payment labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key B_spend and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *  B_m = B_spend + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payment address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key each.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if an error occurred.\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend\n+ *                                public key\n+ *  In:   recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                         label: pointer to the recipient's label public\n+ *                                key\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *recipient_spend_pubkey,\n+    const secp256k1_pubkey *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds silent payments public input data.\n+ *\n+ *  This structure does not contain secret data. Guaranteed to be 101 bytes in\n+ *  size. It can be safely copied/moved. Created with\n+ *  `secp256k1_silentpayments_recipient_public_data_create`. Can be serialized as a\n+ *  compressed public key using\n+ *  `secp256k1_silentpayments_recipient_public_data_serialize`. The serialization is\n+ *  intended for sending the public input data to light clients. Light clients\n+ *  can use this serialization with\n+ *  `secp256k1_silentpayments_recipient_public_data_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_recipient_public_data {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_recipient_public_data;\n+\n+/** Compute Silent Payment public data from input public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each silent payment\n+ *  eligible input to spend) and a serialized outpoint_smallest, create a\n+ *  `public_data` object. This object summarizes the public data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common pubkey format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side, or\n+ *  stored in an index for later use (e.g., wallet rescanning, sending data to\n+ *  light clients).\n+ *\n+ *  If calling this function for simply aggregating the public transaction data\n+ *  for later use, the caller can save the result with\n+ *  `silentpayments_recipient_public_data_serialize`.\n+ *\n+ *  Returns: 1 if public data creation was successful. 0 if an error occurred.\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:          public_data: pointer to public_data object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the number of taproot input public keys\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the number of non-taproot input public keys\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a silentpayments_recipient_public_data object into a 33-byte sequence.\n+ *\n+ *  Returns: 1 always.\n+ *\n+ *  Args:         ctx: pointer to a context object\n+ *  Out:     output33: pointer to a 33-byte array to place the serialized\n+ *                     `silentpayments_recipient_public_data` in\n+ *  In:   public_data: pointer to an initialized silentpayments_recipient_public_data\n+ *                     object\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_public_data_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *output33,\n+    const secp256k1_silentpayments_recipient_public_data *public_data\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a 33-byte sequence into a silentpayments_recipients_public_data object.\n+ *\n+ *  Returns: 1 if the data was able to be parsed.\n+ *           0 if the sequence is invalid (e.g., does not represent a valid\n+ *           public key).\n+ *\n+ *  Args:         ctx: pointer to a context object.\n+ *  Out:  public_data: pointer to a silentpayments_recipient_public_data object. If 1 is\n+ *                     returned, it is set to a parsed version of input33.\n+ *  In:       input33: pointer to a serialized silentpayments_recipient_public_data.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_public_data_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_recipient_public_data *public_data,\n+    const unsigned char *input33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache,\n+ *  `secp256k1_silentpayments_recipient_create_label` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label pubkey to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payment transaction outputs.\n+ *\n+ *  Given a public_data object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  For the labels cache, `secp256k1_silentpayments_recipient_create_label`\n+ *  can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if an error occurred.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               be initialized to be the same length as the\n+ *                               tx_outputs array\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found)\n+ *  In:              tx_outputs: pointer to the tx's x-only public key outputs\n+ *                 n_tx_outputs: the number of tx_outputs being scanned\n+ *         recipient_scan_key32: pointer to the recipient's 32 byte scan key\n+ *                  public_data: pointer to the transaction public data\n+ *                               (see `_recipient_public_data_create`).\n+ *       recipient_spend_pubkey: pointer to the recipient's spend pubkey\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               pubkey as an argument and returns a pointer to\n+ *                               the label tweak if the label exists, otherwise\n+ *                               returns a NULL pointer (NULL if labels are not\n+ *                               used)",
      "path": "include/secp256k1_silentpayments.h",
      "position": 346,
      "original_position": 340,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "6264c3d0939f2ab11ba8c92f3cb521f9c89c8596",
      "in_reply_to_id": 2198191851,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for the detailed explanation! As I was thinking through this, it also occurred to me requiring the pointers to be valid for the lifetime of `_scan_outputs` would require keeping around pointers to every label found, even after they had been used by `_scan_outputs`. This seems undesirable, e.g., imagine a transaction with ~15k labeled outputs all paying to a single recipient. Your explanation seems to confirm my understanding.",
      "created_at": "2025-07-14T14:50:29Z",
      "updated_at": "2025-07-14T14:50:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2205138710",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2205138710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": 341,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": 346,
      "original_line": 346,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219105417",
      "pull_request_review_id": 3037944552,
      "id": 2219105417,
      "node_id": "PRRC_kwDOAP4Jqs6ERNyJ",
      "diff_hunk": "@@ -263,5 +286,61 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n         CHECK(ret == 1);\n     }\n \n+#endif\n+\n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    SECP256K1_CHECKMEM_DEFINE(key, 32);\n+\n+    generated_outputs[0] = &generated_output;\n+\n+    /* Initialize recipient */\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.scan_pubkey, key));\n+    key[31] ^= 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.labeled_spend_pubkey, key));\n+    key[31] ^= (1 << 1);\n+    recipient.index = 0;\n+    recipients[0] = &recipient;\n+\n+    /* Set up secret keys */\n+    SECP256K1_CHECKMEM_UNDEFINE(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &taproot_seckey, key);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret);\n+    key[31] ^= (1 << 2);\n+    taproot_seckeys[0] = &taproot_seckey;\n+    plain_seckeys[0] = key;\n+\n+    ret = secp256k1_silentpayments_sender_create_outputs(ctx, generated_outputs, recipients, 1, outpoint_smallest, taproot_seckeys, 1, plain_seckeys, 1);\n+    CHECK(ret == 1);\n+\n+    /* TODO: use non-confusing public key */\n+    ret = secp256k1_silentpayments_recipient_create_label(ctx, &recipient.labeled_spend_pubkey, label_tweak, key, 0);\n+    key[31] ^= (1 << 3);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey, NULL, &taproot_seckey));\n+    SECP256K1_CHECKMEM_DEFINE(&xonly_pubkey, sizeof(xonly_pubkey));\n+    xonly_pubkeys[0] = &xonly_pubkey;\n+    ret = secp256k1_ec_pubkey_create(ctx, &plain_pubkey, plain_seckeys[0]);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+    SECP256K1_CHECKMEM_DEFINE(&plain_pubkey, sizeof(plain_pubkey));\n+    plain_pubkeys[0] = &plain_pubkey;\n+\n+    ret = secp256k1_silentpayments_recipient_public_data_create(ctx, &public_data, outpoint_smallest, xonly_pubkeys, 1, plain_pubkeys, 1);\n+    CHECK(ret == 1);\n+\n+    tx_outputs[0] = generated_outputs[0];\n+    n_found_outputs = 1;\n+    SECP256K1_CHECKMEM_DEFINE(&recipient.labeled_spend_pubkey, sizeof(recipient.labeled_spend_pubkey));\n+    /* TODO: make sure we're actually go through all relevant code paths */\n+    ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\n+    CHECK(ret == 1);\n+\n+    /* TODO: this fails */\n+    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\n+    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */",
      "path": "src/ctime_tests.c",
      "position": null,
      "original_position": 95,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit de508a78ac66b93b0ff83b419cc6e149950ecc25: took a look into these TODOs, I think the following patch would tackle them (note that the serialize/parse-roundtrip looks superfluous at first sight, but it is needed to set the \"combined\" flag in the public data, which is ARG_CHECKEDed for 1 in _recipient_create_shared_secret):\r\n```diff\r\ndiff --git a/src/ctime_tests.c b/src/ctime_tests.c\r\nindex 17964b9..83596a3 100644\r\n--- a/src/ctime_tests.c\r\n+++ b/src/ctime_tests.c\r\n@@ -116,6 +116,8 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\r\n     const secp256k1_xonly_pubkey *xonly_pubkeys[1];\r\n     secp256k1_pubkey plain_pubkey;\r\n     const secp256k1_pubkey *plain_pubkeys[1];\r\n+    unsigned char public_data_ser[33] = { 0 };\r\n+    unsigned char shared_secret[33] = { 0 };\r\n #endif\r\n \r\n     for (i = 0; i < 32; i++) {\r\n@@ -338,9 +340,10 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\r\n     ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\r\n     CHECK(ret == 1);\r\n \r\n-    /* TODO: this fails */\r\n-    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\r\n-    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */\r\n+    CHECK(secp256k1_silentpayments_recipient_public_data_serialize(ctx, public_data_ser, &public_data));\r\n+    CHECK(secp256k1_silentpayments_recipient_public_data_parse(ctx, &public_data, public_data_ser));\r\n+    CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data));\r\n+    CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(ctx, &xonly_pubkey, shared_secret, &recipient.labeled_spend_pubkey, 0));\r\n \r\n #endif\r\n }\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\nindex 3fc42f5..7d3ad41 100644\r\n--- a/src/modules/silentpayments/main_impl.h\r\n+++ b/src/modules/silentpayments/main_impl.h\r\n@@ -708,6 +708,7 @@ int secp256k1_silentpayments_recipient_create_shared_secret(const secp256k1_cont\r\n     ret &= secp256k1_scalar_set_b32_seckey(&rsk, recipient_scan_key32);\r\n     ret &= secp256k1_silentpayments_recipient_public_data_load_pubkey(ctx, &A_tweaked_ge, public_data);\r\n     /* If there are any issues with the recipient scan key or public data, return early */\r\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\r\n     if (!ret) {\r\n         return 0;\r\n     }\r\n```",
      "created_at": "2025-07-21T12:45:14Z",
      "updated_at": "2025-07-21T12:45:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2219105417",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219105417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219368126",
      "pull_request_review_id": 3038350839,
      "id": 2219368126,
      "node_id": "PRRC_kwDOAP4Jqs6ESN6-",
      "diff_hunk": "@@ -263,5 +286,61 @@ static void run_tests(secp256k1_context *ctx, unsigned char *key) {\n         CHECK(ret == 1);\n     }\n \n+#endif\n+\n+#ifdef ENABLE_MODULE_SILENTPAYMENTS\n+    SECP256K1_CHECKMEM_DEFINE(key, 32);\n+\n+    generated_outputs[0] = &generated_output;\n+\n+    /* Initialize recipient */\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.scan_pubkey, key));\n+    key[31] ^= 1;\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &recipient.labeled_spend_pubkey, key));\n+    key[31] ^= (1 << 1);\n+    recipient.index = 0;\n+    recipients[0] = &recipient;\n+\n+    /* Set up secret keys */\n+    SECP256K1_CHECKMEM_UNDEFINE(key, 32);\n+    ret = secp256k1_keypair_create(ctx, &taproot_seckey, key);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret);\n+    key[31] ^= (1 << 2);\n+    taproot_seckeys[0] = &taproot_seckey;\n+    plain_seckeys[0] = key;\n+\n+    ret = secp256k1_silentpayments_sender_create_outputs(ctx, generated_outputs, recipients, 1, outpoint_smallest, taproot_seckeys, 1, plain_seckeys, 1);\n+    CHECK(ret == 1);\n+\n+    /* TODO: use non-confusing public key */\n+    ret = secp256k1_silentpayments_recipient_create_label(ctx, &recipient.labeled_spend_pubkey, label_tweak, key, 0);\n+    key[31] ^= (1 << 3);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey, NULL, &taproot_seckey));\n+    SECP256K1_CHECKMEM_DEFINE(&xonly_pubkey, sizeof(xonly_pubkey));\n+    xonly_pubkeys[0] = &xonly_pubkey;\n+    ret = secp256k1_ec_pubkey_create(ctx, &plain_pubkey, plain_seckeys[0]);\n+    SECP256K1_CHECKMEM_DEFINE(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+    SECP256K1_CHECKMEM_DEFINE(&plain_pubkey, sizeof(plain_pubkey));\n+    plain_pubkeys[0] = &plain_pubkey;\n+\n+    ret = secp256k1_silentpayments_recipient_public_data_create(ctx, &public_data, outpoint_smallest, xonly_pubkeys, 1, plain_pubkeys, 1);\n+    CHECK(ret == 1);\n+\n+    tx_outputs[0] = generated_outputs[0];\n+    n_found_outputs = 1;\n+    SECP256K1_CHECKMEM_DEFINE(&recipient.labeled_spend_pubkey, sizeof(recipient.labeled_spend_pubkey));\n+    /* TODO: make sure we're actually go through all relevant code paths */\n+    ret = secp256k1_silentpayments_recipient_scan_outputs(ctx, found_outputs, &n_found_outputs, tx_outputs, 1, key, &public_data, &recipient.labeled_spend_pubkey, NULL, NULL);\n+    CHECK(ret == 1);\n+\n+    /* TODO: this fails */\n+    /* CHECK(secp256k1_silentpayments_recipient_create_shared_secret(ctx, shared_secret, key, &public_data)); */\n+    /* TODO: test secp256k1_silentpayments_recipient_create_output_pubkey */",
      "path": "src/ctime_tests.c",
      "position": null,
      "original_position": 95,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "de508a78ac66b93b0ff83b419cc6e149950ecc25",
      "in_reply_to_id": 2219105417,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for the patch! I've updated the ctime tests to use this, and also removed the remaining TODOs from the test file (with comments where appropriate).",
      "created_at": "2025-07-21T14:18:16Z",
      "updated_at": "2025-07-21T14:18:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2219368126",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2219368126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 341,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2225857523",
      "pull_request_review_id": 3047815175,
      "id": 2225857523,
      "node_id": "PRRC_kwDOAP4Jqs6Eq-Pz",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 896e0af2f883d21ba3540290f176dcaa7f57272d: As for those TODOs, probably the safest option is to return an error if `_pubkey_tweak_add` indeed fails? Initially I assumed that doing that would introduce a branch that can't be tested in practice, but I think it is: by picking arbitrary `shared_secret33` and `k` values, and calculating `recipient_labeled_spend_pubkey` as `-G^(_create_t_k(shared_secret33, k))` the tweaking should fail with these three values. Will try to come up with some test code later to verify.",
      "created_at": "2025-07-23T14:51:40Z",
      "updated_at": "2025-07-23T14:51:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2225857523",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2225857523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2226200883",
      "pull_request_review_id": 3048350883,
      "id": 2226200883,
      "node_id": "PRRC_kwDOAP4Jqs6EsSEz",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, managed to come up with a test that makes the VERIFY_CHECK on the `_pubkey_tweak_add` return value fail:\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/tests_impl.h b/src/modules/silentpayments/tests_impl.h\r\nindex a1acab7..2a10791 100644\r\n--- a/src/modules/silentpayments/tests_impl.h\r\n+++ b/src/modules/silentpayments/tests_impl.h\r\n@@ -367,6 +367,23 @@ static void test_recipient_api(void) {\r\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_output_pubkey(CTX, &t, NULL, &p, 0));\r\n     CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_output_pubkey(CTX, &t, o, NULL, 0));\r\n \r\n+    /* check the _recipient_create_output_pubkey cornercase where internal tweaking would fail;\r\n+       this is the case if the recipient spend public key is P = -(create_t_k(shared_secret, k))*G */\r\n+    {\r\n+        const unsigned char *shared_secret = o;\r\n+        const uint32_t k = 0;\r\n+        secp256k1_scalar t_k;\r\n+        unsigned char t_k_ser[32];\r\n+        secp256k1_pubkey fake_spend_pubkey;\r\n+        secp256k1_xonly_pubkey output_xonly;\r\n+\r\n+        secp256k1_silentpayments_create_t_k(&t_k, shared_secret, k);\r\n+        secp256k1_scalar_get_b32(t_k_ser, &t_k);\r\n+        CHECK(secp256k1_ec_pubkey_create(CTX, &fake_spend_pubkey, t_k_ser));\r\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &fake_spend_pubkey));\r\n+        CHECK(secp256k1_silentpayments_create_output_pubkey(CTX, &output_xonly, shared_secret, &fake_spend_pubkey, k) == 0);\r\n+    }\r\n+\r\n     n_f = 0;\r\n     labels_cache.entries_used = 0;\r\n     CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp, 1, ALICE_SECKEY, &pd, &p, &label_lookup, &labels_cache));\r\n```\r\n</details>\r\n\r\nI assume that in practice a user can't be tricked into such a scenario though, as the recipient spend public key is known/generated before the shared secret is.",
      "created_at": "2025-07-23T17:14:12Z",
      "updated_at": "2025-07-23T17:14:12Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2226200883",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2226200883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2228336402",
      "pull_request_review_id": 3051391771,
      "id": 2228336402,
      "node_id": "PRRC_kwDOAP4Jqs6E0bcS",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Awesome! IIRC, the initial hesitance to returning a value was adding an untestable branch in the code. But considering this can be exercised in a test (which indicates its not inconceivable that someone could be tricked into calling this function with a maliciously crafted spend pubkey), I removed the VERIFY_CHECK in favour of returning the value and added your test case. Thanks for working on this!",
      "created_at": "2025-07-24T12:10:33Z",
      "updated_at": "2025-07-24T12:10:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2228336402",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2228336402"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229570600",
      "pull_request_review_id": 3053302400,
      "id": 2229570600,
      "node_id": "PRRC_kwDOAP4Jqs6E5Iwo",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 246,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Suggestion for the comment to tackle another TODO 🔫  (IIUC, the non-constant timing of group element serialization seems to ultimately be caused by [variable-time normalization of field elements](https://github.com/bitcoin-core/secp256k1/blob/b9313c6e1a6082a66b4c75777e18ca4b176fcf9d/src/eckey_impl.h#L44-L45)):\r\n```suggestion\r\n    /* Need to declassify the pubkey sum because serializing a group element (done in the\r\n       `_calculate_input_hash` call following) is not a constant-time operation */\r\n    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\r\n```",
      "created_at": "2025-07-24T21:04:03Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229570600",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229570600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 249,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229577936",
      "pull_request_review_id": 3053302400,
      "id": 2229577936,
      "node_id": "PRRC_kwDOAP4Jqs6E5KjQ",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 141,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "only noticing now that in one of my [earlier comments](https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2225857523) I was using multiplicative notation (cryptocamp leaving its marks already I guess 😁)\r\n```suggestion\r\n     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\r\n```",
      "created_at": "2025-07-24T21:07:46Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229577936",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229577936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229609301",
      "pull_request_review_id": 3053302400,
      "id": 2229609301,
      "node_id": "PRRC_kwDOAP4Jqs6E5SNV",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 282,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should also memclear the shared secret here and in the error path a few lines above (admitedly a bit annoying though that this leads to so much code duplication :/)",
      "created_at": "2025-07-24T21:22:37Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229609301",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229609301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 285,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 299,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229624153",
      "pull_request_review_id": 3053302400,
      "id": 2229624153,
      "node_id": "PRRC_kwDOAP4Jqs6E5V1Z",
      "diff_hunk": "@@ -0,0 +1,618 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 151,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "72489a733c81153782eba2e4dded316dccc55c99",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could update the `main` return values in the example to use `EXIT_FAILURE`/`EXIT_SUCCESS` (done for other examples in #1654)",
      "created_at": "2025-07-24T21:32:44Z",
      "updated_at": "2025-07-24T21:35:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2229624153",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2229624153"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230327932",
      "pull_request_review_id": 3054340559,
      "id": 2230327932,
      "node_id": "PRRC_kwDOAP4Jqs6E8Bp8",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 141,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229577936,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was about to ask what this strange \"`-`\" symbol in `-G^(_create_t_k(shared_secret33, k))` is supposed to mean. :stuck_out_tongue:  ",
      "created_at": "2025-07-25T07:04:44Z",
      "updated_at": "2025-07-25T07:04:44Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230327932",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230327932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230609936",
      "pull_request_review_id": 3054721891,
      "id": 2230609936,
      "node_id": "PRRC_kwDOAP4Jqs6E9GgQ",
      "diff_hunk": "@@ -0,0 +1,618 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Static data for Bob and Carol's silent payment addresses */\n+static unsigned char smallest_outpoint[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char bob_scan_key[32] = {\n+    0xa8, 0x90, 0x54, 0xc9, 0x5b, 0xe3, 0xc3, 0x01,\n+    0x56, 0x65, 0x74, 0xf2, 0xaa, 0x93, 0xad, 0xe0,\n+    0x51, 0x85, 0x09, 0x03, 0xa6, 0x9c, 0xbd, 0xd1,\n+    0xd4, 0x7e, 0xae, 0x26, 0x3d, 0x7b, 0xc0, 0x31\n+};\n+static unsigned char bob_spend_key[32] = {\n+    0x9d, 0x6a, 0xd8, 0x55, 0xce, 0x34, 0x17, 0xef,\n+    0x84, 0xe8, 0x36, 0x89, 0x2e, 0x5a, 0x56, 0x39,\n+    0x2b, 0xfb, 0xa0, 0x5f, 0xa5, 0xd9, 0x7c, 0xce,\n+    0xa3, 0x0e, 0x26, 0x6f, 0x54, 0x0e, 0x08, 0xb3\n+};\n+static unsigned char bob_spend_pubkey[33] = {\n+    0x02, 0x5c, 0xc9, 0x85, 0x6d, 0x6f, 0x83, 0x75,\n+    0x35, 0x0e, 0x12, 0x39, 0x78, 0xda, 0xac, 0x20,\n+    0x0c, 0x26, 0x0c, 0xb5, 0xb5, 0xae, 0x83, 0x10,\n+    0x6c, 0xab, 0x90, 0x48, 0x4d, 0xcd, 0x8f, 0xcf, 0x36\n+};\n+static unsigned char bob_address[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f, 0x23\n+    },\n+    {\n+        0x03, 0x0b, 0x9d, 0xd4, 0x9d, 0xf2, 0xc6, 0x85,\n+        0x23, 0xbb, 0x0c, 0x72, 0xd4, 0xfb, 0x59, 0xb6,\n+        0x4c, 0xe5, 0xc9, 0xa9, 0x33, 0x6d, 0x0b, 0xef,\n+        0x94, 0x9e, 0xe0, 0x77, 0x5b, 0xea, 0x61, 0xef, 0x05\n+    }\n+};\n+static unsigned char carol_scan_key[32] = {\n+    0x04, 0xb2, 0xa4, 0x11, 0x63, 0x5c, 0x09, 0x77,\n+    0x59, 0xaa, 0xcd, 0x0f, 0x00, 0x5a, 0x4c, 0x82,\n+    0xc8, 0xc9, 0x28, 0x62, 0xc6, 0xfc, 0x28, 0x4b,\n+    0x80, 0xb8, 0xef, 0xeb, 0xc2, 0x0c, 0x3d, 0x17\n+};\n+static unsigned char carol_address[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed, 0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7, 0x16\n+    }\n+};\n+\n+/** Labels\n+ *\n+ *  The structs and call back function are implemented here as a demonstration\n+ *  of how the label lookup callback is meant to query a label cache and return\n+ *  the label tweak when a match is found. This is for demonstration purposes\n+ *  only and not optimized. In a production usecase, it is expected that the\n+ *  caller will be using a much more performant method for storing and querying\n+ *  labels.\n+ *\n+ *  Recipients not using labels can ignore these steps and simply pass `NULL`\n+ *  for the label_lookup and label_context arguments:\n+ *\n+ *      secp256k1_silentpayments_recipient_scan_outputs(..., NULL, NULL);\n+ */\n+\n+struct label_cache_entry {\n+    unsigned char label[33];\n+    unsigned char label_tweak[32];\n+};\n+\n+struct labels_cache {\n+    size_t entries_used;\n+    struct label_cache_entry entries[5];\n+};\n+\n+const unsigned char* label_lookup(\n+    const unsigned char* label33,\n+    const void* cache_ptr\n+) {\n+    const struct labels_cache* cache = (const struct labels_cache*)cache_ptr;\n+    size_t i;\n+    for (i = 0; i < cache->entries_used; i++) {\n+        if (my_memcmp_var(cache->entries[i].label, label33, 33) == 0) {\n+            return cache->entries[i].label_tweak;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+int main(void) {\n+    enum { N_INPUTS = 2, N_OUTPUTS = 3 };\n+    unsigned char randomize[32];\n+    unsigned char serialized_xonly[32];\n+    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\n+    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\n+    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\n+    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\n+    int ret;\n+    size_t i;\n+\n+    /* Before we can call actual API functions, we need to create a \"context\" */\n+    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    if (!fill_random(randomize, sizeof(randomize))) {\n+        printf(\"Failed to generate randomness\\n\");\n+        return 1;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 151,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "72489a733c81153782eba2e4dded316dccc55c99",
      "in_reply_to_id": 2229624153,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-07-25T09:20:32Z",
      "updated_at": "2025-07-25T09:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230609936",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230609936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230612333",
      "pull_request_review_id": 3054725418,
      "id": 2230612333,
      "node_id": "PRRC_kwDOAP4Jqs6E9HFt",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 282,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229609301,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, also slightly reworded the comment. Overall, while slightly annoying, the code duplication doesn't seem too bad to me and I don't see a clever way to DRY it up.",
      "created_at": "2025-07-25T09:21:26Z",
      "updated_at": "2025-07-25T09:21:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230612333",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230612333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 285,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 299,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230613364",
      "pull_request_review_id": 3054726664,
      "id": 2230613364,
      "node_id": "PRRC_kwDOAP4Jqs6E9HV0",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 141,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229577936,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Team additive 💪 ",
      "created_at": "2025-07-25T09:21:56Z",
      "updated_at": "2025-07-25T09:21:56Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230613364",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230613364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230614608",
      "pull_request_review_id": 3054728553,
      "id": 2230614608,
      "node_id": "PRRC_kwDOAP4Jqs6E9HpQ",
      "diff_hunk": "@@ -7,10 +7,296 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -G^(_create_t_k(shared_secret33, k))\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* TODO: comment */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 246,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "78bbd7b65fdc3ffa4dbc8267b8bff0802f84f53e",
      "in_reply_to_id": 2229570600,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for digging into this! Added the comment with some slight formatting changes.",
      "created_at": "2025-07-25T09:22:25Z",
      "updated_at": "2025-07-25T09:22:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230614608",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230614608"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 249,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230617988",
      "pull_request_review_id": 3054733915,
      "id": 2230617988,
      "node_id": "PRRC_kwDOAP4Jqs6E9IeE",
      "diff_hunk": "@@ -7,10 +7,297 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+    int ret;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    ret = secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar);\n+    /* tweak add only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function. */\n+    /* TODO: consider declassify ret */\n+    /* TODO: but we don't want to imply this can never happen */\n+    VERIFY_CHECK(ret);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 144,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "896e0af2f883d21ba3540290f176dcaa7f57272d",
      "in_reply_to_id": 2225857523,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated this to actually calculate the shared secret from the public data object, to make valgrind happy.",
      "created_at": "2025-07-25T09:23:51Z",
      "updated_at": "2025-07-25T09:23:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2230617988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2230617988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": 144,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236470910",
      "pull_request_review_id": 3062729343,
      "id": 2236470910,
      "node_id": "PRRC_kwDOAP4Jqs6FTdZ-",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": null,
      "original_position": 111,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It might make sense to split this benchmark into \"labeled\" and \"unlabeled\" variants in order to also get a feeling how overhead the labels scanning causes, with something like e.g.:\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/bench_impl.h b/src/modules/silentpayments/bench_impl.h\r\nindex 1dd1e5a..366d172 100644\r\n--- a/src/modules/silentpayments/bench_impl.h\r\n+++ b/src/modules/silentpayments/bench_impl.h\r\n@@ -108,7 +108,7 @@ static void bench_silentpayments_output_scan(void* arg, int iters) {\r\n     }\r\n }\r\n \r\n-static void bench_silentpayments_full_tx_scan(void* arg, int iters) {\r\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters, int use_labels) {\r\n     int i;\r\n     size_t n_found = 0;\r\n     secp256k1_silentpayments_found_output *found_output_ptrs[2];\r\n@@ -116,6 +116,8 @@ static void bench_silentpayments_full_tx_scan(void* arg, int iters) {\r\n     const secp256k1_xonly_pubkey *tx_input_ptrs[2];\r\n     bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\r\n     secp256k1_silentpayments_recipient_public_data public_data;\r\n+    const secp256k1_silentpayments_label_lookup label_lookup_fn = use_labels ? label_lookup : NULL;\r\n+    const void *label_context = use_labels ? label_cache : NULL;\r\n \r\n     for (i = 0; i < 2; i++) {\r\n         found_output_ptrs[i] = &data->found_outputs[i];\r\n@@ -135,11 +137,19 @@ static void bench_silentpayments_full_tx_scan(void* arg, int iters) {\r\n             data->scan_key,\r\n             &public_data,\r\n             &data->spend_pubkey,\r\n-            label_lookup, label_cache)\r\n+            label_lookup_fn, label_context)\r\n         );\r\n     }\r\n }\r\n \r\n+static void bench_silentpayments_full_tx_scan_unlabeled(void *arg, int iters) {\r\n+    bench_silentpayments_full_tx_scan(arg, iters, 0);\r\n+}\r\n+\r\n+static void bench_silentpayments_full_tx_scan_labeled(void *arg, int iters) {\r\n+    bench_silentpayments_full_tx_scan(arg, iters, 1);\r\n+}\r\n+\r\n static void run_silentpayments_bench(int iters, int argc, char** argv) {\r\n     bench_silentpayments_data data;\r\n     int d = argc == 1;\r\n@@ -147,7 +157,8 @@ static void run_silentpayments_bench(int iters, int argc, char** argv) {\r\n     /* create a context with no capabilities */\r\n     data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\r\n \r\n-    if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_full_tx_scan\", bench_silentpayments_full_tx_scan, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n+    if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_full_tx_scan_labeled\", bench_silentpayments_full_tx_scan_labeled, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n+    if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_full_tx_scan_unlabeled\", bench_silentpayments_full_tx_scan_unlabeled, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n     if (d || have_flag(argc, argv, \"silentpayments\")) run_benchmark(\"silentpayments_output_scan\", bench_silentpayments_output_scan, bench_silentpayments_scan_setup, NULL, &data, 10, iters);\r\n \r\n     secp256k1_context_destroy(data.ctx);\r\n\r\n```\r\n</details>\r\nResults on my machine:\r\n\r\n```\r\nBenchmark                     ,    Min(us)    ,    Avg(us)    ,    Max(us)\r\n\r\nsilentpayments_full_tx_scan_labeled,    94.6       ,    96.6       ,   101.0\r\nsilentpayments_full_tx_scan_unlabeled,    82.7       ,    84.2       ,    85.9\r\nsilentpayments_output_scan    ,    85.3       ,    87.5       ,    90.7\r\n```",
      "created_at": "2025-07-28T13:27:27Z",
      "updated_at": "2025-07-28T13:27:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2236470910",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236470910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236659827",
      "pull_request_review_id": 3062979375,
      "id": 2236659827,
      "node_id": "PRRC_kwDOAP4Jqs6FULhz",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": null,
      "original_position": 111,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agreed. I added the dummy labels originally to make sure I was reporting worst-case[^1] numbers for the full scan benchmark, and the idea was to add more benchmarks in a follow-up that more accurately benchmark labels. However, I think what you have here is nicer and we can still leave a TODO comment to add a more representative benchmark for scanning _with_ labels.\r\n\r\n[^1]: worst case in the sense that all of the scan-with-labels code paths are hit during the benchmark. Its not an actual worst case in that you could have a very large, poorly implemented labels cache which would necessarily slow down scanning",
      "created_at": "2025-07-28T14:11:33Z",
      "updated_at": "2025-07-28T14:11:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2236659827",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2236659827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2237486984",
      "pull_request_review_id": 3064088495,
      "id": 2237486984,
      "node_id": "PRRC_kwDOAP4Jqs6FXVeI",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": null,
      "original_position": 111,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added your diff with a few minor naming differences and left a TODO comment for filling out the labels benchmark in a follow-up. In particular, I would be interested to see a benchmark that demonstrates that scan time is largely unaffected by label cache size, e.g., scanning with 10 labels vs 100,000 labels shouldn't make a difference. I think this should be a follow-up, however, since it's not strictly necessary and will likely require dedicated review of its own to get things right. ",
      "created_at": "2025-07-28T18:09:35Z",
      "updated_at": "2025-07-28T18:09:35Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2237486984",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2237486984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2240863450",
      "pull_request_review_id": 3069025328,
      "id": 2240863450,
      "node_id": "PRRC_kwDOAP4Jqs6FkNza",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": null,
      "original_position": 111,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Seems fine to limit the scanning-with-labels benchmark to the cryptography-related parts for now. The planned extended benchmark doesn't even necessarily have to live in the secp repo IMHO, it could as well be in a project using the module (i.e. Bitcoin Core in our case), where a labels cache has to be implemented anyways and we wouldn't have to fake it (which might be non-trivial in C to achieve something representative, as I guess we'd need to implement some hashmap-like data structure a la `std::unordered_map`?). But no hard feelings on the details of where/how, I agree that seeing such a followup would be very interesting indeed.",
      "created_at": "2025-07-29T20:08:33Z",
      "updated_at": "2025-07-29T20:08:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2240863450",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2240863450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2242248473",
      "pull_request_review_id": 3070874257,
      "id": 2242248473,
      "node_id": "PRRC_kwDOAP4Jqs6Fpf8Z",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+/***********************************************************************\n+ * Copyright (c) 2024 josibake                                         *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_BENCH_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+typedef struct {\n+    secp256k1_context *ctx;\n+    secp256k1_pubkey spend_pubkey;\n+    unsigned char scan_key[32];\n+    unsigned char input_pubkey33[33];\n+    secp256k1_xonly_pubkey tx_outputs[2];\n+    secp256k1_xonly_pubkey tx_inputs[2];\n+    secp256k1_silentpayments_found_output found_outputs[2];\n+    unsigned char scalar[32];\n+    unsigned char smallest_outpoint[36];\n+} bench_silentpayments_data;\n+\n+/* we need a non-null pointer for the cache */\n+static int noop;\n+void* label_cache = &noop;\n+const unsigned char* label_lookup(const unsigned char* key, const void* cache_ptr) {\n+    (void)key;\n+    (void)cache_ptr;\n+    return NULL;\n+}\n+\n+static void bench_silentpayments_scan_setup(void* arg) {\n+    int i;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    const unsigned char tx_outputs[2][32] = {\n+        {0x84,0x17,0x92,0xc3,0x3c,0x9d,0xc6,0x19,0x3e,0x76,0x74,0x41,0x34,0x12,0x5d,0x40,0xad,0xd8,0xf2,0xf4,0xa9,0x64,0x75,0xf2,0x8b,0xa1,0x50,0xbe,0x03,0x2d,0x64,0xe8},\n+        {0x2e,0x84,0x7b,0xb0,0x1d,0x1b,0x49,0x1d,0xa5,0x12,0xdd,0xd7,0x60,0xb8,0x50,0x96,0x17,0xee,0x38,0x05,0x70,0x03,0xd6,0x11,0x5d,0x00,0xba,0x56,0x24,0x51,0x32,0x3a},\n+    };\n+    const unsigned char static_tx_input[32] = {\n+        0xf2,0x07,0x16,0x2b,0x1a,0x7a,0xbc,0x51,\n+        0xc4,0x20,0x17,0xbe,0xf0,0x55,0xe9,0xec,\n+        0x1e,0xfc,0x3d,0x35,0x67,0xcb,0x72,0x03,\n+        0x57,0xe2,0xb8,0x43,0x25,0xdb,0x33,0xac\n+    };\n+    const unsigned char smallest_outpoint[36] = {\n+        0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+        0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+        0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+        0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00,\n+    };\n+    const unsigned char spend_pubkey[33] = {\n+        0x02,0xee,0x97,0xdf,0x83,0xb2,0x54,0x6a,\n+        0xf5,0xa7,0xd0,0x62,0x15,0xd9,0x8b,0xcb,\n+        0x63,0x7f,0xe0,0x5d,0xd0,0xfa,0x37,0x3b,\n+        0xd8,0x20,0xe6,0x64,0xd3,0x72,0xde,0x9a,0x01\n+    };\n+    const unsigned char scan_key[32] = {\n+        0xa8,0x90,0x54,0xc9,0x5b,0xe3,0xc3,0x01,\n+        0x56,0x65,0x74,0xf2,0xaa,0x93,0xad,0xe0,\n+        0x51,0x85,0x09,0x03,0xa6,0x9c,0xbd,0xd1,\n+        0xd4,0x7e,0xae,0x26,0x3d,0x7b,0xc0,0x31\n+    };\n+    secp256k1_keypair input_keypair;\n+    secp256k1_pubkey input_pubkey;\n+    size_t pubkeylen = 33;\n+\n+    for (i = 0; i < 32; i++) {\n+        data->scalar[i] = i + 1;\n+    }\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_outputs[i], tx_outputs[i]));\n+    }\n+    /* Create the first input public key from the scalar.\n+     * This input is also used to create the serialized public data object for the light client\n+     */\n+    CHECK(secp256k1_keypair_create(data->ctx, &input_keypair, data->scalar));\n+    CHECK(secp256k1_keypair_pub(data->ctx, &input_pubkey, &input_keypair));\n+    CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->input_pubkey33, &pubkeylen, &input_pubkey, SECP256K1_EC_COMPRESSED));\n+    /* Create the input public keys for the full scan */\n+    CHECK(secp256k1_keypair_xonly_pub(data->ctx, &data->tx_inputs[0], NULL, &input_keypair));\n+    CHECK(secp256k1_xonly_pubkey_parse(data->ctx, &data->tx_inputs[1], static_tx_input));\n+    CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->spend_pubkey, spend_pubkey, pubkeylen));\n+    memcpy(data->scan_key, scan_key, 32);\n+    memcpy(data->smallest_outpoint, smallest_outpoint, 36);\n+}\n+\n+static void bench_silentpayments_output_scan(void* arg, int iters) {\n+    int i, k = 0;\n+    bench_silentpayments_data *data = (bench_silentpayments_data*)arg;\n+    secp256k1_silentpayments_recipient_public_data public_data;\n+\n+    for (i = 0; i < iters; i++) {\n+        unsigned char shared_secret[33];\n+        secp256k1_xonly_pubkey xonly_output;\n+        CHECK(secp256k1_silentpayments_recipient_public_data_parse(data->ctx, &public_data, data->input_pubkey33));\n+        CHECK(secp256k1_silentpayments_recipient_create_shared_secret(data->ctx,\n+            shared_secret,\n+            data->scan_key,\n+            &public_data\n+        ));\n+        CHECK(secp256k1_silentpayments_recipient_create_output_pubkey(data->ctx,\n+            &xonly_output,\n+            shared_secret,\n+            &data->spend_pubkey,\n+            k\n+        ));\n+    }\n+}\n+\n+static void bench_silentpayments_full_tx_scan(void* arg, int iters) {",
      "path": "src/modules/silentpayments/bench_impl.h",
      "position": null,
      "original_position": 111,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "e18e04f63c130738952f3f61717befd852ac0eec",
      "in_reply_to_id": 2236470910,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Excellent point regarding the hashmap. I'll leave the TODO comment for now, but it might be that the follow-up is simply to remove the comment in favour of, as you suggest, benchmarking this in a more realistic setting like Bitcoin Core.",
      "created_at": "2025-07-30T10:48:11Z",
      "updated_at": "2025-07-30T10:48:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2242248473",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2242248473"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244025546",
      "pull_request_review_id": 3073577403,
      "id": 2244025546,
      "node_id": "PRRC_kwDOAP4Jqs6FwRzK",
      "diff_hunk": "@@ -0,0 +1,619 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return EXIT_SUCCESS;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 35,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "070ea002339bf10603da5dd772795c7ccae3af51",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in 070ea002339bf10603da5dd772795c7ccae3af51, function `my_memcmp_var`\r\n```suggestion\r\n    return 0;\r\n```\r\nas this doesn't indicate a process execution status",
      "created_at": "2025-07-30T23:05:57Z",
      "updated_at": "2025-07-30T23:49:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2244025546",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244025546"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244864246",
      "pull_request_review_id": 3074665943,
      "id": 2244864246,
      "node_id": "PRRC_kwDOAP4Jqs6Fzej2",
      "diff_hunk": "@@ -0,0 +1,619 @@\n+/*************************************************************************\n+ * To the extent possible under law, the author(s) have dedicated all    *\n+ * copyright and related and neighboring rights to the software in this  *\n+ * file to the public domain worldwide. This software is distributed     *\n+ * without any warranty. For the CC0 Public Domain Dedication, see       *\n+ * EXAMPLES_COPYING or https://creativecommons.org/publicdomain/zero/1.0 *\n+ *************************************************************************/\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <secp256k1_extrakeys.h>\n+#include <secp256k1_silentpayments.h>\n+\n+#include \"examples_util.h\"\n+\n+/* Use my_memcmp_var instead of memcmp.\n+ *\n+ * Normally, memcmp should be fine, but we use my_memcmp_var\n+ * here to avoid a false positive from valgrind on macOS.\n+ * TODO: remove this in the event the bug is fixed with valgrind in the future.\n+ */\n+static int my_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return EXIT_SUCCESS;",
      "path": "examples/silentpayments.c",
      "position": null,
      "original_position": 35,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "070ea002339bf10603da5dd772795c7ccae3af51",
      "in_reply_to_id": 2244025546,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, good catch!",
      "created_at": "2025-07-31T09:33:28Z",
      "updated_at": "2025-07-31T09:33:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2244864246",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2244864246"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245393152",
      "pull_request_review_id": 3075428613,
      "id": 2245393152,
      "node_id": "PRRC_kwDOAP4Jqs6F1fsA",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 36,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: it may be worth reminding the reader why there's never more than one secret key per input; BIP352 excludes inputs \"with conditional branches or multiple public keys\". ",
      "created_at": "2025-07-31T13:23:55Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245393152",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245393152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245418259",
      "pull_request_review_id": 3075428613,
      "id": 2245418259,
      "node_id": "PRRC_kwDOAP4Jqs6F1l0T",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 47,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: the taproot secret keys",
      "created_at": "2025-07-31T13:33:02Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245418259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245418259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245425545",
      "pull_request_review_id": 3075428613,
      "id": 2245425545,
      "node_id": "PRRC_kwDOAP4Jqs6F1nmJ",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 66,
      "original_position": 45,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: I still think it would be nice to have a helper for this, but it can be introduced in a later PR.",
      "created_at": "2025-07-31T13:35:58Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245425545",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245425545"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245490407",
      "pull_request_review_id": 3075428613,
      "id": 2245490407,
      "node_id": "PRRC_kwDOAP4Jqs6F13bn",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 9,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: from offline conversation my understanding is as follows:\r\n\r\nWe don't add a tie breaker here (e.g. `->index`) because:\r\n\r\n1. The protocol doesn't require it\r\n2. It would break the constant time property of heap sort\r\n\r\nIf so, it would be good to say this in a comment so nobody is a) confused b) tempted later to introduce a footgun.\r\n\r\n(the temptation might come from a user of this library who finds that their tests are breaking half of the time because they had an ordering related bug - or just natural programmer desire for deterministic sort ) ",
      "created_at": "2025-07-31T14:00:45Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245490407",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245490407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245508149",
      "pull_request_review_id": 3075428613,
      "id": 2245508149,
      "node_id": "PRRC_kwDOAP4Jqs6F17w1",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 41,
      "original_position": 33,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: anyone have a nice Python / Ruby incantation to derive the midstates of `BIP0352/...`?",
      "created_at": "2025-07-31T14:07:45Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245508149",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245508149"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 41,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245582298",
      "pull_request_review_id": 3075428613,
      "id": 2245582298,
      "node_id": "PRRC_kwDOAP4Jqs6F2N3a",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 301,
      "original_position": 293,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: it's worth noting somewhere, maybe in the BIP, that _removing_ (omitting) any output `k` later will cause the recipient to not find outputs `> k`  ",
      "created_at": "2025-07-31T14:34:23Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245582298",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245582298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 301,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245635733",
      "pull_request_review_id": 3075428613,
      "id": 2245635733,
      "node_id": "PRRC_kwDOAP4Jqs6F2a6V",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 16,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: \"is set to\" -> \"must be set to ... starting with 0\" (since it's checked).",
      "created_at": "2025-07-31T14:54:50Z",
      "updated_at": "2025-07-31T15:24:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245635733",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245635733"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245675709",
      "pull_request_review_id": 3075428613,
      "id": 2245675709,
      "node_id": "PRRC_kwDOAP4Jqs6F2kq9",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 265,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In eeed5671de059d5812571dc0bfcaee12f10f71e2 _silentpayments: sending_: so the last shall be first, and the first last :-)\r\n\r\nI think it would be more clear to store `recipients[0]->scan_pubkey` instead and call it `current_scan_pubkey`.",
      "created_at": "2025-07-31T15:10:30Z",
      "updated_at": "2025-07-31T15:27:20Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245675709",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245675709"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245789470",
      "pull_request_review_id": 3076017194,
      "id": 2245789470,
      "node_id": "PRRC_kwDOAP4Jqs6F3Ace",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 41,
      "original_position": 33,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Wrote one in C using secp256k1 itself a while ago, see https://github.com/bitcoin-core/secp256k1/issues/1653 (regarding Python, the thread suggests using the https://github.com/cloudtools/sha256 library, but didn't try that yet; with the standard library implementation in `hashlib` it's unfortunately not possible to access the internal state :/).",
      "created_at": "2025-07-31T15:57:43Z",
      "updated_at": "2025-07-31T15:57:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2245789470",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2245789470"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 41,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247461288",
      "pull_request_review_id": 3078444703,
      "id": 2247461288,
      "node_id": "PRRC_kwDOAP4Jqs6F9Ymo",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 9,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245490407,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Following up on this, I misspoke regarding 2). Its not about being constant time (heapsort is $O(n\\log{}n)$ time, $O(1)$ space), but rather heapsort is unstable so there isn't a straightforward way to do a stable, e.g., multi-key, sort.\r\n\r\nEven if there were a straightforward way, I'd still push back since the protocol is _designed_ to not rely on ordering. Rather, the BIP only specifies grouping by scan key and sorting is just our way of implementing \"grouping.\" I'll flesh out the comment to make this more clear.",
      "created_at": "2025-08-01T09:35:28Z",
      "updated_at": "2025-08-01T09:35:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247461288",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247461288"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247485588",
      "pull_request_review_id": 3078478732,
      "id": 2247485588,
      "node_id": "PRRC_kwDOAP4Jqs6F9eiU",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 41,
      "original_position": 33,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245508149,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've had this thought a few times in the past. Opened https://github.com/secp256k1lab/secp256k1lab/issues/10 to discuss further, as that seems like the most natural place to me for an example/script to live.",
      "created_at": "2025-08-01T09:45:47Z",
      "updated_at": "2025-08-01T09:45:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247485588",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247485588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 41,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247487614",
      "pull_request_review_id": 3078481228,
      "id": 2247487614,
      "node_id": "PRRC_kwDOAP4Jqs6F9fB-",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 301,
      "original_position": 293,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245582298,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Great point! I'll add a footnote to the BIP.",
      "created_at": "2025-08-01T09:46:19Z",
      "updated_at": "2025-08-01T09:46:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247487614",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247487614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 301,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247625218",
      "pull_request_review_id": 3078686422,
      "id": 2247625218,
      "node_id": "PRRC_kwDOAP4Jqs6F-AoC",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 265,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245675709,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-08-01T10:35:07Z",
      "updated_at": "2025-08-01T10:35:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247625218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247625218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247629863",
      "pull_request_review_id": 3078693598,
      "id": 2247629863,
      "node_id": "PRRC_kwDOAP4Jqs6F-Bwn",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 16,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245635733,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. I also took out the first sentence, as it seemed to imply we only need to set the index field in certain situations (the index field must always be set, even if only sending to one silent payment recipient).",
      "created_at": "2025-08-01T10:36:24Z",
      "updated_at": "2025-08-01T10:36:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247629863",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247629863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247633383",
      "pull_request_review_id": 3078699912,
      "id": 2247633383,
      "node_id": "PRRC_kwDOAP4Jqs6F-Cnn",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": null,
      "original_position": 9,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245490407,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated the comment to indicate developers cannot and should not rely on deterministic sorting of the recipients.",
      "created_at": "2025-08-01T10:37:16Z",
      "updated_at": "2025-08-01T10:37:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247633383",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247633383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247638059",
      "pull_request_review_id": 3078708175,
      "id": 2247638059,
      "node_id": "PRRC_kwDOAP4Jqs6F-Dwr",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 66,
      "original_position": 45,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245425545,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think this module should include a helper function for this, but we can debate this in a later PR 😉 ",
      "created_at": "2025-08-01T10:39:16Z",
      "updated_at": "2025-08-01T10:39:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247638059",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247638059"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680706",
      "pull_request_review_id": 3078762032,
      "id": 2247680706,
      "node_id": "PRRC_kwDOAP4Jqs6F-OLC",
      "diff_hunk": "@@ -7,10 +7,299 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient. */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n \n-/* TODO: implement functions for receiver side. */\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_calculate_input_hash(unsigned char *input_hash, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    (void)ret;\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_scalar *secret_component, const secp256k1_ge *public_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    /* Compute shared_secret = tweaked_secret_component * Public_component */\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point, considering we have already validated the public key and\n+     * the secret key being used\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+    VERIFY_CHECK(ret && len == 33);\n+    (void)ret;\n+    /* While not technically \"secret\" data, explicitly clear the shared secret since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static void secp256k1_silentpayments_create_t_k(secp256k1_scalar *t_k_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow = 0;\n+\n+    /* Compute t_k = hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    secp256k1_scalar_set_b32(t_k_scalar, hash_ser, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(t_k_scalar));\n+    /* While not technically \"secret\" data, explicitly clear hash and hash_ser since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_memclear(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *P_output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *recipient_labeled_spend_pubkey, uint32_t k) {\n+    secp256k1_ge P_output_ge;\n+    secp256k1_scalar t_k_scalar;\n+\n+    /* Calculate and return P_output_xonly = B_spend + t_k * G\n+     * This will fail if B_spend is the point at infinity or if\n+     * B_spend + t_k*G is the point at infinity.\n+     */\n+    secp256k1_silentpayments_create_t_k(&t_k_scalar, shared_secret33, k);\n+    if (!secp256k1_pubkey_load(ctx, &P_output_ge, recipient_labeled_spend_pubkey)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if t_k_scalar is equal to the dlog of -P_output_ge, but t_k_scalar is the output of a collision resistant hash function.\n+     * This will never happen under normal usage, but we handle this error to anyways to protect against this function being called with a malicious\n+     * B_spend argument, i.e., B_spend = -(_create_t_k(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&P_output_ge, &t_k_scalar)) {\n+        secp256k1_scalar_clear(&t_k_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(P_output_xonly, &P_output_ge);\n+\n+    /* While not technically \"secret\" data, explicitly clear t_k since leaking this would allow an attacker\n+     * to identify the resulting transaction as a silent payments transaction and potentially link the transaction\n+     * back to the silent payment address\n+     */\n+    secp256k1_scalar_clear(&t_k_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar a_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge A_sum_ge;\n+    secp256k1_gej A_sum_gej;\n+    unsigned char input_hash[32];\n+    unsigned char shared_secret[33];\n+    secp256k1_silentpayments_recipient last_recipient;\n+    int overflow = 0;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    /* ensure the index field is set correctly */\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    /* Compute input private keys sum: a_sum = a_1 + a_2 + ... + a_n */\n+    a_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* private keys used for taproot outputs have to be negated if they resulted in an odd point */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&a_sum_scalar, &a_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early */\n+    ret = secp256k1_scalar_is_zero(&a_sum_scalar);\n+    secp256k1_declassify(ctx, &ret, sizeof(ret));\n+    if (ret) {\n+        secp256k1_scalar_clear(&addend);\n+        secp256k1_scalar_clear(&a_sum_scalar);\n+        return 0;\n+    } else {\n+        /* Clear the addend variable as this is no longer needed at this point\n+         * and contains secret data. This saves from needing to remember to clear\n+         * this variable from multiple places below */\n+        secp256k1_scalar_clear(&addend);\n+    }\n+    /* Compute input_hash = hash(outpoint_L || (a_sum * G)) */\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &A_sum_gej, &a_sum_scalar);\n+    secp256k1_ge_set_gej(&A_sum_ge, &A_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &A_sum_ge, sizeof(A_sum_ge));\n+\n+    /* Calculate the input hash and tweak a_sum, i.e., a_sum_tweaked = a_sum * input_hash\n+     * This should fail if input hash is greater than the curve order, but this is stastically improbable so\n+     * we only do a verify_check here.\n+     */\n+    secp256k1_silentpayments_calculate_input_hash(input_hash, outpoint_smallest36, &A_sum_ge);\n+    secp256k1_scalar_set_b32(&input_hash_scalar, input_hash, &overflow);\n+    VERIFY_CHECK(!overflow);\n+    secp256k1_scalar_mul(&a_sum_scalar, &a_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    last_recipient = *recipients[0];\n+    k = 0;\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &last_recipient.scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                /* Explicitly clear variables containing secret data before returning (here and below).\n+                 * While technically not \"secret data,\" explicitly clear the shared secret since leaking this\n+                 * could result in a third party being able to identify the transaction as a silent payments transaction\n+                 * and potentially link the transaction back to a silent payment address.\n+                 */\n+                secp256k1_scalar_clear(&a_sum_scalar);\n+                secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &a_sum_scalar, &pk);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->labeled_spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&a_sum_scalar);\n+            secp256k1_memclear(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        k++;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 301,
      "original_position": 293,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245582298,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done in https://github.com/bitcoin/bips/pull/1908",
      "created_at": "2025-08-01T10:53:04Z",
      "updated_at": "2025-08-01T10:53:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247680706",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680706"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 301,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680951",
      "pull_request_review_id": 3078762423,
      "id": 2247680951,
      "node_id": "PRRC_kwDOAP4Jqs6F-OO3",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.\n+ *\n+ *  `outpoint_smallest` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both silent payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  If necessary, the secret keys are negated to enforce the right y-parity.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 47,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245418259,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-08-01T10:53:14Z",
      "updated_at": "2025-08-01T10:53:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247680951",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247680951"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247682028",
      "pull_request_review_id": 3078764200,
      "id": 2247682028,
      "node_id": "PRRC_kwDOAP4Jqs6F-Ofs",
      "diff_hunk": "@@ -25,6 +26,93 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+/** This struct serves as an input parameter for passing the silent payment\n+ *  address data to `silentpayments_sender_create_outputs`.\n+ *\n+ *  The index field is for when more than one address is being sent to in\n+ *  a transaction. Index is set to the position of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`\n+ *  and used to return the generated outputs matching the original ordering.\n+ *\n+ *  The spend public key field is named `labeled_spend_pubkey` to indicate this\n+ *  spend public key may be tweaked with an optional label. This is not relevant\n+ *  for the sender and is purely a documentation convention to differentiate\n+ *  between other uses of `spend_pubkey` in this API, where it is meant to refer\n+ *  to the unlabeled spend public key.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey labeled_spend_pubkey;\n+    size_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payment outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each silent payment\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs.",
      "path": "include/secp256k1_silentpayments.h",
      "position": null,
      "original_position": 36,
      "commit_id": "b26c87d5c09ddefe764a9cad6a8612e34ccd13de",
      "original_commit_id": "eeed5671de059d5812571dc0bfcaee12f10f71e2",
      "in_reply_to_id": 2245393152,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a reminder, with a prompt to review the BIP for more details.",
      "created_at": "2025-08-01T10:53:46Z",
      "updated_at": "2025-08-01T10:53:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2247682028",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2247682028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1698"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    }
  ]
}